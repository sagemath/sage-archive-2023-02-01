r"""
Tensor products of crystals
"""

#*****************************************************************************
#       Copyright (C) 2007 Anne Schilling <anne at math.ucdavis.edu>
#                          Nicolas Thiery <nthiery at users.sf.net>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
#****************************************************************************

from sage.structure.element    import Element
from sage.combinat.cartan_type import CartanType
from sage.combinat.cartesian_product  import CombinatorialObject, CartesianProduct
from crystals                  import Crystal, CrystalElement
from letters                   import CrystalOfLetters
from sage.misc.flatten         import flatten

##############################################################################
# Support classes
##############################################################################

class ImmutableListWithParent(CombinatorialObject, Element):
    r"""
    A class for lists having a parent

    Specification: any subclass C should implement __init__ which accepts the following
    form C(parent, list = list)

    We create an immutable list whose parent is the class list:

    sage: from sage.combinat.crystals.tensor_product import ImmutableListWithParent
    sage: l = ImmutableListWithParent(list, [1,2,3])

    TESTS:

    sage: l.list == [1, 2, 3]
    True
    sage: l.parent() == list
    True
    sage: l == l
    True
    sage: l.sibling([2,1]) == ImmutableListWithParent(list, [2,1])
    True
    sage: l.reverse()      == l.sibling([3,2,1])
    True
    sage: l.set_index(1,4) == l.sibling([1,4,3])
    True

    """

    def __init__(self, parent, list):
#        Element.__init__(self, parent);
        self._parent = parent
        CombinatorialObject.__init__(self, list)

    def parent(self):
        return self._parent  # Should be inherited from Element!

    def __repr__(self):
        return "%s"%self.list

    def __eq__(self, other):
        return self.__class__ == other.__class__ and \
               self.parent()  == self.parent()   and \
               self.list      == other.list

    def sibling(self, list): # Makes some hypothesis on the constructor!
                             # of subclasses
        return self.__class__(self.parent(), list=list)

    def reverse(self):
        return self.sibling([ i for i in reversed(self.list)])

    def set_index(self, k, value):
        l = [i for i in self.list]
        l[k] = value
        return self.sibling(l)

class TensorProductOfCrystals(Crystal):
    r"""
    Tensor product of crystals

    EXAMPLES:

        We construct the type $A_2$-crystal generated by $2\otimes
        1\otimes 1$:

        sage: C = CrystalOfLetters(['A',2])
        sage: T = TensorProductOfCrystals(C,C,C,generators=[[C(2),C(1),C(1)]])

        It has $8$ elements

        sage: [t for t in T]
        [[2, 1, 1],
        [2, 1, 2],
        [2, 1, 3],
        [3, 1, 3],
        [3, 2, 3],
        [3, 1, 1],
        [3, 1, 2],
        [3, 2, 2]]

    TESTS:
        sage: C = CrystalOfLetters(['A',5])
        sage: T = TensorProductOfCrystals(C,C)

        sage: T(C(1),C(2)).e(1) == T(C(1),C(1))
        True
        sage: T(C(2),C(1)).e(1) == None
        True
        sage: T(C(2),C(2)).e(1) == T(C(1),C(2))
        True

	sage: T(C(1),C(1)).f(1) == T(C(1),C(2))
	True
	sage: T(C(2),C(1)).f(1) == None
	True
	sage: T(C(1),C(2)).f(1) == T(C(2),C(2))
	True

	sage: T(C(2),C(1)).positionsOfUnmatchedMinus(1) == []
	True
	sage: T(C(2),C(1)).positionsOfUnmatchedPlus(1) == []
	True
	sage: T(C(1),C(2)).positionsOfUnmatchedMinus(1) == [0]
	True
	sage: T(C(1),C(2)).positionsOfUnmatchedPlus(1) == [1]
	True
    """
    def __init__(self, *crystals, **options):
        crystals = [ crystal for crystal in crystals]
        self._name = "The tensor product of the crystals %s"%crystals
        self.crystals = crystals
        self.cartanType = crystals[1].cartanType
        self.index_set = self.cartanType.index_set()
        if options.has_key('generators'):
            self.module_generators = [ self(*x) for x in options['generators']]
#             self.module_genera
#         self.module_generators = \
#         [ self(*generator) \
#           for generator in CartesianProduct(*[[x for x in crystal] \
#                                               for crystal in crystals])]

    def __call__(self, *args):
        return TensorProductOfCrystalsElement(self,
                                              [crystalElement for crystalElement in args]);

class TensorProductOfCrystalsElement(ImmutableListWithParent, CrystalElement):
    r"""
    A class for elements of tensor products of crystals
    """

    def e(self, i):
	assert i in self.index_set()
	position = self.positionsOfUnmatchedPlus(i)
	if position == []:
	    return None
	k = position[0]
	return self.set_index(k, self[k].e(i))
#	self[k] = self[k].e(i)
#       return self

    def f(self, i):
	assert i in self.index_set()
	position = self.positionsOfUnmatchedMinus(i)
	if position == []:
	    return None
	k = position[len(position)-1]
	return self.set_index(k, self[k].f(i))
#	self[k] = self[k].f(i)
#	return self

    def phi(self, i):
	self = self.reverse()
	height = 0
	for j in range(len(self)):
	    plus = self[j].epsilon(i)
	    minus = self[j].phi(i)
	    if height-plus < 0:
		height = minus
	    else:
		height = height - plus + minus
	return height

    def epsilon(self, i):
	height = 0
	for j in range(len(self)):
	    minus = self[j].phi(i)
	    plus = self[j].epsilon(i)
	    if height-minus < 0:
		height = plus
	    else:
		height = height - minus + plus
	return height

    def positionsOfUnmatchedMinus(self, i, dual=False, reverse=False):
	unmatchedPlus = []
	height = 0
	if reverse == True:
	    self = self.reverse()
	if dual == False:
	    for j in range(len(self)):
		minus = self[j].phi(i)
		plus = self[j].epsilon(i)
		if height-minus < 0:
		    unmatchedPlus.append(j)
		    height = plus
		else:
		    height = height - minus + plus
	else:
	    for j in range(len(self)):
		plus = self[j].epsilon(i)
		minus = self[j].phi(i)
		if height-plus < 0:
		    unmatchedPlus.append(j)
		    height = minus
		else:
		    height = height - plus + minus
	return unmatchedPlus

    def positionsOfUnmatchedPlus(self, i):
	list = self.positionsOfUnmatchedMinus(i, dual=True, reverse=True)
	list.reverse()
	return [len(self)-1-list[j] for j in range(len(list))]

class CrystalOfTableaux(TensorProductOfCrystals):
    def __init__(self, type, shape):
	C=CrystalOfLetters(type)
	module_generator = flatten([[C(i+1)]*shape[i] for i in range(len(shape))])
	module_generator.reverse()
        TensorProductOfCrystals.__init__(self, *[C]*shape.size(), **{'generators':[module_generator]})
	self._name = "The crystal of tableaux of type%s"%type

    def __call__(self, *args, **options):
	if not options.has_key('rows') and isinstance(args[0], Element) and args[0].parent() == self:
	    return args[0];
        return CrystalOfTableauxElement(self, *args, **options);

class CrystalOfTableauxElement(TensorProductOfCrystalsElement):
    def __init__(self, parent, *args, **options):
	if options.has_key('list'):
	    list = options['list']
	elif options.has_key('rows'):
	    rows=options['rows']
	    C=CrystalOfLetters(parent.cartanType)
	    list = []
	    l = len(rows)
	    for i in range(l):
		for x in rows[i]:
		    list.append(C(x))
        else:
	    list = [i for i in args]
	TensorProductOfCrystalsElement.__init__(self, parent, list=list)

    def to_tableau(self):
	tab = [ [self[0]] ]
	for i in range(1,len(self)):
	    if self[i-1].value > self[i].value:
		tab.append([self[i]])
	    else:
		l = len(tab)-1
		tab[l].append(self[i])
	return tab
