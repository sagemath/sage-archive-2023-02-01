# Makefile template for Sage packages: This Makefile is filled by the
# ./configure script with information all of Sage's dependent packages (SPKGs),
# including their names, their current versions, their dependencies, and some
# classifications according to their installation priority ("standard",
# "optional") and installation method ("normal", "pip", "script").
#
# Finally, install and clean rules for each package are generated from the
# templates at the end of this file.  Because the templates may slightly
# obscure the substance of the actual rules, this file can be debugged by
# running:
#
#     $ make -f build/make/Makefile -n DEBUG_RULES=1
#
# This will not actually run any rules (the -n flag) but will print all the
# rules generated from the templates.

# Always use bash for make rules
SHELL = @SHELL@

# Check a variable that is only set in build/make/install, but not in sage-env, for example
ifndef SAGE_PKGCONFIG
# Set by build/bin/sage-sdist, which invokes the Makefile directly in
# order to download upstream packages for distribution.
ifndef SAGE_SPKG_COPY_UPSTREAM
$(error This Makefile needs to be invoked by build/make/install)
endif
endif

# Directory to keep track of which packages are installed - relative to installation prefix
SPKG_INST_RELDIR = var/lib/sage/installed

# Aliases for mutually exclusive standard packages selected at configure time
TOOLCHAIN = @SAGE_TOOLCHAIN@
PYTHON = python3
MP_LIBRARY = @SAGE_MP_LIBRARY@
BLAS = @SAGE_BLAS@

# pkgconfig files generated/installed at build time
PCFILES = @SAGE_SYSTEM_FACADE_PC_FILES@

LN = ln
SED = sed

# In recursive invocations of make, remove "-jNUMJOBS" options that may
# be in $(MAKE) when users follow the recommendations in our manuals.
# We also get rid of excessive "Entering directory" messages.
MAKE_REC = $(MAKE:-j%=) --no-print-directory

# We need to be able to override this to support ./sage -i -c PKG
SAGE_SPKG = sage-spkg

# These are added to SAGE_SPKG in the call
SAGE_SPKG_OPTIONS = @SAGE_SPKG_OPTIONS@

# Where the Sage distribution installs Python packages.
# This can be overridden by 'make SAGE_VENV=/some/venv'.
SAGE_VENV = @SAGE_VENV@

# Generate/install sage-specific .pc files.
# see build/pkgs/gsl/spkg-configure.m4
$(SAGE_PKGCONFIG)/gsl.pc:
	-rm -f $@
	@SAGE_GSL_PC_COMMAND@

# see build/pkgs/openblas/spkg-configure.m4
$(SAGE_PKGCONFIG)/openblas.pc $(SAGE_PKGCONFIG)/blas.pc $(SAGE_PKGCONFIG)/cblas.pc $(SAGE_PKGCONFIG)/lapack.pc:
	-rm -f $@
	@SAGE_OPENBLAS_PC_COMMAND@

# Files to track installation of packages
BUILT_PACKAGES = @SAGE_BUILT_PACKAGES@
DUMMY_PACKAGES = @SAGE_DUMMY_PACKAGES@

# Set to the path to Sage's GCC (if GCC is installed) to force rebuilds
# of packages if GCC changed.
# See m4/sage_spkg_collect.m4 and https://trac.sagemath.org/ticket/24703
GCC_DEP = @SAGE_GCC_DEP@

# Versions of all the packages, in the format
#
# vers_<pkgname> = <pkgvers>

@SAGE_PACKAGE_VERSIONS@

# Dependencies for all packages, in the format
#
# deps_<pkgname> = <dep1> <dep2> etc...

@SAGE_PACKAGE_DEPENDENCIES@

# Installation trees for all packages, in the format:
#
# - for a non-Python package:
#
#   trees_<pkgname1> = SAGE_LOCAL
#
# - for a Python package:
#
#   trees_<pkgname2> = SAGE_VENV

@SAGE_PACKAGE_TREES@

# All standard/optional/experimental installed packages (triggers the auto-update)
OPTIONAL_INSTALLED_PACKAGES = @SAGE_OPTIONAL_INSTALLED_PACKAGES@
INSTALLED_PACKAGES = $(OPTIONAL_INSTALLED_PACKAGES)
INSTALLED_PACKAGE_INSTS = \
    $(foreach pkgname,$(INSTALLED_PACKAGES),$(inst_$(pkgname)))

# All previously installed standard/optional/experimental packages that are to be uninstalled
OPTIONAL_UNINSTALLED_PACKAGES = @SAGE_OPTIONAL_UNINSTALLED_PACKAGES@
UNINSTALLED_PACKAGES = $(OPTIONAL_UNINSTALLED_PACKAGES)
UNINSTALLED_PACKAGES_CLEANS = $(UNINSTALLED_PACKAGES:%=%-clean)

# All packages which should be downloaded
SDIST_PACKAGES = @SAGE_SDIST_PACKAGES@

# Packages that use the 'normal' build rules
NORMAL_PACKAGES = @SAGE_NORMAL_PACKAGES@

# Packages that use the 'pip' package build rules
PIP_PACKAGES = @SAGE_PIP_PACKAGES@

# Packages that use the 'script' package build rules
SCRIPT_PACKAGES = @SAGE_SCRIPT_PACKAGES@



# Generate the actual inst_<pkgname> variables; for each package that is
# actually built this generates a line like:
#
# inst_<pkgname> = $(INST)/<pkgname>-<pkgvers>
#
# And for 'dummy' package that are not actually built/installed (e.g. because
# configure determined we can use the package from the system):
#
# inst_<pkgname> = $(INST)/.dummy
#
# For example:
#
# inst_python3 = $(INST)/python3-$(vers_python3)
#
# inst_git = $(INST)/.dummy

$(foreach pkgname,$(BUILT_PACKAGES),\
	$(eval inst_$(pkgname) = $(foreach tree, $(trees_$(pkgname)), $($(tree))/$(SPKG_INST_RELDIR)/$(pkgname)-$(vers_$(pkgname)))))
$(foreach pkgname,$(DUMMY_PACKAGES),\
	$(eval inst_$(pkgname) = $(SAGE_LOCAL)/$(SPKG_INST_RELDIR)/.dummy))

# Override this for pip packages, for which we do not keep an installation record
# in addition to what pip is already doing.
$(foreach pkgname,$(PIP_PACKAGES),\
	$(eval inst_$(pkgname) = $(pkgname)))

# Dummy target for packages which are not installed
$(SAGE_LOCAL)/$(SPKG_INST_RELDIR)/.dummy:
	touch $@


# Filtered by installation tree
$(foreach tree,SAGE_LOCAL SAGE_VENV, \
    $(eval $(tree)_INSTALLED_PACKAGE_INSTS = \
               $(foreach pkgname,$(INSTALLED_PACKAGES), \
                         $(if $(findstring $(tree),$(trees_$(pkgname))), \
                              $(inst_$(pkgname))))) \
    $(eval $(tree)_CLEANED_PACKAGE_CLEANS = \
               $(foreach pkgname,$(INSTALLED_PACKAGES), \
                         $(if $(findstring $(tree),$(trees_$(pkgname))), \
                              $(inst_$(pkgname))))))


###############################################################################

# Silent rules
# https://www.gnu.org/software/automake/manual/html_node/Automake-Silent-Rules.html
ifeq ($(V), 0)
AM_V_at = @
else
AM_V_at =
endif

# List of targets that can be run using `sage -i` or `sage -f`
# These should generally have an associated -clean target for `sage -f` to
# work correctly
SAGE_I_TARGETS = sagelib doc

# Tell make not to look for files with these names:
.PHONY: all all-sage all-toolchain all-build all-sageruntime \
	all-start build-start base toolchain toolchain-deps base-toolchain \
	sagelib \
	doc doc-html doc-html-jsmath doc-html-mathjax doc-pdf \
	doc-clean doc-src-clean doc-output-clean \
	clean sagelib-clean build-clean python3_venv _clean-broken-gcc

PYTHON_FOR_VENV = @PYTHON_FOR_VENV@

ifneq ($(PYTHON_FOR_VENV),)
# Special rule for making the Python virtualenv from the system Python (Python
# 3 only).  $(PYTHON) is set in Makefile to python3_venv.
# Thus $(inst_python3_venv) will be the dependency of every Python package.
#
# TODO: If we reconfigure to build our own Python after having used the system
# Python, files installed to create the virtualenv should be *removed*.  That
# could either be done here by the makefile, or in an spkg-preinst for python3
ifeq ($(PYTHON),python3)
PYTHON = python3_venv
endif
inst_python3_venv = $(SAGE_VENV)/pyvenv.cfg

$(inst_python3_venv):
	$(PYTHON_FOR_VENV) $(SAGE_ROOT)/build/bin/sage-venv "$(SAGE_VENV)"
endif

# Build everything and start Sage.
# Note that we put the "doc" target first in the rule below because
# the doc build takes the most time and should be started as soon as
# possible.
all-start: toolchain-deps
	+$(MAKE_REC) doc all-sage

# Build everything except the documentation
all-build: toolchain-deps
	+$(MAKE_REC) all-sage

# This used to do run "sage-starts" script, now it's just an alias
build-start: all-build

# The 2 preliminary build phases: base and toolchain.
base-toolchain: _clean-broken-gcc base
	+$(MAKE_REC) toolchain

# All targets except for the base packages
all-sage: \
		$(INSTALLED_PACKAGE_INSTS) \
                $(UNINSTALLED_PACKAGES_CLEANS)

# Same but filtered by installation trees:
all-build-local: toolchain-deps
	+$(MAKE_REC) all-sage-local

all-sage-local: $(SAGE_LOCAL_INSTALLED_PACKAGE_INSTS) $(SAGE_LOCAL_UNINSTALLED_PACKAGES_CLEANS)

all-build-venv: toolchain-deps
	+$(MAKE_REC) all-sage-venv

all-sage-venv:  $(SAGE_VENV_INSTALLED_PACKAGE_INSTS)  $(SAGE_VENV_UNINSTALLED_PACKAGES_CLEANS)

# Download all packages which should be inside an sdist tarball (the -B
# option to make forces all targets to be built unconditionally)
download-for-sdist:
	+env SAGE_INSTALL_FETCH_ONLY=yes $(MAKE_REC) -B SAGERUNTIME= \
		$(SDIST_PACKAGES)

# TOOLCHAIN consists of dependencies determined by configure.
# These are built after the "base" target but before anything else.
toolchain: $(foreach pkgname,$(TOOLCHAIN),$(inst_$(pkgname))) $(PCFILES)

# Build all packages that GCC links against serially, otherwise this
# leads to race conditions where some library which is used by GCC gets
# reinstalled. Since system GCCs might use Sage's libraries, we do this
# unconditionally. We still use the dependency checking from $(MAKE),
# so this will not trigger useless rebuilds.
# See #14168 and #14232.
#
# Note: This list consists of only the *runtime* dependencies of the toolchain.
TOOLCHAIN_DEPS = zlib $(MP_LIBRARY) mpfr mpc
TOOLCHAIN_DEP_INSTS = \
	$(foreach pkgname,$(TOOLCHAIN_DEPS),$(inst_$(pkgname)))

toolchain-deps:
	+@for target in $(TOOLCHAIN_DEP_INSTS); do \
	    echo $(MAKE_REC) $$target; \
	    $(MAKE_REC) $$target; \
	done

all-toolchain: base-toolchain
	+$(MAKE_REC) toolchain-deps

# All packages needed as a prerequisite to install other Python packages with
# pip or which are otherwise used by the Python build tools; these should be
# given as a prerequisite to any pip-installed packages
PYTHON_TOOLCHAIN = setuptools pip setuptools_scm wheel setuptools_wheel

# Trac #32056: Avoid installed setuptools leaking into the build of python3 by uninstalling it.
# It will have to be reinstalled anyway because of its dependency on $(PYTHON).
python3-SAGE_LOCAL-no-deps: setuptools-clean
python3-SAGE_VENV-no-deps: setuptools-clean

# Everything needed to start up Sage using "./sage".  Of course, not
# every part of Sage will work.  It does not include Maxima for example.
SAGERUNTIME = sagelib $(inst_ipython) $(inst_pexpect) \
		$(inst_psutil)

all-sageruntime: toolchain-deps
	+$(MAKE_REC) $(SAGERUNTIME)


###############################################################################
# Building the base system
#
# This consists of packages which are required for the Sage build system.
###############################################################################
base: $(inst_patch) $(inst_pkgconf)

###############################################################################
# Building the documentation
###############################################################################

# You can choose to have the built HTML version of the documentation link to
# the PDF version. To do so, you need to build both the HTML and PDF versions.
# To have the HTML version link to the PDF version, do
#
# $ ./sage --docbuild all html
# $ ./sage --docbuild all pdf
#
# For more information on the docbuild utility, do
#
# $ ./sage --docbuild -H

# Building the documentation has many dependencies, because all
# documented modules are imported and because we use matplotlib to
# produce plots.
DOC_DEPENDENCIES = sagelib sage_docbuild $(inst_sphinx) \
	| $(SAGERUNTIME) $(inst_maxima) $(inst_networkx) $(inst_scipy) $(inst_sympy) \
	$(inst_matplotlib) $(inst_pillow) $(inst_mathjax) $(inst_mpmath) \
	$(inst_ipykernel) $(inst_jupyter_client) $(inst_conway_polynomials) \
	$(inst_tachyon) $(inst_jmol) $(inst_thebe) $(inst_ipywidgets)

doc: doc-html

doc-html: $(DOC_DEPENDENCIES)
	$(AM_V_at)cd "$(SAGE_SRC)/doc" && sage-logger -p "$(MAKE) doc-html" $(SAGE_ROOT)/logs/dochtml.log

# 'doc-html-no-plot': build docs without building the graphics coming
# from the '.. plot' directive, in case you want to save a few
# megabytes of disk space. 'doc-clean' is a prerequisite because the
# presence of graphics is cached in src/doc/output.
doc-html-no-plot: doc-clean
	$(AM_V_at)sage-logger -p "$(MAKE) SAGE_DOCBUILD_OPTS=\"$(SAGE_DOCBUILD_OPTS) --no-plot\" doc-html" $(SAGE_ROOT)/logs/dochtml.log

doc-html-mathjax:
	$(AM_V_at)sage-logger -p "$(MAKE) SAGE_DOCBUILD_OPTS=\"$(SAGE_DOCBUILD_OPTS) -j\" doc-html" $(SAGE_ROOT)/logs/dochtml.log

# Keep target 'doc-html-jsmath' for backwards compatibility.
doc-html-jsmath: doc-html-mathjax

doc-pdf: $(DOC_DEPENDENCIES)
	$(AM_V_at)cd "$(SAGE_SRC)/doc" && sage-logger -p "$(MAKE) doc-pdf" $(SAGE_ROOT)/logs/docpdf.log

doc-clean: doc-src-clean doc-output-clean

doc-src-clean:
	cd "$(SAGE_SRC)/doc" && $(MAKE) clean

doc-output-clean:
	rm -rf "$(SAGE_SHARE)/doc/sage"


###############################################################################
# Cleaning up
###############################################################################

clean:
	@echo "Deleting package build directories..."
	rm -rf "$(SAGE_LOCAL)/var/tmp/sage/build"

# "c_lib", ".cython_version", "build" in $(SAGE_SRC) are from old sage versions
# Cleaning .so files (and .c and .cpp files associated with .pyx files) is for editable installs.
# Also cython_debug is for editable installs.
sagelib-clean:
	@echo "Deleting Sage library build artifacts..."
	(cd "$(SAGE_SRC)" && \
	 rm -rf c_lib .cython_version cython_debug; \
	 rm -rf build; find . -name '*.pyc' -o -name "*.so" | xargs rm -f; \
	 rm -f $$(find . -name "*.pyx" | sed 's/\(.*\)[.]pyx$$/\1.c \1.cpp/'); \
	 rm -rf sage/ext/interpreters) \
	&& (cd "$(SAGE_ROOT)/build/pkgs/sagelib/src/" && rm -rf build)

sage_docbuild-clean:
	(cd "$(SAGE_ROOT)/build/pkgs/sage_docbuild/src" && rm -rf build)

sage_setup-clean:
	(cd "$(SAGE_ROOT)/build/pkgs/sage_setup/src" && rm -rf build)

build-clean: clean doc-clean sagelib-clean sage_docbuild-clean

# Special target for cleaning up a broken GCC install detected by configure
# This should check for the .clean-broken-gcc stamp, and if found clean
# everything up along with the stamp file itself.  This target is then run
# as a prerequisite to installing any other packages.
_clean-broken-gcc:
	@if [ -f "$(SAGE_ROOT)/build/make/.clean-broken-gcc" ]; then \
	   rm -f "$(SAGE_LOCAL)/bin/gcc"; \
	   rm -f "$(SAGE_LOCAL)/gcc-"*; \
	   rm -f "$(SAGE_LOCAL)/bin/g++"; \
	   rm -f "$(SAGE_SPKG_INST)/gcc-"*; \
	   rm -f "$(SAGE_ROOT)/build/make/.clean-broken-gcc"; \
	   echo "Cleaned up old broken GCC install"; \
	fi

#==============================================================================
# Setting SAGE_CHECK... variables
#==============================================================================
ifeq "$(origin SAGE_CHECK)" "undefined"
SAGE_CHECK := no
endif

define SET_SAGE_CHECK
$(eval SAGE_CHECK_$(1) := $(2))
endef
# Set defaults
$(foreach pkgname, $(NORMAL_PACKAGES),\
	$(eval $(call SET_SAGE_CHECK,$(pkgname),$(SAGE_CHECK))))

# Parsing the SAGE_CHECK_PACKAGES variable:
# - if this contains "!pkg", set SAGE_CHECK_pkg=no.
# - if this contains "?pkg", set SAGE_CHECK_pkg=warn.
# - if this contains "pkg",  set SAGE_CHECK_pkg=yes.
#
# We check this now and export SAGE_CHECK_pkg for
# dependencies and the Makefile rules.
#
# Since Python's self-tests seem to fail on all platforms, we disable
# its test suite by default.
# However, if SAGE_CHECK=warn, we do not do that.
SAGE_CHECK_PACKAGES_DEFAULT_yes := !python3
SAGE_CHECK_PACKAGES_DEFAULT_warn :=
SAGE_CHECK_PACKAGES_DEFAULT_no :=
comma := ,
ifeq "$(origin SAGE_CHECK_PACKAGES)" "undefined"
SAGE_CHECK_PACKAGES := $(SAGE_CHECK_PACKAGES_DEFAULT_$(SAGE_CHECK))
endif
SAGE_CHECK_PACKAGES_sep := $(subst $(comma), ,$(SAGE_CHECK_PACKAGES))
SAGE_CHECK_PACKAGES_sep := $(subst :, ,$(SAGE_CHECK_PACKAGES_sep))
$(foreach clause, $(SAGE_CHECK_PACKAGES_sep),					\
     $(if $(findstring !,$(clause)),						\
	  $(eval $(call SET_SAGE_CHECK,$(subst !,,$(clause)),no)),		\
	  $(if $(findstring ?,$(clause)),					\
	       $(eval $(call SET_SAGE_CHECK,$(subst ?,,$(clause)),warn)),	\
	       $(eval $(call SET_SAGE_CHECK,$(clause),yes)))))
debug-check:
	@echo $(foreach pkgname, $(NORMAL_PACKAGES), SAGE_CHECK_$(pkgname) = $(SAGE_CHECK_$(pkgname)))


#==============================================================================
# Rules generated from pkgs/<package>/dependencies files
#==============================================================================

# Define a function for generating the list of a package's dependencies
# as $(inst_<pkgname>) variables.  For example, takes:
#
#     deps_cysignals = python3 cython pari | pip
#
# to:
#
#     $(inst_python3) $(inst_cython) $(inst_pari) | $(inst_pip)
#
# If some value in the dependencies list is not a package name (e.g. it is
# the name of some arbitrary file, or it is the '|' symbol) then it is just
# used verbatim.
#
# As a special case, also adds a special variable GCC_DEP for all packages
# except for gcc itself.  See the definition of GCC_DEP above
#
# Positional arguments:
#     $(1): package name
pkg_deps = \
	$(if $(filter gcc,$(1)),,$$(GCC_DEP))\
	$(foreach dep,$(deps_$(1)),\
        $(if $(value inst_$(dep)),$$(inst_$(dep)),$(dep)))

# ============================= normal packages ==============================
# Generate build rules for 'normal' packages; this template is used to generate
# rules in the form:
#
# $(INST)/<pkgname>-<pkgvers>: <dependencies>
#     $(MAKE) $(1)-no-deps
#
# <pkgname>: $(INST)/<pkgname>-<pkgvers>
#
# <pkgname>-build-deps: <dependencies>
#
# <pkgname>-no-deps:
#     +$(AM_V_at)sage-logger -p '$(SAGE_SPKG) <pkgname>-<pkgvers>' '$(SAGE_LOGS)/<pkgname>-<pkgvers>.log'
#
# <pkgname>-clean:
#     sage-spkg-uninstall <pkgname> '$(SAGE_LOCAL)'
#
# So <pkgname>-build-deps installs just the dependencies, while
# <pkgname>-no-deps tries to install the package without its
# dependencies. This is currently used in SAGE_SRC/bin/sage when
# running 'sage -b' to build the Sage library.
#
# For example, for python3 this will expand to:
#
# $(INST)/python3-3.7.3: $(inst_zlib) $(inst_readline) $(inst_sqlite) $(inst_libpng) $(inst_bzip2) $(inst_xz) $(inst_libffi)
#     +$(AM_V_at)sage-logger -p '$(SAGE_SPKG) python3-3.7.3' '$(SAGE_LOGS)/python3-3.7.3.log'
#
# python3: $(INST)/python3-3.7.3
#
# python3-clean:
#     sage-spkg-uninstall python3 '$(SAGE_LOCAL)'
#
# Note: In these rules the $(INST)/<pkgname>-<pkgvers> target is used
# explicitly, rather than expanding the $(inst_<pkgname>) variable, since
# it may expand to $(INST)/.dummy for packages that were not configured
# for installation by default.  However, we wish to be able to manually
# install those packages later.
#
# For packages listed in $(TOOLCHAIN_DEPS) we also pass --keep-existing to
# sage-spkg, and --keep-files to sage-spkg-uninstall since those packages can
# have a recursive self-dependency, and should not be deleted while upgrading.
# See Trac #25857

# Positional arguments:
#     $(1): package name
#     $(2): package version
#     $(3): package dependencies
#     $(4): package tree variable

define NORMAL_PACKAGE_templ ##########################################

$(1)-build-deps: $(3)

$$($(4))/$(SPKG_INST_RELDIR)/$(1)-$(2): $(3)
	+$(MAKE_REC) $(1)-$(4)-no-deps

$(1): $$($(4))/$(SPKG_INST_RELDIR)/$(1)-$(2)

$(1)-$(4)-no-deps:
	+$(AM_V_at)sage-logger -p 'SAGE_CHECK=$$(SAGE_CHECK_$(1)) PATH=$$($(4))/bin:$$$$PATH $$(SAGE_SPKG) $$(SAGE_SPKG_OPTIONS) \
		$(if $(filter $(1),$(TOOLCHAIN_DEPS)),--keep-existing) \
		$(1)-$(2) $$($(4))' '$$(SAGE_LOGS)/$(1)-$(2).log'

$(1)-no-deps: $(1)-$(4)-no-deps

$(1)-$(4)-clean:
	if [ -d '$$($(4))' ]; then \
	    sage-spkg-uninstall $(if $(filter $(1),$(TOOLCHAIN_DEPS)),--keep-files) \
		$(1) '$$($(4))'; \
	fi

$(1)-clean: $(1)-$(4)-clean

.PHONY: $(1) $(1)-clean $(1)-build-deps $(1)-no-deps
endef #################################################################

$(foreach pkgname, $(NORMAL_PACKAGES),\
    $(foreach tree, $(trees_$(pkgname)), \
	$(eval $(call NORMAL_PACKAGE_templ,$(pkgname),$(vers_$(pkgname)),\
	                                   $(call pkg_deps,$(pkgname)),$(tree)))))

ifdef DEBUG_RULES
$(info # Rules for standard packages)
$(foreach pkgname, $(NORMAL_PACKAGES),\
    $(foreach tree, $(trees_$(pkgname)), \
	$(info $(call NORMAL_PACKAGE_templ,$(pkgname),$(vers_$(pkgname)),\
	                                   $(call pkg_deps,$(pkgname)),$(tree)))))
endif

# ================================ pip packages ===============================
# Generate build rules for 'pip' packages; this template is used to generate
# two rules in the form:
#
# <pkgname>: <dependencies>
#     $(AM_V_at)sage-logger -p 'sage --pip install ...' '$(SAGE_LOGS)/<pkgname>.log'
#
# <pkgname>-clean:
#     -sage --pip uninstall -y ...

# Positional arguments:
#     $(1): package name
#     $(2): package dependencies
define PIP_PACKAGE_templ
$(1)-build-deps: $(2)

$(1): $(2)
	+$(MAKE_REC) $(1)-no-deps

$(1)-no-deps:
	$(AM_V_at)sage-logger -p 'sage --pip install -r "$$(SAGE_ROOT)/build/pkgs/$(1)/requirements.txt"' '$$(SAGE_LOGS)/$(1).log'

$(1)-clean:
	-sage --pip uninstall --isolated --yes --no-input -r '$$(SAGE_ROOT)/build/pkgs/$(1)/requirements.txt'

.PHONY: $(1) $(1)-clean $(1)-build-deps $(1)-no-deps
endef

$(foreach pkgname,$(PIP_PACKAGES),\
	$(eval $(call PIP_PACKAGE_templ,$(pkgname),$(call pkg_deps,$(pkgname)))))

ifdef DEBUG_RULES
$(info # Rules for pip packages)
$(foreach pkgname,$(PIP_PACKAGES),\
	$(info $(call PIP_PACKAGE_templ,$(pkgname),$(call pkg_deps,$(pkgname)))))
endif

# ============================= script packages ==============================
# Generate build rules for 'script' packages; this template is used to generate
# three rules in the form:
#
# $(INST)/<pkgname>-<pkgvers>: <dependencies>
#     $(AM_V_at)cd '$SAGE_ROOT' && \\
#         . '$SAGE_ROOT/src/bin/sage-env-config' && \\
#         . '$SAGE_ROOT/src/bin/sage-env' && \\
#         . '$SAGE_ROOT/build/bin/sage-build-env-config' && \\
#         . '$SAGE_ROOT/build/bin/sage-build-env' && \\
#         sage-logger -p '$SAGE_ROOT/build/pkgs/<pkgname>/spkg-install' '$(SAGE_LOGS)/<pkgname>.log'
#
# <pkgname>: $(INST)/<pkgname>-<pkgvers>
#
# <pkgname>-clean:
#     -$(AM_V_at)cd '$SAGE_ROOT' && \\
#         . '$SAGE_ROOT/src/bin/sage-env-config' && \\
#         . '$SAGE_ROOT/src/bin/sage-env' && \\
#         . '$SAGE_ROOT/build/bin/sage-build-env-config' && \\
#         . '$SAGE_ROOT/build/bin/sage-build-env' && \\
#         '$SAGE_ROOT/build/pkgs/$PKG_NAME/spkg-uninstall'

# Positional arguments:
#     $(1): package name
#     $(2): package version
#     $(3): package dependencies
#     $(4): package tree variable

define SCRIPT_PACKAGE_templ
$(1)-build-deps: $(3)

$$($(4))/$(SPKG_INST_RELDIR)/$(1)-$(2): $(3)
	+$(MAKE_REC) $(1)-$(4)-no-deps

$(1): $$($(4))/$(SPKG_INST_RELDIR)/$(1)-$(2)

$(1)-$(4)-no-deps:
	$(AM_V_at)cd '$$(SAGE_ROOT)/build/pkgs/$(1)' && \
		. '$$(SAGE_ROOT)/src/bin/sage-src-env-config' && \
		. '$$(SAGE_ROOT)/src/bin/sage-env-config' && \
		. '$$(SAGE_ROOT)/src/bin/sage-env' && \
		. '$$(SAGE_ROOT)/build/bin/sage-build-env-config' && \
		. '$$(SAGE_ROOT)/build/bin/sage-build-env' && \
		SAGE_SPKG_WHEELS=$$($(4))/var/lib/sage/wheels \
		SAGE_INST_LOCAL=$$($(4)) \
		sage-logger -p '$$(SAGE_ROOT)/build/pkgs/$(1)/spkg-install' '$$(SAGE_LOGS)/$(1)-$(2).log'
	touch "$$($(4))/$(SPKG_INST_RELDIR)/$(1)-$(2)"

$(1)-no-deps: $(1)-$(4)-no-deps

$(1)-$(4)-uninstall:
	-$(AM_V_at)cd '$$(SAGE_ROOT)/build/pkgs/$(1)' && \
		. '$$(SAGE_ROOT)/src/bin/sage-src-env-config' && \
		. '$$(SAGE_ROOT)/src/bin/sage-env-config' && \
		. '$$(SAGE_ROOT)/src/bin/sage-env' && \
		. '$$(SAGE_ROOT)/build/bin/sage-build-env-config' && \
		. '$$(SAGE_ROOT)/build/bin/sage-build-env' && \
		'$$(SAGE_ROOT)/build/pkgs/$(1)/spkg-uninstall'
	-rm -f "$$($(4))/$(SPKG_INST_RELDIR)/$(1)-$(2)"

$(1)-uninstall: $(1)-$(4)-uninstall

$(1)-clean: $(1)-uninstall

.PHONY: $(1) $(1)-uninstall $(1)-build-deps $(1)-no-deps $(1)-clean
endef

$(foreach pkgname,$(SCRIPT_PACKAGES),\
    $(foreach tree, $(trees_$(pkgname)), \
	$(eval $(call SCRIPT_PACKAGE_templ,$(pkgname),$(vers_$(pkgname)),$(call pkg_deps,$(pkgname)),$(tree)))))

ifdef DEBUG_RULES
$(info # Rules for script packages)
$(foreach pkgname,$(SCRIPT_PACKAGES),\
    $(foreach tree, $(trees_$(pkgname)), \
	$(info $(call SCRIPT_PACKAGE_templ,$(pkgname),$(vers_$(pkgname)),$(call pkg_deps,$(pkgname)),$(tree)))))
endif

# sagelib depends on this so that its install script is always executed
FORCE:

# Use this target to list common targets of this Makefile (in particular for
# installation with `sage -i`.
list:
	@for pkg in $(SAGE_I_TARGETS) $(NORMAL_PACKAGES) $(PIP_PACKAGES) $(SCRIPT_PACKAGES); do\
		echo $$pkg;\
	done


.PHONY: list
