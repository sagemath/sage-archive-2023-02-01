# -*- shell-script -*-

###########################################################################
#
#  Set environment variables for building and/or running Sage.
#
#  NOTES:
#  - You must *source* this script instead of executing.
#  - Use "return" instead of "exit" to signal a failure.  Since this
#    file is sourced, an "exit" here will actually exit src/bin/sage,
#    which is probably not intended.
#  - All environment variables set here should be *exported*, otherwise
#    they won't be available in child programs.
#  - This script has a version number such that a newer version of
#    sage-env can be sourced when upgrading.  See below.
#
#  If you want to set all environment variables for your shell like
#  they are during the build of Sage packages, type
#
#             . src/bin/sage-env
#
#  from the SAGE_ROOT directory.
#
#  AUTHORS: William Stein, David Kirkby, Jeroen Demeyer,
#           J. H. Palmieri, Leif Leonhardy and others.
#
##########################################################################

# Resolve all symbolic links in a filename.  This more or less behaves
# like "readlink -f" except that it does not convert the filename to an
# absolute path (a relative path remains relative), nor does it treat
# "." or ".." specially.
#
# AUTHOR: Jeroen Demeyer (2011-08-23): Trac tickets #5852 and #11704
#
resolvelinks() {
    # $in is what still needs to be converted (normally has no starting slash)
    in="$1"
    # $out is the part which is converted (normally ends with trailing slash)
    out="./"

    # Move stuff from $in to $out
    while [ -n "$in" ]; do
        # Normalize $in by replacing consecutive slashes by one slash
        in=$(echo "${in}" | sed 's://*:/:g')

        # If $in starts with a slash, remove it and set $out to the root
        in_without_slash=${in#/}
        if [ "$in" != "$in_without_slash" ]; then
            in=$in_without_slash
            out="/"
            continue
        fi

        # Check that the directory $out exists by trying to cd to it.
        # If this fails, then cd will show an error message (unlike
        # test -d "$out"), so no need to be more verbose.
        ( cd "$out" ) || return $?


        # Get the first component of $in
        f=${in%%/*}

        # If it is not a symbolic link, simply move it to $out
        if [ ! -L "$out$f" ]; then
            in=${in#"$f"}
            out="$out$f"

            # If the new $in starts with a slash, move it to $out
            in_without_slash=${in#/}
            if [ "$in" != "$in_without_slash" ]; then
                in=$in_without_slash
                out="$out/"
            fi
            continue
        fi

        # Now resolve the symbolic link "$f"
        f_resolved=`readlink -n "$out$f" 2>/dev/null`
        status=$?
        # status 127 means readlink could not be found.
        if [ $status -eq 127 ]; then
            # We don't have "readlink", try a stupid "ls" hack instead.
            # This will fail if we have filenames like "a -> b".
            fls=`ls -l "$out$f" 2>/dev/null`
            status=$?
            f_resolved=${fls##*-> }

            # If $fls equals $f_resolved, then certainly
            # something is wrong
            if [ $status -eq 0 -a "$fls" = "$f_resolved" ]; then
                echo >&2 "Cannot parse output from ls -l '$out$f'"
                return 1
            fi
        fi
        if [ $status -ne 0 ]; then
            echo >&2 "Cannot read symbolic link '$out$f'"
            return $status
        fi

        # In $in, replace $f by $f_resolved (leave $out alone)
        in="${in#${f}}"
        in="${f_resolved}${in}"
    done

    # Return $out
    echo "$out"
}

# New value for SAGE_ROOT: either SAGE_ROOT (if given)
# or a guessed value based on pwd.
if [ -n "$SAGE_ROOT" ]; then
    NEW_SAGE_ROOT="$SAGE_ROOT"
elif [ -f sage -a -d build ]; then
    NEW_SAGE_ROOT="."
elif [ -f ../../sage -a -d ../../build ]; then
    NEW_SAGE_ROOT="../.."
fi

if [ -n "$NEW_SAGE_ROOT" ]; then
    # Make NEW_SAGE_ROOT absolute
    NEW_SAGE_ROOT=`cd "$NEW_SAGE_ROOT" && pwd -P`

    # Warn if NEW_SAGE_ROOT does not equal the old SAGE_ROOT
    if [ "$SAGE_ROOT" != "$NEW_SAGE_ROOT" -a -n "$SAGE_ROOT" ]; then
        echo >&2 "Warning: overwriting SAGE_ROOT environment variable:"
        echo >&2 "Old SAGE_ROOT=$SAGE_ROOT"
        echo >&2 "New SAGE_ROOT=$NEW_SAGE_ROOT"
    fi
fi


# Don't execute the commands more than once for the same version of
# sage-env.  Check this after checking the validity of SAGE_ROOT, but
# before modifying its value.
#
# The idea of versioning is that SAGE_ENV_SOURCED will be set to a
# "version number" of sage-env.  If a different version of sage-env was
# sourced earlier (when upgrading), we still source the new version.
# The sage-env version should be increased whenever a newer sage-env is
# required for upgrading.  Note that build/make/deps might also need
# to be changed: the packages which need the new sage-env must depend on
# SAGE_ROOT_REPO (the root repo contains sage-env).
#
# sage-env version history:
# - sage-4.7.1: version 1 (#10469)
# - sage-5.4:   version 2 (#13395)
# - sage-5.10:  version 3 (#14699)
# - sage-6.0:   version 4 (#14715)
#
SAGE_ENV_VERSION=4
if [ "$SAGE_ENV_SOURCED" = "$SAGE_ENV_VERSION" ]; then
    # Already sourced, nothing to do.
    return 0
fi
export SAGE_ENV_SOURCED=$SAGE_ENV_VERSION

if [ -n "$NEW_SAGE_ROOT" ]; then
    export SAGE_ROOT="$NEW_SAGE_ROOT"
fi

# The compilers are set in order of priority by
# 1) environment variables
# 2) compiler installed by sage
# 3) compiler set at configuration time 
if [ -z "$CC" ]; then
    if [ -n "$SAGE_LOCAL" -a -x "$SAGE_LOCAL/bin/gcc" ]; then
        CC=gcc
    elif [ -n "$CONFIGURED_CC" ]; then
        CC="$CONFIGURED_CC"
    fi
    export CC
fi
if [ -z "$CXX" ]; then
    if [  -n "$SAGE_LOCAL" -a -x "$SAGE_LOCAL/bin/g++" ]; then
        CXX=g++
    elif [ -n "$CONFIGURED_CXX" ]; then
        CXX="$CONFIGURED_CXX"
    fi
    export CXX
fi
if [ -z "$FC" ]; then
    if [ -n "$SAGE_LOCAL" -a -x "$SAGE_LOCAL/bin/gfortran" ]; then
        FC=gfortran
    elif [ -n "$CONFIGURED_FC" ]; then
        FC="$CONFIGURED_FC"
    fi
    export FC
fi
if [ "$UNAME" = "Darwin" ]; then
    if [ -z "$OBJC" ]; then
        OBJC="$CONFIGURED_OBJC"
    fi
    if [ -z "$OBJCXX" ]; then
        OBJCXX="$CONFIGURED_OBJCXX"
    fi
    export OBJC OBJCXX
fi

# Set other Fortran-related compiler variables
export F77="$FC"
export F90="$FC"   # Needed for SciPy
export F95="$FC"

# For ARCHFLAGS (#31227) we need to distinguish unset and empty.
# If the environment defines ARCHFLAGS, even when empty, then take that.
# Otherwise, use the configured value; but if that is "unset", do not set
# the variable at all.
if [ "${ARCHFLAGS-unset}" = "unset" ]; then
    if [ "${SAGE_ARCHFLAGS-unset}" != "unset" ]; then
        export ARCHFLAGS="${SAGE_ARCHFLAGS}"
    fi
fi

# Call with: contains_spaces X${VAR}X
# i.e., WITHOUT quotes but some character(s) around the environment variable to test.
# (This function does return false for empty/unset variables.)
contains_spaces()
{
    if [ $# -ne 1 ]; then
        return 0 # true
    else
        return 1 # false
    fi
}


if contains_spaces X${SAGE_ROOT}X ; then
    echo "Error: The path to the Sage directory (\$SAGE_ROOT) MUST NOT contain spaces."
    echo "It is currently \"$SAGE_ROOT\"."
    echo "Please correct this by moving Sage (or renaming one or more directories) first."
    echo "Exiting now..."
    return 1
fi


if [ 1 = 2 ]; then
    echo "The following enviroment variables can be set by the user"
    echo "AR          The archiver (e.g. ar, /usr/ccs/bin/ar or /usr/bin/ar)"
    echo "AS          The assembler (e.g. as, /usr/ccs/bin/as or /usr/bin/as)"
    echo "CC          The C compiler (e.g cc, /opt/SUNWspro/bin/cc or /usr/bin/gcc)"
    echo "CFLAGS      Flag(s) for the C compiler (e.g.  -g -Wall -O2)"
    echo "            (You are advised to a some optimisation flag(s), such as -O2 or -xO2 to CFLAGS)"
    echo "CXX         The C++ compiler (e.g g++, /opt/SUNWspro/bin/CC or /usr/local/bin/g++)"
    echo "CXXFLAGS    Flag(s) for the C++ compiler (e.g. -fast -fsimple=1 -x04)"
    echo "LD          The linker (e.g. ld, /usr/ccs/bin/ld or /usr/bin/ld)"
    echo "LDFLAGS     Linker flag(s) (e.g. -D token)"
    echo "LN          Used to make links (e.g. ln, /usr/xpg4/bin/ln or /usr/bin/ln)"
    echo "MAKE        The make program (e.g. make, /usr/bin/make or /usr/local/bin/gmake)"
    echo "MAKEFLAGS   Flag(s) to make (e.g. -j4)."
    echo "RANLIB      Archiver ranlib (e.g. ranlib, /usr/ccs/bin/ranlib etc)"
    echo "SHAREDFLAGS Flag(s) necessary for building a shared library (e.g. -fPIC or -xcode=pic32)"
    echo "We attempt to set this to sensible values, but check below to"
    echo "ensure they are OK. If you wish to override any then please use:"
    echo "setenv NAME_OF_ENVIROMENT_VARIABLE value_of_enviroment_variable"
    echo "(if you use tcsh, csh or a similar shell) or"
    echo "NAME_OF_ENVIROMENT_VARIABLE value_of_enviroment_variable"
    echo "export NAME_OF_ENVIROMENT_VARIABLE"
    echo "if you use sh, bash or a similar shell"
fi

# Setting Sage-related location environment variables,
# depending on SAGE_ROOT and SAGE_LOCAL which are already defined.
if [ -n "$SAGE_LOCAL" ]; then
    export SAGE_ETC="$SAGE_LOCAL/etc"
    export SAGE_SHARE="$SAGE_LOCAL/share"
    export SAGE_SPKG_INST="$SAGE_LOCAL/var/lib/sage/installed"
fi
if [ -n "$SAGE_SHARE" ]; then
    export SAGE_DOC="$SAGE_SHARE/doc/sage"
fi
if [ -n "$SAGE_ROOT" ]; then
    export SAGE_LOGS="$SAGE_ROOT/logs/pkgs"
    export SAGE_SRC="$SAGE_ROOT/src"
fi
if [ -n "$SAGE_SRC" ]; then
    export SAGE_DOC_SRC="$SAGE_SRC/doc"
fi

if [ -n "$SAGE_PKG_CONFIG_PATH" ]; then
    # set up external pkg-config to look into SAGE_LOCAL/lib/pkgconfig/
    # (Sage's pkgconf spkg takes care of this, if installed)
    export PKG_CONFIG_PATH="$SAGE_PKG_CONFIG_PATH${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH}"
fi

if [ -z "${SAGE_ORIG_PATH_SET}" ]; then
    SAGE_ORIG_PATH=$PATH && export SAGE_ORIG_PATH
    SAGE_ORIG_PATH_SET=True && export SAGE_ORIG_PATH_SET
fi
if [ -n "$SAGE_LOCAL" ]; then
    export PATH="$SAGE_LOCAL/bin:$PATH"
fi
if [ -n "$SAGE_VENV" ]; then
    export PATH="$SAGE_VENV/bin:$PATH"
fi
if [ -n "$SAGE_SRC" ]; then
    export PATH="$SAGE_SRC/bin:$PATH"
fi
if [ -n "$SAGE_ROOT" ]; then
    export PATH="$SAGE_ROOT/build/bin:$PATH"
fi

# We offer a toolchain option, so if $SAGE_LOCAL/toolchain/toolchain-env exists source it.
# Since the user might do something crazy we do not do any checks, but hope for the best.
if [ -n "$SAGE_LOCAL" -a -f "$SAGE_LOCAL"/toolchain/toolchain-env ]; then
  source "$SAGE_LOCAL"/toolchain/toolchain-env
fi

# setting of the variable UNAME (describing the o.s.)
# On Cygwin the result of `uname` depends on the version of Windows
# it is running on, e.g. CYGWIN_NT-5.1 on 32 bits Windows XP or
# CYGWIN_NT-6.1-WOW64 on 64 bits Windows 7.
# Currently, this information is of no use to us so we discard it.
export UNAME=`uname | sed 's/CYGWIN.*/CYGWIN/' `

# Mac OS X-specific setup
if [ "$UNAME" = "Darwin" ]; then
  export MACOSX_VERSION=`uname -r | awk -F. '{print $1}'`
  case "$SAGE_MACOSX_DEPLOYMENT_TARGET" in
  legacy)
    # legacy behavior of the Sage distribution.
    # set MACOSX_DEPLOYMENT_TARGET -- if set incorrectly, this can
    # cause lots of random "Abort trap" issues on OSX. see trac
    # #7095 for an example.
    if [ $MACOSX_VERSION -ge 14 ]; then
        # various packages have still have issues with
        # two digit OS X versions
        MACOSX_DEPLOYMENT_TARGET=10.9
    else
        MACOSX_DEPLOYMENT_TARGET=10.$[$MACOSX_VERSION-4]
    fi
    export MACOSX_DEPLOYMENT_TARGET
    ;;
  "")
    # Do nothing
    ;;
  *)
    # A fixed version set at configure time.
    export MACOSX_DEPLOYMENT_TARGET=$SAGE_MACOSX_DEPLOYMENT_TARGET
    ;;
  esac
    # Work around problems on recent OS X crashing with an error message
    # "... may have been in progress in another thread when fork() was called"
    # when objective-C functions are called after fork(). See Trac #25921.
    # Most likely, these errors are false positives, so we disable them:
    export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES
fi

if [ -n "$SAGE_LOCAL" ]; then
    # Compile-time path for libraries.  This is the equivalent of
    # adding the gcc option -L $SAGE_LOCAL/lib.
    [ -z "$LIBRARY_PATH" ] || LIBRARY_PATH=":${LIBRARY_PATH}"
    export LIBRARY_PATH="$SAGE_LOCAL/lib${LIBRARY_PATH}"
    # Compile-time path for include files.  This is the equivalent of
    # adding the gcc option -I $SAGE_LOCAL/include.
    [ -z "$CPATH" ] || CPATH=":${CPATH}"
    export CPATH="$SAGE_LOCAL/include${CPATH}"
fi

if [ -n "$SAGE_LOCAL" ]; then
    SINGULARPATH="$SAGE_LOCAL/share/singular" && export SINGULARPATH
    SINGULAR_EXECUTABLE="$SAGE_LOCAL/bin/Singular" && export SINGULAR_EXECUTABLE
fi

if [ -z "$SAGE_REPO_ANONYMOUS" ]; then
    SAGE_REPO_ANONYMOUS="https://gitlab.com/sagemath/dev/tracmirror.git"
    export SAGE_REPO_ANONYMOUS
fi
if [ -z "$SAGE_REPO_AUTHENTICATED" ]; then
        SAGE_REPO_AUTHENTICATED="ssh://git@trac.sagemath.org:2222/sage.git"
        export SAGE_REPO_AUTHENTICATED
fi

if [ -n "$SAGE_ROOT" ]; then
    if [ -z "$SAGE_DISTFILES" ]; then
        SAGE_DISTFILES="$SAGE_ROOT/upstream"
        export SAGE_DISTFILES
    fi
fi

# Check that $HOME exists
if [ "$HOME" = "" ]; then
    echo >&2 'Error: environment variable $HOME is not set.'
    return 1
fi
if ! [ -d "$HOME" ]; then
    echo >&2 "Error: HOME directory '$HOME' does not exist."
    return 1
fi

if [ "$DOT_SAGE" = "" ]; then
    # It is *not* an error if this directory does not exist, it will
    # be created in src/bin/sage or src/sage/misc/misc.py.
    # This also works if $HOME/.sage is a symbolic link to a
    # non-existing directory.
    DOT_SAGE=`resolvelinks "$HOME/.sage"`

    # In theory, DOT_SAGE is not required to have a trailing slash.
    # But since there are some issues (#11924, maybe #12221),
    # we add a slash for safety.
    DOT_SAGE="${DOT_SAGE}/"
    export DOT_SAGE
fi

if [ "$SAGE_STARTUP_FILE" = "" ]; then
    SAGE_STARTUP_FILE="$DOT_SAGE/init.sage"
    export SAGE_STARTUP_FILE
fi

if [ "$PYTHON_EGG_CACHE" = "" ]; then
    PYTHON_EGG_CACHE="$DOT_SAGE/.python-eggs"
    export PYTHON_EGG_CACHE
fi

# Set PYTHONUSERBASE to avoid picking up non-Sage versions of
# Matplotlib, numpy, etc. See http://trac.sagemath.org/ticket/19612.
#
# For more history (it used to be PYTHONNOUSERSITE=yes which killed
# the ability to do "sage -pip install PACKAGE --user"), see
# http://trac.sagemath.org/ticket/14243 and
# http://trac.sagemath.org/ticket/18955.

if [ "$PYTHONUSERBASE" = "" ]; then
    PYTHONUSERBASE="$DOT_SAGE/local"
    export PYTHONUSERBASE
fi

if [ -n "$PYTHONHOME" ]; then
    >&2 echo "Warning: PYTHONHOME must not be set when running Sage, clearing env..."
    unset PYTHONHOME
fi

if [ -n "$SAGE_LOCAL" ]; then
    LDFLAGS="-L$SAGE_LOCAL/lib -Wl,-rpath,$SAGE_LOCAL/lib $LDFLAGS"
    if [ "$UNAME" = "Linux" ]; then
        LDFLAGS="-Wl,-rpath-link,$SAGE_LOCAL/lib $LDFLAGS"
    fi
    export LDFLAGS
fi

if [ -z "$IPYTHONDIR" ]; then
    # We hardcode a version number in the directory name. The idea is
    # that we keep using the same version number as long as that is
    # possible. Only when some future IPython version really requires
    # a new structure for the $IPYTHONDIR should this version number be
    # changed to the new IPython version.
    export IPYTHONDIR="$DOT_SAGE/ipython-5.0.0"
fi

if [ -z "$JUPYTER_CONFIG_DIR" ]; then
    # We hardcode a version number in the directory name. The idea is
    # that we keep using the same version number as long as that is
    # possible. Only when some future Jupyter version really requires
    # a new structure for the $JUPYTER_CONFIG_DIR should this version
    # number be changed to the new jupyter_core version.
    export JUPYTER_CONFIG_DIR="$DOT_SAGE/jupyter-4.1"
fi

if [ -z "$MPLCONFIGDIR" ]; then
    # We hardcode a version number in the directory name. The idea is
    # that we keep using the same version number as long as that is
    # possible. Only when some future Matplotlib version really requires
    # a new structure for the $MPLCONFIGDIR should this version
    # number be changed to the new matplotlib version.
    export MPLCONFIGDIR="$DOT_SAGE/matplotlib-1.5.1"
fi

# Make sure that a system-wide R installation does not interfere
unset R_HOME
unset R_PROFILE
# Do not use the global Makevars.site and ~/.R/Makevars when installing R packages
# Provide empty files to appease some R packages' installation scripts.
if [ -n "$SAGE_LOCAL" -a -d "$SAGE_LOCAL/lib/R/share" ] ; then
   R_MAKEVARS_SITE="$SAGE_LOCAL/lib/R/share/Makevars.site" && export R_MAKEVARS_SITE
   if ! [ -f "$R_MAKEVARS_SITE" ] ; then
       if ! [ -e "$R_MAKEVARS_SITE" ] ; then
           echo "## Empty site-wide Makevars file for Sage's R" > "$R_MAKEVARS_SITE"
       else
           >&2 echo "Warning: $R_MAKEVARS_SITE exists and is not a file : trouble ahead..."
       fi
   fi
fi
if [ -d "$DOT_SAGE" ] ; then
    if ! [ -d "$DOT_SAGE/R" ] ; then
        if ! [ -e  "$DOT_SAGE/R" ] ; then
            mkdir -p "$DOT_SAGE/R"
        else
            >&2 echo "Warning: $DOT_SAGE/R exists and is not a directory : trouble ahead..."
        fi
    fi
    R_MAKEVARS_USER="$DOT_SAGE/R/Makevars.user" && export R_MAKEVARS_USER
    if ! [ -f "$R_MAKEVARS_USER" ] ; then
        if ! [ -e "$R_MAKEVARS_USER" ] ; then
            echo "## Empty user-specific Makevars file for Sage's R" > "$R_MAKEVARS_USER"
        else
            >&2 echo "Warning: $R_MAKEVARS_USER exists and is not a file : trouble ahead..."
        fi
    fi
fi

if [ -n "$SAGE_LOCAL" ]; then
    export MAXIMA_PREFIX="$SAGE_LOCAL"
fi
export MAXIMA_USERDIR="$DOT_SAGE/maxima"

if [ -n "$SAGE_LOCAL" ]; then
    PERL5LIB="$SAGE_LOCAL/lib/perl5:$PERL5LIB" && export PERL5LIB
fi

# Allow SAGE_BROWSER to override BROWSER (Trac #22449)
if [ -n "$SAGE_BROWSER" ]; then
    export BROWSER="$SAGE_BROWSER"
fi

############ compilation flags

# Setting Sage-related compilation flags.
# This could be used in code to make special changes only when
# code is being built as part of Sage.
export __sage__=""

# Setup env varariables if ccache is installed
if [ -n "$SAGE_LOCAL" -a -d "$SAGE_LOCAL/libexec/ccache" ]; then
    PATH="$SAGE_LOCAL/libexec/ccache:$PATH"
fi
if [ -n "$SAGE_ROOT" -a -z "$CCACHE_BASEDIR" ]; then
    export CCACHE_BASEDIR="$SAGE_ROOT"
fi

# Set AS to assembler used by $CC ("as" by default)
if [ "$AS" = "" ]; then
    CC_as=`$CC -print-prog-name=as 2>/dev/null`
    if command -v $CC_as >/dev/null 2>/dev/null; then
        AS="$CC_as"
    fi
    if [ "$AS" = "" ]; then
        AS=as
    fi
fi
export AS

# Set LD to linker used by $CC ("ld" by default)
if [ "$LD" = "" ]; then
    CC_ld=`$CC -print-prog-name=ld 2>/dev/null`
    if command -v $CC_ld >/dev/null 2>/dev/null; then
        LD="$CC_ld"
    fi
    if [ "$LD" = "" ]; then
        LD=ld
    fi
fi
export LD


if [ "$AR" = "" ]; then
    AR="ar"  && export AR
fi

if [ "$LDFLAGS" = "" ]; then
    LDFLAGS=""          && export LDFLAGS
fi

if [ -z "$CFLAGS" ]; then
    unset CFLAGS
fi

if [ -z "$CXXFLAGS" ]; then
    unset CXXFLAGS
fi

if [ -n "$CFLAGS" -a -z "$CXXFLAGS" ]; then
    export CXXFLAGS="$CFLAGS"
fi

if [ "$CP" = "" ]; then
    CP="cp"  && export CP
fi

if [ "$MV" = "" ]; then
    MV="mv"  && export MV
fi

if [ "$RANLIB" = "" ]; then
    RANLIB="ranlib"  && export RANLIB
fi

if [ "$LN" = "" ]; then
    LN="ln"  && export LN
fi

if [ "$MKDIR" = "" ]; then
    MKDIR="mkdir"  && export MKDIR
fi

if [ "$CHMOD" = "" ]; then
    CHMOD="chmod"  && export CHMOD
fi

if [ "$TOUCH" = "" ]; then
    TOUCH="touch"  && export TOUCH
fi

if [ "$UNAME" = "CYGWIN" -a -n "$SAGE_LOCAL" ]; then
    # Cygwin needs pathnames in PATH to resolve runtime dependencies
    PATH="$SAGE_LOCAL/lib/R/lib:$SAGE_LOCAL/lib:$PATH" && export PATH
    # And "dlopen" needs them in LD_LIBRARY_PATH, just as on Linuces,
    # except that on Cygwin shared libraries are usually stored in "bin"
    # and not in "lib"
    LD_LIBRARY_PATH="$SAGE_LOCAL/bin:$LD_LIBRARY_PATH" && export LD_LIBRARY_PATH
fi

# See trac 7186 -- this is needed if ecl is moved
if [ -n "$SAGE_LOCAL" ]; then
    ECLDIR="$SAGE_LOCAL/lib/ecl/" && export ECLDIR
fi


# Handle parallel building/testing/...
case "$SAGE_NUM_THREADS,$SAGE_NUM_THREADS_PARALLEL" in
    [1-9][0-9]*,[1-9][0-9]*)
        # Variables are set to positive values already,
        # sage-num-threads.py would just recompute them
        ;;
    *)
        # See Trac Ticket #12016
        # First, figure out the right values for SAGE_NUM_THREADS (default
        # number of threads) and SAGE_NUM_THREADS_PARALLEL (default number of
        # threads when parallel execution is asked explicitly).
        sage_num_threads_array=$(sage-num-threads.py 2>/dev/null || echo 1 2 1)
        sage_num_threads_array="${sage_num_threads_array% *}" # strip third item
        SAGE_NUM_THREADS="${sage_num_threads_array% *}" # keep first item
        SAGE_NUM_THREADS_PARALLEL="${sage_num_threads_array#* }" # keep second item
        export SAGE_NUM_THREADS
        export SAGE_NUM_THREADS_PARALLEL
        ;;
esac

# Multithreading in OpenBLAS does not seem to play well with Sage's attempts to
# spawn new processes, see #26118. Apparently, OpenBLAS sets the thread
# affinity and, e.g., parallel doctest jobs, remain on the same core.
# Disabling that thread-affinity with OPENBLAS_MAIN_FREE=1 leads to hangs in
# some computations.
# So we disable OpenBLAS' threading completely; we might loose some performance
# here but strangely the opposite seems to be the case. Note that callers such
# as LinBox use a single-threaded OpenBLAS anyway.
export OPENBLAS_NUM_THREADS=1

if [ "$MAKE" = "" ]; then
    MAKE="make"
fi

# If MAKEFLAGS exists, assume it got set by make.
# Therefore, remove all flags from $MAKE
if [ "${MAKEFLAGS-__unset__}" != "__unset__" ]; then
    MAKE=`echo "$MAKE" | sed 's/ .*//'`
fi
export MAKE

export PIP_FORMAT="columns"

# When building documentation, use MathJax by default. To turn it off,
# set SAGE_DOC_MATHJAX to be "no" or "False".
if [ -z "$SAGE_DOC_MATHJAX" ]; then
    # For backwards compatibility, we use the value of SAGE_DOC_JSMATH
    # if it is set.
    if [ -n "$SAGE_DOC_JSMATH" ]; then
        SAGE_DOC_MATHJAX="$SAGE_DOC_JSMATH"
    else
        SAGE_DOC_MATHJAX="True"
    fi
    export SAGE_DOC_MATHJAX
fi

# Set the cysignals crash logs directory
if [ -z "$CYSIGNALS_CRASH_LOGS" ]; then
    export CYSIGNALS_CRASH_LOGS="$DOT_SAGE/crash_logs"
    export CYSIGNALS_CRASH_DAYS=7  # keep logs for 7 days
fi

# You can set environment variables in $SAGE_RC_FILE
# (by default, this is the file $DOT_SAGE/sagerc).  For example,
# setting PS1 there will set your prompt when you run "sage --sh".
if [ -z "$SAGE_RC_FILE" ]; then
    SAGE_RC_FILE="$DOT_SAGE/sagerc"
fi

if [ -r "$SAGE_RC_FILE" ]; then
    source "$SAGE_RC_FILE"
    if [ $? -ne 0 ]; then
        echo >&2 "Error sourcing $SAGE_RC_FILE"
        exit 1
    fi
fi

if [ -n "$SAGE_LOCAL" ]; then
    # If we move the Sage tree then ncurses cannot find terminfo, hence, we
    # tell it where to find it. See Trac Ticket #15091
    export TERMINFO="$SAGE_LOCAL/share/terminfo"

    # If nodejs is installed, activate the nodeenv containing it.

    nodeenv_activate="$SAGE_LOCAL/share/nodejs/activate"

    if [ -f "$nodeenv_activate" ]; then
        # symlinked into nodeenv for specific version of nodejs installed
        # The activate script needs to be sourced using its actual path.
        nodeenv_activate=`resolvelinks "$nodeenv_activate"`

        # Don't let nodeenv wipe out the sage-sh/sage-buildsh prompt.
        NODE_VIRTUAL_ENV_DISABLE_PROMPT=1 . "$nodeenv_activate"

        if [ $? -ne 0 ]; then
            echo >&2 "Warning: failed to activate the nodeenv containing nodejs"
        fi
    elif [ -L "$nodeenv_activate" ]; then
        echo >&2 "Warning: the nodeenv activation symlink for nodejs is broken"
    fi

fi
