#!/usr/bin/env bash

###############################################################################
# Check if pipestatus already exists, otherwise
# create it to allow upgrade from Sage <4.5.  This is a temporary fix.
# See trac 9528: http://trac.sagemath.org/sage_trac/ticket/9528
# Go about 56 lines down from here for the actual "install" script.
###############################################################################
if [ ! -f pipestatus ]; then
  echo "Creating pipestatus."
  cat >pipestatus <<'EOF'
#!/usr/bin/env bash
#
# spkg/pipestatus: run two commands in a pipeline CMD1 | CMD2 and exit
# with the status of the last command to exit with a non-zero status, or
# zero if no command exited with a non-zero status.
#
# This is useful, for example, in a Makefile, where we tee the output
# of a build command to a log file.  Using pipestatus, make will stop if
# tee succeeds but a preceding command in the pipeline fails.
#
# Syntactically, the command executed is "CMD1 | CMD2" where CMD1 and
# CMD2 are *not* treated as atoms.  If CMD1 is "A && B" and CMD2 is "C",
# then pipestatus CMD1 CMD2 will act as A && (B | C).  This also implies
# that CMD1 and CMD2 *MUST NOT* contain pipes, or this script will break.
#
# IMPORTANT: if you edit this file, be sure to also edit spkg/install
#            where this file is created for upgrading.
#
#
# AUTHORS:
#
# - Jeroen Demeyer (2010-12-19): complete rewrite (#10339)
#
#*****************************************************************************
#       Copyright (C) 2010 Jeroen Demeyer <jdemeyer@cage.ugent.be>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************


if [ $# -ne 2 ] || [ -z "$1" -o -z "$2" ]; then
    echo >&2 "Usage: $0 CMD1 CMD2"
    echo >&2 "Run two commands in a pipeline 'CMD1 | CMD2' and exit with the status"
    echo >&2 "of the last command to exit with a non-zero status, or zero if no"
    echo >&2 "command exited with a non-zero status."
    exit 2
fi

eval "$1 | $2; pipestatus=(\${PIPESTATUS[*]})"

if [ ${pipestatus[1]} -ne 0 ]; then
    exit ${pipestatus[1]}
else
    exit ${pipestatus[0]}
fi
EOF
  chmod +x pipestatus
fi

###############################################################################


CUR=`pwd`
cd ..
SAGE_ROOT=`pwd`
# Storing the start time of the build process. The time is stored in
# seconds since 1970-01-01 in a hidden file called
# "SAGE_ROOT/.BUILDSTART". See ticket #6744.
echo `date -u "+%s"` > .BUILDSTART
cd "$CUR"
SAGE_LOCAL="$SAGE_ROOT/local"
SAGE_LOGS="$SAGE_ROOT/spkg/logs"
PATH="$SAGE_ROOT:$SAGE_LOCAL/bin:$PATH"
PYTHONPATH="$SAGE_LOCAL"
PKGDIR=standard
export PATH SAGE_ROOT SAGE_LOCAL SAGE_LOGS PYTHONPATH

if [ ! -f "$SAGE_LOCAL/bin/sage-spkg" ]; then
    if [ ! -d "$SAGE_LOCAL" ]; then
        mkdir "$SAGE_LOCAL"
    fi
    if [ ! -d "$SAGE_LOCAL/bin" ]; then
        mkdir "$SAGE_LOCAL/bin"
    fi
    cp base/sage-* base/testcc.sh base/testcxx.sh "$SAGE_LOCAL/bin/"
fi

if [ ! -d "$SAGE_LOGS" ]; then
    mkdir -p "$SAGE_LOGS"
fi

###############################################################################
# Make upgrading work: If this script is called from sage-upgrade,
# either sage-upgrade has set SAGE_UPGRADING to "yes",
# or we have an old version of sage-upgrade that doesn't contain
# the string "SAGE_UPGRADING".
# If SAGE_UPGRADING is not set to "yes", or sage-upgrade does not (yet)
# exist, do the usual build (without setting SAGE_SPKG_OPTS).
###############################################################################
if [ "$SAGE_UPGRADING" = yes ] \
    || ([ -f "$SAGE_LOCAL/bin/sage-upgrade" ] && \
        ! grep SAGE_UPGRADING "$SAGE_LOCAL/bin/sage-upgrade" >/dev/null);
then
    # We're doing an upgrade.
    # Let the Makefile (spkg/standard/deps) call sage-spkg with "-f"
    # to force rebuilding dependent packages, too:
    export SAGE_SPKG_OPTS="-f"
fi

###############################################################################
# Setup environment variables pointing to the newest versions
# of the base packages:
###############################################################################
newest="$PKGDIR/newest_version -base "

SAGE_BZIP2=`$newest bzip2`
export SAGE_BZIP2

DIR=`$newest dir`
export DIR

PREREQ=`$newest prereq`
export PREREQ

###############################################################################
# Setup environment variables pointing to the newest versions
# of the standard packages:
###############################################################################
newest="$PKGDIR/newest_version"

ATLAS=`$newest atlas`
export ATLAS

BLAS=`$newest blas`
export BLAS

BOEHM_GC=`$newest boehm_gc`
export BOEHM_GC

BOOST_CROPPED=`$newest boost-cropped`
export BOOST_CROPPED

CEPHES=`$newest cephes`
export CEPHES

CLIQUER=`$newest cliquer`
export CLIQUER

CDDLIB=`$newest cddlib`
export CDDLIB

PPL=`$newest ppl`
export PPL

ECL=`$newest ecl`
export ECL

CONWAY=`$newest conway_polynomials`
if [ $? -ne 0 ]; then
    echo "Error determining package name using spkg/standard/newest_version script."
    exit 1
fi
export CONWAY

ECLIB=`$newest eclib`
export ECLIB

ELLIPTIC_CURVES=`$newest elliptic_curves`
export ELLIPTIC_CURVES

CVXOPT=`$newest cvxopt`
export CVXOPT

DOCUTILS=`$newest docutils`
export DOCUTILS

ECM=`$newest ecm`
export ECM

EXTCODE=`$newest extcode`
export EXTCODE

F2C=`$newest f2c`
export F2C

GLPK=`$newest glpk`
export GLPK

ICONV=`$newest iconv`
export ICONV

#############
# This is all for GNUtls crypto
LIBGCRYPT=`$newest libgcrypt`
export LIBGCRYPT

OPENCDK=`$newest opencdk`
export OPENCDK

GNUTLS=`$newest gnutls`
export GNUTLS

LIBGPG_ERROR=`$newest libgpg_error`
export LIBGPG_ERROR

PYGMENTS=`$newest pygments`
export PYGMENTS

PYTHON_GNUTLS=`$newest python_gnutls`
export PYTHON_GNUTLS
############# end gnutls crypto

PIL=`$newest pil`
export PIL

PATCH=`$newest patch`
export PATCH

LIBM4RI=`$newest libm4ri`
export LIBM4RI

LIBM4RIE=`$newest libm4rie`
export LIBM4RIE

FORTRAN=`$newest fortran`
export FORTRAN

FPLLL=`$newest libfplll`
export FPLLL

FREETYPE=`$newest freetype`
export FREETYPE

GAP=`$newest gap`
export GAP

G2RED=`$newest genus2reduction`
export G2RED

GD=`$newest gd`
export GD

GDMODULE=`$newest gdmodule`
export GDMODULE

GFAN=`$newest gfan`
export GFAN

GIVARO=`$newest givaro`
export GIVARO

MPIR=`$newest mpir`
export MPIR

GRAPHS=`$newest graphs`
export GRAPHS

GSL=`$newest gsl`
export GSL

IPYTHON=`$newest ipython`
export IPYTHON

LAPACK=`$newest lapack`
export LAPACK

LCALC=`$newest lcalc`
export LCALC

LIBPNG=`$newest libpng`
export LIBPNG

LINBOX=`$newest linbox`
export LINBOX

IML=`$newest iml`
export IML

JINJA2=`$newest jinja2`
export JINJA2

MATPLOTLIB=`$newest matplotlib`
export MATPLOTLIB

MAXIMA=`$newest maxima`
export MAXIMA

MERCURIAL=`$newest mercurial`
export MERCURIAL

MPFI=`$newest mpfi`
export MPFI

MOIN=`$newest moin`
export MOIN

MPFR=`$newest mpfr`
export MPFR

MPMATH=`$newest mpmath`
export MPMATH

NETWORKX=`$newest networkx`
export NETWORKX

NUMPY=`$newest numpy`
export NUMPY

NTL=`$newest ntl`
export NTL

#OPENSSL=`$newest openssl`
#export OPENSSL

#PYOPENSSL=`$newest pyopenssl`
#export PYOPENSSL

PALP=`$newest palp`
export PALP

PARI=`$newest pari`
export PARI

PEXPECT=`$newest pexpect`
export PEXPECT

POLYBORI=`$newest polybori`
export POLYBORI

PYNAC=`$newest pynac`
export PYNAC

CYTHON=`$newest cython`
export CYTHON

RATPOINTS=`$newest ratpoints`
export RATPOINTS

SAGENB=`$newest sagenb`
export SAGENB

SAGETEX=`$newest sagetex`
export SAGETEX

SPHINX=`$newest sphinx`
export SPHINX

SQLALCHEMY=`$newest sqlalchemy`
export SQLALCHEMY

SQLITE=`$newest sqlite`
export SQLITE

FLINTQS=`$newest flintqs`
export FLINTQS

FLINT=`$newest flint`
export FLINT

POLYTOPES_DB=`$newest polytopes_db`
export POLYTOPES_DB

PYCRYPTO=`$newest pycrypto`
export PYCRYPTO

PYTHON=`$newest python`
export PYTHON

R=`$newest r`
export R

# Needed when #9906 gets merged:
# RPY=`$newest rpy2`
# export RPY

READLINE=`$newest readline`
export READLINE

RUBIKS=`$newest rubiks`
export RUBIKS

SAGE=`$newest sage`
export SAGE

SAGE_ROOT_REPO=`$newest sage_root`
export SAGE_ROOT_REPO

SAGE_SCRIPTS=`$newest sage_scripts`
export SAGE_SCRIPTS

SCIPY=`$newest scipy`
export SCIPY

TACHYON=`$newest tachyon`
export TACHYON

TWISTED=`$newest twisted`
export TWISTED

SCONS=`$newest scons`
export SCONS

SETUPTOOLS=`$newest setuptools`
export SETUPTOOLS

SINGULAR=`$newest singular`
export SINGULAR

SYMPOW=`$newest sympow`
export SYMPOW

SYMPY=`$newest sympy`
export SYMPY

SYMMETRICA=`$newest symmetrica`
export SYMMETRICA

TERMCAP=`$newest termcap`
export TERMCAP

ZLIB=`$newest zlib`
export ZLIB

ZODB=`$newest zodb3`
export ZODB

ZNPOLY=`$newest zn_poly`
export ZNPOLY

# If the user (or the Makefile) has set SAGE_PARALLEL_SPKG_BUILD=no,
# then turn off parallel building by writing .NOTPARALLEL to
# spkg/standard/parallel_make.cfg.  Otherwise clear that file.
if [[ ${SAGE_PARALLEL_SPKG_BUILD:-yes} = no ]]; then
    # Disable just building multiple packages at the same time; individual
    # spkgs still get built in parallel if they support it and '--jobs'
    # in $MAKE is greater than one (and at all specified):
    echo ".NOTPARALLEL:" > "$SAGE_ROOT"/spkg/parallel_make.cfg
else
    # Create an (almost) empty file, s.t. including it from spkg/standard/deps
    # doesn't raise an error, thereby also invalidating any previous setting:
    echo > "$SAGE_ROOT"/spkg/parallel_make.cfg
fi

# Skip the rest if nothing to do (i.e., to [re]build).
# * If "make" doesn't understand the -q option (although we require
#   GNU make, which supports it), it should exit with a non-zero status
#   which is not a problem.
# * Only do this check if $SAGE_LOCAL/bin/sage-spkg understands MAKEFLAGS.
#   If $SAGE_LOCAL/bin/sage-spkg does not exist, we assume that a
#   sage-5.x scripts and root repository has been installed, which also
#   understands MAKEFLAGS.  See Trac #12248 and also #12016.
if [ ! -f "$SAGE_LOCAL/bin/sage-spkg" ] || \
grep >/dev/null MAKEFLAGS "$SAGE_LOCAL/bin/sage-spkg"; then
    if ${MAKE:-make} -q -f standard/deps $1; then
        echo "Nothing to (re)build / all up-to-date."
        exit 0
    fi
fi

# Dump environment for debugging purposes:
echo "*** ALL ENVIRONMENT VARIABLES BEFORE BUILD: ***"
env | sort
echo "***********************************************"

###############################################################################
# NOW do the actual build:
###############################################################################
time ${MAKE:-make} -f standard/deps $1

# Added by Burcin Erocal, see trac #6295:
if [ $? -ne 0 ]; then
    echo >&2 "Error building Sage."
    exit 1
fi

cd "$SAGE_ROOT"

# Rename makefile to Makefile (see #10156):
if [ -f makefile ]; then
    mv makefile Makefile
    if [ $? -ne 0 ]; then
        echo "Error renaming 'makefile' to 'Makefile'."
        exit 1
    fi
fi

# Build succeeded.
echo "Sage build/upgrade complete!"

if [ "$1" = "all" ]; then
    echo
    echo "To install small scripts to directly run Sage's versions of GAP,"
    echo "the PARI/GP interpreter, Maxima, or Singular etc. (by typing e.g."
    echo "just 'gap' or 'gp') into a standard 'bin' directory, start Sage"
    echo "by typing 'sage' (or './sage') and enter something like"
    echo
    echo "    install_scripts('/usr/local/bin')"
    echo
    echo "at the Sage command prompt ('sage:')."
    echo
    echo "If you issued 'make', 'make all', or a similar command, then the"
    echo "HTML version of the documentation will be built right now."
    echo "Otherwise, if you want to (re)build the HTML documentation,"
    echo "run 'make doc'.  To build the PDF version, run 'make doc-pdf'."
    echo
fi
