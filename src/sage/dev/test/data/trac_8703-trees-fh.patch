#8703: Enumerated sets and data structure for ordered and binary trees
- The Class Abstract[Labelled]Tree allows for inheritance from different
  Cython classes.
- Added shape on labelled trees.
- Add a new function as_digraph() that maps a tree to the associated directed
  graph, with edges oriented away from from the root
- Added canopee to binary trees.
- Decreasing and increasing Binary tree of a permutations.
- Added Binary tree insertion.
- Added Binary search tree of a permutation
- removed sage.misc.sagex_ds.BinaryTree from the interface.

diff --git a/doc/en/reference/combinat/index.rst b/doc/en/reference/combinat/index.rst
--- a/doc/en/reference/combinat/index.rst
+++ b/doc/en/reference/combinat/index.rst
@@ -45,6 +45,9 @@ Combinatorics
    sage/combinat/sidon_sets
    sage/combinat/set_partition_ordered
    sage/combinat/set_partition
+   sage/combinat/abstract_tree
+   sage/combinat/ordered_tree
+   sage/combinat/binary_tree
    sage/combinat/skew_partition
    sage/combinat/subset
    sage/combinat/subsets_pairwise
diff --git a/sage/combinat/abstract_tree.py b/sage/combinat/abstract_tree.py
new file mode 100644
--- /dev/null
+++ b/sage/combinat/abstract_tree.py
@@ -0,0 +1,979 @@
+"""
+Abstract Recursive Trees
+
+The purpose of this class is to help implement trees with a specific structure
+on the children of each node. For instance, one could want to define a tree in
+which each node sees its children as linearly (see the :mod:`Ordered Trees
+<sage.combinat.ordered_tree>` module) or cyclically ordered.
+
+**Tree structures**
+
+Conceptually, one can define a tree structure from any object that can contain
+others. Indeed, a list can contain lists which contain lists which contain
+lists, and thus define a tree ... The same can be done with sets, or any kind
+of iterable objects.
+
+While any iterable is sufficient to encode trees, it can prove useful to have
+other methods available like isomorphism tests (see next section), conversions
+to DiGraphs objects (see :meth:`~.AbstractLabelledTree.as_digraph`) or
+computation of the number of automorphisms constrained by the structure on
+children. Providing such methods is the whole purpose of the
+:class:`AbstractTree` class.
+
+As a result, the :class:`AbstractTree` class is not meant to be
+instantiated, but extended. It is expected that classes extending this one may
+also inherit from classes representing iterables, for instance
+:class:`ClonableArray` or :class:`~sage.structure.list_clone.ClonableList`
+
+**Constrained Trees**
+
+The tree built from a specific container will reflect the properties of the
+container. Indeed, if ``A`` is an iterable class whose elements are linearly
+ordered, a class ``B`` extending both of :class:`AbstractTree` and ``A`` will
+be such that the children of a node will be linearly ordered. If ``A`` behaves
+like a set (i.e. if there is no order on the elements it contains), then two
+trees will be considered as equal if one can be obtained from the other
+through permutations between the children of a same node (see next section).
+
+**Paths and ID**
+
+It is expected that each element of a set of children should be identified by
+its index in the container. This way, any node of the tree can be identified
+by a word describing a path from the root node.
+
+**Canonical labellings**
+
+Equality between instances of classes extending both of :class:`AbstractTree`
+and ``A`` is entirely defined by the equality defined on the elements of
+``A``. A canonical labelling of such a tree however, should be such that two
+trees ``a`` and ``b`` satisfying ``a == b`` should have the same canonical
+labellings. On the other hand, the canonical labellings of trees ``a`` and
+``b`` satisfying ``a != b`` are expected to be different.
+
+For this reason, the values returned by the :meth:`canonical_labelling
+<AbstractTree.canonical_labelling>` method heavily
+depend on the data structure used for a node's children and **should be**
+**overridden** by most of the classes extending :class:`AbstractTree` if it is
+incoherent with the data structure.
+
+**Authors**
+
+- Florent Hivert (2010-2011): initial revision
+- Frederic Chapoton (2011): contributed some methods
+"""
+
+from sage.structure.list_clone import ClonableArray
+from sage.rings.integer import Integer
+from sage.misc.misc_c import prod
+
+# Unfortunately Cython forbids multiple inheritance. Therefore, we do not
+# inherits from SageObject to be able to inherits from Element or a subclass
+# of it later.
+class AbstractTree(object):
+    """
+    Abstract Tree
+
+    There is no data structure defined here, as this class is meant to be
+    extended, not instantiated.
+
+    .. rubric:: How should this class be extended ?
+
+    A class extending :class:`AbstractTree
+    <sage.combinat.abstract_tree.AbstractTree>` should respect several
+    assumptions:
+
+    * For a tree ``T``, the call ``iter(T)`` should return an iterator on the
+      children of the root ``T``.
+
+    * The :meth:`canonical_labelling
+      <AbstractTree.canonical_labelling>` method
+      should return the same value for trees that are considered equal (see the
+      "canonical labellings" section in the documentation of the
+      :class:`AbstractTree <sage.combinat.abstract_tree.AbstractTree>` module).
+
+    * For a tree ``T`` the call ``T.parent().labelled_trees()`` should return
+      a parent for labelled trees of the same kind: for example,
+
+      - if ``T`` is a binary tree, ``T.parent()`` is ``BinaryTrees()`` and
+        ``T.parent().labelled_trees()`` is ``LabelledBinaryTrees()``
+
+      - if ``T`` is an ordered tree, ``T.parent()`` is ``OrderedTrees()`` and
+        ``T.parent().labelled_trees()`` is ``LabelledOrderedTrees()``
+
+    TESTS::
+
+        sage: TestSuite(OrderedTree()).run()
+        sage: TestSuite(BinaryTree()).run()
+    """
+
+    def subtrees(self):
+        """
+        Returns a generator for all subtrees of ``self``
+
+        The number of subtrees of a tree is its number of elements.
+
+        EXAMPLES::
+
+            sage: list(OrderedTree([]).subtrees())
+            [[]]
+            sage: list(OrderedTree([[],[[]]]).subtrees())
+            [[[], [[]]], [], [[]], []]
+
+            sage: list(BinaryTree([[],[[],[]]]).subtrees())
+            [[[., .], [[., .], [., .]]], [., .], [[., .], [., .]], [., .], [., .]]
+
+        TESTS::
+
+            sage: t = OrderedTree([[], [[], [[], []], [[], []]], [[], []]])
+            sage: t.node_number() == len(list(t.subtrees()))
+            True
+            sage: list(BinaryTree().subtrees())
+            []
+            sage: bt = BinaryTree([[],[[],[]]])
+            sage: bt.node_number() == len(list(bt.subtrees()))
+            True
+        """
+        if not self.is_empty():
+            yield self
+            for i in self:
+                for t in i.subtrees():
+                    yield t
+
+    def paths(self):
+        """
+        Returns a generator for all paths to nodes of ``self``
+
+        OUTPUT:
+
+        This method returns a list of sequences of integers. Each of these
+        sequences represents a path from the root node to another one : `(1, 3,
+        2, 5, 3)` represents the node obtained by chosing the 1st children of
+        the root node (in the ordering returned by ``iter``), then the 3rd of
+        its children, then the 2nd of this element, etc.
+
+        The root element is represented by the empty tuple ``()``.
+
+        EXAMPLES::
+
+            sage: list(OrderedTree([]).paths())
+            [()]
+            sage: list(OrderedTree([[],[[]]]).paths())
+            [(), (0,), (1,), (1, 0)]
+
+            sage: list(BinaryTree([[],[[],[]]]).paths())
+            [(), (0,), (1,), (1, 0), (1, 1)]
+
+        TESTS::
+
+            sage: t = OrderedTree([[], [[], [[], []], [[], []]], [[], []]])
+            sage: t.node_number() == len(list(t.paths()))
+            True
+            sage: list(BinaryTree().paths())
+            []
+            sage: bt = BinaryTree([[],[[],[]]])
+            sage: bt.node_number() == len(list(bt.paths()))
+            True
+        """
+        if not self.is_empty():
+            yield ()
+            for i, t in enumerate(self):
+                for p in t.paths():
+                    yield (i,)+p
+
+    def node_number(self):
+        """
+        The number of nodes of ``self``
+
+        EXAMPLES::
+
+            sage: OrderedTree().node_number()
+            1
+            sage: OrderedTree([]).node_number()
+            1
+            sage: OrderedTree([[],[]]).node_number()
+            3
+            sage: OrderedTree([[],[[]]]).node_number()
+            4
+            sage: OrderedTree([[], [[], [[], []], [[], []]], [[], []]]).node_number()
+            13
+
+        EXAMPLE::
+
+            sage: BinaryTree(None).node_number()
+            0
+            sage: BinaryTree([]).node_number()
+            1
+            sage: BinaryTree([[], None]).node_number()
+            2
+            sage: BinaryTree([[None, [[], []]], None]).node_number()
+            5
+        """
+        if self.is_empty():
+            return 0
+        else:
+            return sum((i.node_number() for i in self), Integer(1))
+
+    def depth(self):
+        """
+        The depth of ``self``
+
+        EXAMPLES::
+
+            sage: OrderedTree().depth()
+            1
+            sage: OrderedTree([]).depth()
+            1
+            sage: OrderedTree([[],[]]).depth()
+            2
+            sage: OrderedTree([[],[[]]]).depth()
+            3
+            sage: OrderedTree([[], [[], [[], []], [[], []]], [[], []]]).depth()
+            4
+
+            sage: BinaryTree().depth()
+            0
+            sage: BinaryTree([[],[[],[]]]).depth()
+            3
+        """
+        if self:
+            return Integer(1 + max(i.depth() for i in self))
+        else:
+            return Integer(0 if self.is_empty() else 1)
+
+    def canonical_labelling(self,shift=1):
+        """
+        Returns a labelled version of ``self``
+
+        The actual canonical labelling is currently unspecified. However, it
+        is guaranteed to have labels in `1...n` where `n` is the number of
+        nodes of the tree. Moreover, two (unlabelled) trees compare as equal if
+        and only if they canonical labelled trees compare as equal.
+
+        EXAMPLES::
+
+            sage: t = OrderedTree([[], [[], [[], []], [[], []]], [[], []]])
+            sage: t.canonical_labelling()
+            1[2[], 3[4[], 5[6[], 7[]], 8[9[], 10[]]], 11[12[], 13[]]]
+
+            sage: BinaryTree([]).canonical_labelling()
+            1[., .]
+            sage: BinaryTree([[],[[],[]]]).canonical_labelling()
+            2[1[., .], 4[3[., .], 5[., .]]]
+
+        TESTS::
+
+            sage: BinaryTree().canonical_labelling()
+            .
+        """
+        LTR = self.parent().labelled_trees()
+        liste=[]
+        deca=1
+        for subtree in self:
+            liste=liste+[subtree.canonical_labelling(shift+deca)]
+            deca=deca+subtree.node_number()
+        return LTR._element_constructor_(liste,label=shift)
+
+    def tree_factorial(self):
+        """
+        Returns the tree-factorial of ``self``
+
+        Definition:
+
+        The tree-factorial `T!` of a tree `T` is the product `\prod_{v\in
+        T}\#\mbox{children}(v)`.
+
+        EXAMPLES::
+
+            sage: LT=LabelledOrderedTrees()
+            sage: t=LT([LT([],label=6),LT([],label=1)],label=9)
+            sage: t.tree_factorial()
+            3
+
+            sage: BinaryTree([[],[[],[]]]).tree_factorial()
+            15
+
+        TESTS::
+
+            sage: BinaryTree().tree_factorial()
+            1
+        """
+        nb = self.node_number()
+        if nb <= 1:
+            return 1
+        else:
+            return nb*prod(s.tree_factorial() for s in self)
+
+    latex_unit_length   = "4mm"
+    latex_node_diameter = "0.5"
+    latex_root_diameter = "0.7"
+
+    def _latex_(self):
+        """
+        Returns a LaTeX version of ``self``
+
+        EXAMPLES::
+
+            sage: print(OrderedTree([[],[]])._latex_())
+            \vcenter{\hbox{{\setlength\unitlength{4mm}
+            \begin{picture}(4,3)
+            \put(1,1){\circle*{0.5}}
+            \put(2,2){\circle*{0.5}}
+            \put(3,1){\circle*{0.5}}
+            \put(2,2){\line(-1,-1){1}}
+            \put(2,2){\line(1,-1){1}}
+            \put(2,2){\circle*{0.7}}
+            \end{picture}}}}
+
+        TESTS::
+
+            sage: OrderedTree([])._latex_()
+            '\\vcenter{\\hbox{{\\setlength\\unitlength{4mm}\n\\begin{picture}(2,2)\n\\put(1,1){\\circle*{0.5}}\n\\put(1,1){\\circle*{0.7}}\n\\end{picture}}}}'
+            sage: OrderedTree([[]])._latex_()
+            '\\vcenter{\\hbox{{\\setlength\\unitlength{4mm}\n\\begin{picture}(2,3)\n\\put(1,1){\\circle*{0.5}}\n\\put(1,2){\\circle*{0.5}}\n\\put(1,2){\\line(0,-1){1}}\n\\put(1,2){\\circle*{0.7}}\n\\end{picture}}}}'
+            sage: OrderedTree([[], [[], [[], []], [[], []]], [[], []]])._latex_()
+            '\\vcenter{\\hbox{{\\setlength\\unitlength{4mm}\n\\begin{picture}(12,5)\n\\put(1,3){\\circle*{0.5}}\n\\put(2,2){\\circle*{0.5}}\n\\put(3,1){\\circle*{0.5}}\n\\put(4,2){\\circle*{0.5}}\n\\put(5,1){\\circle*{0.5}}\n\\put(4,2){\\line(-1,-1){1}}\n\\put(4,2){\\line(1,-1){1}}\n\\put(4,3){\\circle*{0.5}}\n\\put(6,1){\\circle*{0.5}}\n\\put(7,2){\\circle*{0.5}}\n\\put(8,1){\\circle*{0.5}}\n\\put(7,2){\\line(-1,-1){1}}\n\\put(7,2){\\line(1,-1){1}}\n\\put(4,3){\\line(-2,-1){2}}\n\\put(4,3){\\line(0,-1){1}}\n\\put(4,3){\\line(3,-1){3}}\n\\put(4,4){\\circle*{0.5}}\n\\put(9,2){\\circle*{0.5}}\n\\put(10,3){\\circle*{0.5}}\n\\put(11,2){\\circle*{0.5}}\n\\put(10,3){\\line(-1,-1){1}}\n\\put(10,3){\\line(1,-1){1}}\n\\put(4,4){\\line(-3,-1){3}}\n\\put(4,4){\\line(0,-1){1}}\n\\put(4,4){\\line(6,-1){6}}\n\\put(4,4){\\circle*{0.7}}\n\\end{picture}}}}'
+        """
+        from sage.misc.latex import latex
+        drawing = [""] # allows modification of  in rec...
+        x = [1]        # allows modification of x[0] in rec...
+        max_label_width = [0] # allows modification of x[0] in rec...
+        maxy = self.depth()
+
+        def rec(t, y):
+            """
+            Draw the subtree t on the drawing, below y (included) and to
+            the right of x[0] (included). Update x[0]. Returns the horizontal
+            position of the root
+            """
+            if t.node_number() == 0 : return -1
+            n = len(t)
+            posChild = [rec(t[i], y+1) for i in range(n // 2)]
+            i = n // 2
+            if n % 2 == 1:
+                xc = rec(t[i], y+1)
+                posChild.append(xc)
+                i += 1
+            else:
+                xc = x[0]
+                x[0] +=1
+            drawing[0] = drawing[0] + "\\put(%s,%s){\\circle*{%s}}\n"%(
+                xc, maxy-y, self.latex_node_diameter)
+            try:
+                lbl = t.label()
+            except AttributeError:
+                pass
+            else:
+                max_label_width[0] = 1 # TODO find a better heuristic
+                drawing[0] = drawing[0] + "\\put(%s,%s){$\scriptstyle %s$}"%(
+                    xc+0.3, maxy-y-0.3, latex(lbl))
+            posChild += [rec(t[j], y+1) for j in range(i, n)]
+            for i in range(n):
+                if posChild[i] != -1:
+                    drawing[0] = (drawing[0] +
+                        "\\put(%s,%s){\\line(%s,-1){%s}}\n"%(
+                            xc, maxy-y, posChild[i]-xc,
+                            max(abs(posChild[i]-xc), 1)))
+            return xc
+
+        res = rec(self, 0)
+        drawing[0] = drawing[0] + "\\put(%s,%s){\\circle*{%s}}\n"%(
+            res, maxy, self.latex_root_diameter)
+        return "\\vcenter{\hbox{{\setlength\unitlength{%s}\n\\begin{picture}(%s,%s)\n%s\\end{picture}}}}"%(
+            self.latex_unit_length,
+            x[0] + max_label_width[0],
+            maxy + 1,
+            drawing[0])
+
+class AbstractClonableTree(AbstractTree):
+    """
+    Abstract Clonable Tree
+
+    An abstract class for trees with clone protocol (see
+    :mod:`~sage.structure.list_clone`). It is expected that classes extending
+    this one may also inherit from classes like :class:`ClonableArray` or
+    :class:`~sage.structure.list_clone.ClonableList` depending wether one
+    wants to build trees where adding a child is allowed.
+
+    .. note:: Due to the limitation of Cython inheritance, one cannot inherit
+       here from :class:`~sage.structure.list_clone.ClonableElement`, because
+       it would prevent us to inherit later from
+       :class:`~sage.structure.list_clone.ClonableArray` or
+       :class:`~sage.structure.list_clone.ClonableList`.
+
+    .. rubric:: How should this class be extended ?
+
+    A class extending :class:`AbstractTree
+    <sage.combinat.abstract_tree.AbstractTree>` should the following
+    assumptions:
+
+    * An instantiable class extending :class:`AbstractTree
+      <sage.combinat.abstract_tree.AbstractTree>` should also extend the
+      :class:`ClonableElement <sage.structure.list_clone.ClonableElement>`
+      class or one of its subclass generally at least :class:`ClonableArray
+      <sage.structure.list_clone.ClonableArray>`.
+
+
+    * To respect the Clone protocol, the :meth:`AbstractClonableTree.check`
+      method should be overridden by the new class.
+    """
+    def check(self):
+        """
+        Check that ``self`` is a correct tree
+
+        This method does nothing. It is implemented here because many
+        extensions of :class:`AbstractTree
+        <sage.combinat.abstract_tree.AbstractTree>` also extend
+        :class:`sage.structure.list_clone.ClonableElement`, which requires it.
+
+        It should be overriden in subclass is order to chech that the
+        invariant of the kind of tree holds (eg: two children for binary
+        trees).
+
+        EXAMPLES::
+
+            sage: OrderedTree([[],[[]]]).check()
+            sage: BinaryTree([[],[[],[]]]).check()
+        """
+        pass
+
+    def __setitem__(self, idx, value):
+        """
+        Substitute a subtree
+
+        .. NOTE::
+
+            The tree ``self`` must be in a mutable state. See
+            :mod:`sage.structure.list_clone` for more details about
+            mutability.  The default implementation here assume that the
+            container of the node implement a method `_setitem` with signature
+            `self._setitem(idx, value)`. It is usually provided by inheriting
+            from :class:`~sage.structure.list_clone.ClonableArray`.
+
+        INPUT:
+
+        - ``idx`` -- a valid path in ``self`` identifying a node
+
+        - ``value`` -- the tree to be substituted
+
+        EXAMPLES:
+
+        Trying to modify a non mutable tree raise an error::
+
+            sage: x = OrderedTree([])
+            sage: x[0] =  OrderedTree([[]])
+            Traceback (most recent call last):
+            ...
+            ValueError: object is immutable; please change a copy instead.
+
+        Here is the correct way to do it::
+
+            sage: x = OrderedTree([[],[[]]])
+            sage: with x.clone() as x:
+            ...    x[0] = OrderedTree([[]])
+            sage: x
+            [[[]], [[]]]
+
+        One can also substitute at any depths::
+
+            sage: y = OrderedTree(x)
+            sage: with x.clone() as x:
+            ...    x[0,0] = OrderedTree([[]])
+            sage: x
+            [[[[]]], [[]]]
+            sage: y
+            [[[]], [[]]]
+            sage: with y.clone() as y:
+            ...    y[(0,)] = OrderedTree([])
+            sage: y
+            [[], [[]]]
+
+        This works for binary trees as well::
+
+            sage: bt = BinaryTree([[],[[],[]]]); bt
+            [[., .], [[., .], [., .]]]
+            sage: with bt.clone() as bt1:
+            ...    bt1[0,0] = BinaryTree([[[], []], None])
+            sage: bt1
+            [[[[[., .], [., .]], .], .], [[., .], [., .]]]
+
+        TESTS::
+
+            sage: x = OrderedTree([])
+            sage: with x.clone() as x:
+            ...    x[0] = OrderedTree([[]])
+            Traceback (most recent call last):
+            ...
+            IndexError: list assignment index out of range
+
+            sage: x = OrderedTree([]); x = OrderedTree([x,x]);x = OrderedTree([x,x]); x = OrderedTree([x,x])
+            sage: with x.clone() as x:
+            ...    x[0,0] = OrderedTree()
+            sage: x
+            [[[], [[], []]], [[[], []], [[], []]]]
+        """
+        assert isinstance(value, self.__class__)
+
+        if isinstance(idx, tuple):
+            self.__setitem_rec__(idx, 0, value)
+        else:
+            self._setitem(idx, value)
+
+    def __setitem_rec__(self, idx, i, value):
+        """
+        TESTS::
+
+            sage: x = OrderedTree([[[], []],[[]]])
+            sage: with x.clone() as x:
+            ...    x[0,1] = OrderedTree([[[]]]) # indirect doctest
+            sage: x
+            [[[], [[[]]]], [[]]]
+        """
+        if i == len(idx) - 1:
+            self._setitem(idx[-1], value)
+        else:
+            with self[idx[i]].clone() as child:
+                child.__setitem_rec__(idx, i+1, value)
+            self[idx[i]] = child
+
+    def __getitem__(self, idx):
+        """
+        INPUT:
+
+        - ``idx`` -- a valid path in ``self`` identifying a node
+
+        ..note::
+
+            The default implementation here assume that the container of the
+            node inherits from
+            :class:`~sage.structure.list_clone.ClonableArray`.
+
+        EXAMPLES::
+
+            sage: x = OrderedTree([[],[[]]])
+            sage: x[1,0]
+            []
+            sage: x = OrderedTree([[],[[]]])
+            sage: x[()]
+            [[], [[]]]
+            sage: x[(0,)]
+            []
+            sage: x[0,0]
+            Traceback (most recent call last):
+            ...
+            IndexError: list index out of range
+        """
+        if isinstance(idx, slice):
+            return ClonableArray.__getitem__(self, idx)
+        try:
+            i = int(idx)
+        except TypeError:
+            res = self
+            # idx is supposed to be an iterable of ints
+            for i in idx:
+                res = ClonableArray._getitem(res, i)
+            return res
+        else:
+            return ClonableArray._getitem(self, i)
+
+
+class AbstractLabelledTree(AbstractTree):
+    """
+    Abstract Labelled Tree
+
+    Typically a class for labelled tree is contructed by inheriting from a
+    class for unlabelled trees and :class:`AbstractLabelledTree`
+
+    .. rubric:: How should this class be extended ?
+
+    A class extending :class:`AbstractLabelledTree
+    <sage.combinat.abstract_tree.AbstractLabelledTree>` should respect the
+    following assumptions:
+
+    * For a labelled tree ``T`` the call ``T.parent().unlabelled_trees()``
+      should return a parent for labelled trees of the same kind: for example,
+
+      - if ``T`` is a binary labelled tree, ``T.parent()`` is
+        ``LabelledBinaryTrees()`` and ``T.parent().unlabelled_trees()`` is
+        ``BinaryTrees()``
+
+      - if ``T`` is an ordered labelled tree, ``T.parent()`` is
+        ``LabelledOrderedTrees()`` and ``T.parent().unlabelled_trees()`` is
+        ``OrderedTrees()``
+
+    * In the same vein, the class of ``T`` should contains an attribute
+      ``_Unlabelled`` which should be the class for the corresponding
+      unlabelled trees.
+
+    .. SEEALSO:: :class:`AbstractTree`
+    """
+    def __init__(self, parent, children, label = None, check = True):
+        """
+        TESTS::
+
+            sage: LabelledOrderedTree([])
+            None[]
+            sage: LabelledOrderedTree([], 3)
+            3[]
+            sage: LT = LabelledOrderedTree
+            sage: t = LT([LT([LT([], label=42), LT([], 21)])], label=1)
+            sage: t
+            1[None[42[], 21[]]]
+            sage: LabelledOrderedTree(OrderedTree([[],[[],[]],[]]))
+            None[None[], None[None[], None[]], None[]]
+        """
+        # We must initialize the label before the subtrees to allows rooted
+        # trees canonization. Indeed it needs that ``self``._hash_() is working
+        # at the end of the call super(..., self).__init__(...)
+        if isinstance(children, self.__class__):
+            if label is None:
+                self._label = children._label
+            else:
+                self._label = label
+        else:
+            self._label = label
+        super(AbstractLabelledTree, self).__init__(parent, children, check=check)
+
+    def _repr_(self):
+        """
+        Returns the string representation of ``self``
+
+        TESTS::
+
+            sage: LabelledOrderedTree([])            # indirect doctest
+            None[]
+            sage: LabelledOrderedTree([], label=3)   # indirect doctest
+            3[]
+            sage: LabelledOrderedTree([[],[[]]])     # indirect doctest
+            None[None[], None[None[]]]
+            sage: LabelledOrderedTree([[],LabelledOrderedTree([[]], label=2)], label=3)
+            3[None[], 2[None[]]]
+        """
+        return "%s%s"%(self._label, self[:])
+
+    def label(self, path=None):
+        """
+        Returns the label of ``self``
+
+        INPUT:
+
+        - ``path`` -- None (default) or a path (list or tuple of children index
+                     in the tree)
+
+        OUTPUT: the label of the subtree at indexed by ``path``
+
+        EXAMPLES::
+
+            sage: t=LabelledOrderedTree([[],[]], label = 3)
+            sage: t.label()
+            3
+            sage: t[0].label()
+            sage: t=LabelledOrderedTree([LabelledOrderedTree([], 5),[]], label = 3)
+            sage: t.label()
+            3
+            sage: t[0].label()
+            5
+            sage: t[1].label()
+            sage: t.label([0])
+            5
+        """
+        if path is None:
+            return self._label
+        else:
+            tr = self
+            for i in path:
+                tr = tr[i]
+            return tr._label
+
+    def labels(self):
+        """
+        Returns the list of labels of ``self``
+
+        EXAMPLES::
+
+            sage: LT = LabelledOrderedTree
+            sage: t = LT([LT([],label='b'),LT([],label='c')],label='a')
+            sage: t.labels()
+            ['a', 'b', 'c']
+
+            sage: LBT = LabelledBinaryTree
+            sage: LBT([LBT([],label=1),LBT([],label=4)],label=2).labels()
+            [2, 1, 4]
+        """
+        return [t.label() for t in self.subtrees()]
+
+    def leaf_labels(self):
+        """
+        Returns the list of labels of the leaves of ``self``
+
+        EXAMPLES::
+
+            sage: LT = LabelledOrderedTree
+            sage: t = LT([LT([],label='b'),LT([],label='c')],label='a')
+            sage: t.leaf_labels()
+            ['b', 'c']
+
+            sage: LBT = LabelledBinaryTree
+            sage: bt = LBT([LBT([],label='b'),LBT([],label='c')],label='a')
+            sage: bt.leaf_labels()
+            ['b', 'c']
+            sage: LBT([], label='1').leaf_labels()
+            ['1']
+            sage: LBT(None).leaf_labels()
+            []
+        """
+        return [t.label() for t in self.subtrees() if t.node_number()==1]
+
+    def __eq__(self, other):
+        """
+        Tests if ``self`` is equal to ``other``
+
+        TESTS::
+
+            sage  LabelledOrderedTree() == LabelledOrderedTree()
+            True
+            sage  LabelledOrderedTree([]) == LabelledOrderedTree()
+            False
+            sage: t1 = LabelledOrderedTree([[],[[]]])
+            sage: t2 = LabelledOrderedTree([[],[[]]])
+            sage: t1 == t2
+            True
+            sage: t2 = LabelledOrderedTree(t1)
+            sage: t1 == t2
+            True
+            sage: t1 = LabelledOrderedTree([[],[[]]])
+            sage: t2 = LabelledOrderedTree([[[]],[]])
+            sage: t1 == t2
+            False
+        """
+        return ( super(AbstractLabelledTree, self).__eq__(other) and
+                 self._label == other._label )
+
+    def _hash_(self):
+        """
+        Returns the hash value for ``self``
+
+        TESTS::
+
+            sage: t1 = LabelledOrderedTree([[],[[]]], label = 1); t1hash = t1.__hash__()
+            sage: LabelledOrderedTree([[],[[]]], label = 1).__hash__() == t1hash
+            True
+            sage: LabelledOrderedTree([[[]],[]], label = 1).__hash__() == t1hash
+            False
+            sage: LabelledOrderedTree(t1, label = 1).__hash__() == t1hash
+            True
+            sage: LabelledOrderedTree([[],[[]]], label = 25).__hash__() == t1hash
+            False
+            sage: LabelledOrderedTree(t1, label = 25).__hash__() == t1hash
+            False
+
+            sage: LabelledBinaryTree([[],[[],[]]], label = 25).__hash__() #random
+            8544617749928727644
+
+        We check that the hash value depend on the value of the labels of the
+        subtrees::
+
+            sage: LBT = LabelledBinaryTree
+            sage: t1 = LBT([], label = 1)
+            sage: t2 = LBT([], label = 2)
+            sage: t3 = LBT([], label = 3)
+            sage: t12 = LBT([t1, t2], label = "a")
+            sage: t13 = LBT([t1, t3], label = "a")
+            sage: t12.__hash__() != t13.__hash__()
+            True
+        """
+        return self._UnLabelled._hash_(self) ^ hash(self._label)
+
+    def shape(self):
+        """
+        Returns the unlabelled tree associated to ``self``
+
+        EXAMPLES::
+
+            sage: t = LabelledOrderedTree([[],[[]]], label = 25).shape(); t
+            [[], [[]]]
+
+            sage: LabelledBinaryTree([[],[[],[]]], label = 25).shape()
+            [[., .], [[., .], [., .]]]
+
+        TESTS::
+
+            sage: t.parent()
+            Ordered trees
+            sage: type(t)
+            <class 'sage.combinat.ordered_tree.OrderedTrees_all_with_category.element_class'>
+        """
+        TR = self.parent().unlabelled_trees()
+        if not self:
+            return TR.leaf()
+        else:
+            return TR._element_constructor_([i.shape() for i in self])
+
+    def as_digraph(self):
+        """
+        Returns a directed graph version of ``self``
+
+        EXAMPLES::
+
+           sage: LT=LabelledOrderedTrees()
+           sage: ko=LT([LT([],label=6),LT([],label=1)],label=9)
+           sage: ko.as_digraph()
+           Digraph on 3 vertices
+
+           sage: t = BinaryTree([[None, None],[[],None]]);
+           sage: lt = t.canonical_labelling()
+           sage: lt.as_digraph()
+           Digraph on 4 vertices
+        """
+        from sage.graphs.digraph import DiGraph
+        resu=dict([[self.label(),
+                    [t.label() for t in self if not t.is_empty()]]])
+        resu=DiGraph(resu)
+        for t in self:
+            if not t.is_empty():
+                resu=resu.union(t.as_digraph())
+        return resu
+
+
+class AbstractLabelledClonableTree(AbstractLabelledTree,
+                                   AbstractClonableTree):
+    """
+    Abstract Labelled Clonable Tree
+
+    This class take care of modification for the label by the clone protocol.
+
+    .. note:: Due to the limitation of Cython inheritance, one cannot inherit
+       here from :class:`ClonableArray`, because it would prevent us to
+       inherit later from :class:`~sage.structure.list_clone.ClonableList`.
+    """
+    def set_root_label(self, label):
+        """
+        Sets the label of the root of ``self``
+
+        INPUT: ``label`` -- any Sage object
+
+        OUPUT: ``None``, ``self`` is modified in place
+
+        .. note::
+
+            ``self`` must be in a mutable state. See
+            :mod:`sage.structure.list_clone` for more details about
+            mutability.
+
+        EXAMPLES::
+
+            sage: t=LabelledOrderedTree([[],[[],[]]])
+            sage: t.set_root_label(3)
+            Traceback (most recent call last):
+            ...
+            ValueError: object is immutable; please change a copy instead.
+            sage: with t.clone() as t:
+            ...    t.set_root_label(3)
+            sage: t.label()
+            3
+            sage: t
+            3[None[], None[None[], None[]]]
+
+        This also work for binary trees::
+
+            sage: bt=LabelledBinaryTree([[],[]])
+            sage: bt.set_root_label(3)
+            Traceback (most recent call last):
+            ...
+            ValueError: object is immutable; please change a copy instead.
+            sage: with bt.clone() as bt:
+            ...    bt.set_root_label(3)
+            sage: bt.label()
+            3
+            sage: bt
+            3[None[., .], None[., .]]
+
+        TESTS::
+
+            sage: with t.clone() as t:
+            ...    t[0] = LabelledOrderedTree(t[0], label = 4)
+            sage: t
+            3[4[], None[None[], None[]]]
+            sage: with t.clone() as t:
+            ...    t[1,0] = LabelledOrderedTree(t[1,0], label = 42)
+            sage: t
+            3[4[], None[42[], None[]]]
+            """
+        self._require_mutable()
+        self._label = label
+
+    def set_label(self, path, label):
+        """
+        Changes the label of subtree indexed by ``path`` to ``label``
+
+        INPUT:
+
+        - ``path`` -- ``None`` (default) or a path (list or tuple of children
+                      index in the tree)
+
+        - ``label`` -- any sage object
+
+        OUPUT: Nothing, ``self`` is modified in place
+
+        .. note::
+
+            ``self`` must be in a mutable state. See
+            :mod:`sage.structure.list_clone` for more details about
+            mutability.
+
+        EXAMPLES::
+
+            sage: t=LabelledOrderedTree([[],[[],[]]])
+            sage: t.set_label((0,), 4)
+            Traceback (most recent call last):
+            ...
+            ValueError: object is immutable; please change a copy instead.
+            sage: with t.clone() as t:
+            ...    t.set_label((0,), 4)
+            sage: t
+            None[4[], None[None[], None[]]]
+            sage: with t.clone() as t:
+            ...    t.set_label((1,0), label = 42)
+            sage: t
+            None[4[], None[42[], None[]]]
+
+        .. todo::
+
+            Do we want to implement the following syntactic sugar::
+
+                with t.clone() as tt:
+                    tt.labels[1,2] = 3 ?
+        """
+        self._require_mutable()
+        path = tuple(path)
+        if path == ():
+            self._label = label
+        else:
+            with self[path[0]].clone() as child:
+                child.set_label(path[1:], label)
+            self[path[0]] = child
+
+    def map_labels(self, f):
+        """
+        Applies the function `f` to the labels of ``self``
+
+        This method returns a copy of ``self`` on which the function `f` has
+        been applied on all labels (a label `x` is replaced by `f(x)`).
+
+        EXAMPLES::
+
+            sage: LT = LabelledOrderedTree
+            sage: t = LT([LT([],label=1),LT([],label=7)],label=3); t
+            3[1[], 7[]]
+            sage: t.map_labels(lambda z:z+1)
+            4[2[], 8[]]
+
+            sage: LBT = LabelledBinaryTree
+            sage: bt = LBT([LBT([],label=1),LBT([],label=4)],label=2); bt
+            2[1[., .], 4[., .]]
+            sage: bt.map_labels(lambda z:z+1)
+            3[2[., .], 5[., .]]
+        """
+        if self.is_empty():
+            return self
+        return self.parent()([t.map_labels(f) for t in self],
+                             label=f(self.label()))
diff --git a/sage/combinat/all.py b/sage/combinat/all.py
--- a/sage/combinat/all.py
+++ b/sage/combinat/all.py
@@ -86,6 +86,10 @@ from alternating_sign_matrix import Alte
 # Non Decreasing Parking Functions
 from non_decreasing_parking_function import NonDecreasingParkingFunctions, NonDecreasingParkingFunction
 
+from ordered_tree import (OrderedTree, OrderedTrees,
+                          LabelledOrderedTree, LabelledOrderedTrees)
+from binary_tree import (BinaryTree, BinaryTrees,
+                         LabelledBinaryTree, LabelledBinaryTrees)
 
 from combination import Combinations
 from cartesian_product import CartesianProduct
diff --git a/sage/combinat/binary_tree.py b/sage/combinat/binary_tree.py
new file mode 100644
--- /dev/null
+++ b/sage/combinat/binary_tree.py
@@ -0,0 +1,1039 @@
+"""
+Binary trees
+
+This module deals with binary trees as mathematical (in particular immmutable)
+objects. 
+
+.. note :: If you need the data-structure for example to represent sets or hash
+           tables with AVL trees, you should have a look at
+           :mod:`sage.misc.sagex_ds`.
+
+On the use of Factories to query a database of counting algorithms
+------------------------------------------------------------------
+
+**The problem we try to solve**
+
+A common problem in combinatorics is to enumerate or count some standard
+mathematical objects satisfying a set of constraints. For instance, one can be
+interested in the :mod:`partitions <sage.combinat.partition>` of an integer `n`
+of length `7` and parts of size at least `3` and at most `8`, [...]
+
+For partitions, the number of different parameters available is actually quite
+large :
+
+- The length of the partition (i.e. partitions in `k` parts, or in "at least"
+  `k_1` parts "at most" `k_2` parts).
+
+- The sum of the partition (i.e. the integer `n`).
+
+- The min/max size of a part, or even a set of integers such that the partition
+  should only use integers from the given set.
+
+- The min/max slope of the partition.
+
+- An inner and outer profile.
+
+- A min/max value for the lexicographical ordering of the partition.
+
+One may in particular be interested in enumerating/counting the partitions
+satisfying *some arbitrary combination* of constraints using the parameters
+listed above.
+
+This all means that there is a real need of unifying a large family of
+algorithms, so that users do not have to find their way through a library
+of 50 different counting/enumeration algorithms *all* dealing with partitions
+with different set of parameters.
+
+**How we solve it**
+
+We try to build a *database* of algorithms that the user can query easily in
+order to use the best implementation for his needs.
+
+Namely, in the case of :mod:`partitions <sage.combinat.partition>`, we want to
+define a class factory named ``Partitions`` and accepting any combination of
+constraints as an input. The role of the ``Partitions`` class factory is in this
+situation to identify the counting/enumeration algorithm corresponding to this
+set of constraint, and to return a hand-made object with the best set of
+methods.
+
+**The design**
+
+For each combination of constraints that has specific enumeration/counting
+algorithms in Sage, we want to create a corresponding class. The result will be
+-- if we stick with the example of partitions -- a brand new Zoo with weird things
+inside :
+
+- ``PartitionsWithFixedSlopeAndOuterProfile(slope, outer_profile)`` --
+  representing the partitions with slope ``slope`` and outer profile
+  ``outer_profile``
+
+- ``PartitionsWithRestrictedPartsAndBoundedLength(part_set, length)`` --
+  represeting the partitions with a set of allowed parts and given length.
+
+- ...
+
+Each of these classes should define methods like ``__iter__`` (so that we can
+iterate on its elements) or ``cardinality``.
+
+The main class ``Partitions`` will then take as arguments *all of the*
+*combinations of parameters the user may like*, and query the database for the
+best secialized class implemented. The user then receives an instance of this
+specialized class that he can use with the best algorithms implemented.
+
+Of course, it may happen that there is actually no algorithm able to enumerate
+partitions with the set of constraints specified. In this case, the best way is
+to build a class enumerating a larger set of partitions, and to check for each
+of them whether is also satisfies the more restrictive set of constraints. This
+is costly, but it is the best way available, and the library should also be able
+to answer the question *"what is the best implementation available to list the
+partitions asked by the user ?"*. We then need to make sure we enumerate as few
+unnecessary elements as possible.
+
+**AUTHORS:**
+
+- Florent Hivert (2010-2011): initial implementation.
+"""
+#*****************************************************************************
+#       Copyright (C) 2010 Florent Hivert <Florent.Hivert@univ-rouen.fr>,
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#  as published by the Free Software Foundation; either version 2 of
+#  the License, or (at your option) any later version.
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+from sage.structure.list_clone import ClonableArray, ClonableList
+from sage.combinat.abstract_tree import (AbstractClonableTree,
+                                         AbstractLabelledClonableTree)
+from sage.combinat.ordered_tree import LabelledOrderedTrees
+from sage.rings.integer import Integer
+from sage.misc.classcall_metaclass import ClasscallMetaclass
+from sage.misc.lazy_attribute import lazy_attribute, lazy_class_attribute
+
+class BinaryTree(AbstractClonableTree, ClonableArray):
+    """
+    The class of binary trees
+
+    INPUT:
+
+    - ``children`` -- ``None`` (default) or a list, tuple or iterable of
+      length 2 of binary trees or convertible objects.
+
+    - ``check`` -- (default to ``True``) whether check for binary should be
+      performed or not.
+
+    .. warning:: despite what the HTML documentation may say, ``BinaryTree``
+                 does not have any ``parent`` argument, as the examples below
+                 show.
+
+    EXAMPLES::
+
+        sage: BinaryTree()
+        .
+        sage: BinaryTree([None, None])
+        [., .]
+        sage: BinaryTree([None, []])
+        [., [., .]]
+        sage: BinaryTree([[], None])
+        [[., .], .]
+        sage: BinaryTree([[], None, []])
+        Traceback (most recent call last):
+        ...
+        AssertionError: This is not a binary tree
+
+    TESTS::
+
+        sage: t1 = BinaryTree([[None, [[],[[], None]]],[[],[]]])
+        sage: t2 = BinaryTree([[[],[]],[]])
+        sage: with t1.clone() as t1c:
+        ...       t1c[1,1,1] = t2
+        sage: t1 == t1c
+        False
+    """
+    __metaclass__ = ClasscallMetaclass
+
+    @staticmethod
+    def __classcall_private__(cls, *args, **opts):
+        """
+        Ensure that binary trees created by the enumerated sets and directly
+        are the same and that they are instances of :class:`BinaryTree`
+
+        TESTS::
+
+            sage: from sage.combinat.binary_tree import BinaryTrees_all
+            sage: issubclass(BinaryTrees_all().element_class, BinaryTree)
+            True
+            sage: t0 = BinaryTree([[],[[], None]])
+            sage: t0.parent()
+            Binary trees
+            sage: type(t0)
+            <class 'sage.combinat.binary_tree.BinaryTrees_all_with_category.element_class'>
+
+            sage: t1 = BinaryTrees()([[],[[], None]])
+            sage: t1.parent() is t0.parent()
+            True
+            sage: type(t1) is type(t0)
+            True
+
+            sage: t1 = BinaryTrees(4)([[],[[], None]])
+            sage: t1.parent() is t0.parent()
+            True
+            sage: type(t1) is type(t0)
+            True
+        """
+        return cls._auto_parent.element_class(cls._auto_parent, *args, **opts)
+
+    @lazy_class_attribute
+    def _auto_parent(cls):
+        """
+        The automatic parent of the element of this class
+
+        When calling the constructor of an element of this class, one needs a
+        parent. This class attribute specifies which parent is used.
+
+        EXAMPLES::
+
+            sage: BinaryTree._auto_parent
+            Binary trees
+            sage: BinaryTree([None, None]).parent()
+            Binary trees
+         """
+        return BinaryTrees_all()
+
+    def __init__(self, parent, children = None, check=True):
+        """
+        TESTS::
+
+            sage: BinaryTree([None, None]).parent()
+            Binary trees
+        """
+        if children is None:
+            children = []
+        elif children == [] or isinstance(children, (Integer, int)):
+            children = [None, None]
+        if (children.__class__ is self.__class__ and
+            children.parent() == parent):
+            children = list(children)
+        else:
+            children = [self.__class__(parent, x) for x in children]
+        ClonableArray.__init__(self, parent, children, check=check)
+
+    def check(self):
+        """
+        Checks that ``self`` is a binary tree
+
+        EXAMPLES::
+
+            sage: BinaryTree([[], []])     # indirect doctest
+            [[., .], [., .]]
+            sage: BinaryTree([[], [], []]) # indirect doctest
+            Traceback (most recent call last):
+            ...
+            AssertionError: This is not a binary tree
+            sage: BinaryTree([[]])         # indirect doctest
+            Traceback (most recent call last):
+            ...
+            AssertionError: This is not a binary tree
+        """
+        assert (not self or len(self) == 2), "This is not a binary tree"
+
+    def _repr_(self):
+        """
+        TESTS::
+
+            sage: t1 = BinaryTree([[], None]); t1  # indirect doctest
+            [[., .], .]
+            sage: BinaryTree([[None, t1], None])   # indirect doctest
+            [[., [[., .], .]], .]
+        """
+        if not self:
+            return "."
+        else:
+            return super(BinaryTree, self)._repr_()
+
+    def is_empty(self):
+        """
+        Returns whether ``self`` is  empty.
+
+        EXAMPLES::
+
+            sage: BinaryTree().is_empty()
+            True
+            sage: BinaryTree([]).is_empty()
+            False
+            sage: BinaryTree([[], None]).is_empty()
+            False
+        """
+        return not self
+
+    def graph(self):
+        """
+        Convert ``self`` to a digraph
+
+        EXAMPLE::
+
+            sage: t1 = BinaryTree([[], None])
+            sage: t1.graph()
+            Digraph on 5 vertices
+
+            sage: t1 = BinaryTree([[], [[], None]])
+            sage: t1.graph()
+            Digraph on 9 vertices
+            sage: t1.graph().edges()
+            [(0, 1, None), (0, 4, None), (1, 2, None), (1, 3, None), (4, 5, None), (4, 8, None), (5, 6, None), (5, 7, None)]
+        """
+        from sage.graphs.graph import DiGraph
+        res = DiGraph()
+        def rec(tr, idx):
+            if not tr:
+                return
+            else:
+                nbl = 2*tr[0].node_number() + 1
+                res.add_edges([[idx,idx+1], [idx,idx+1+nbl]])
+                rec(tr[0], idx + 1)
+                rec(tr[1], idx + nbl + 1)
+        rec(self, 0)
+        return res
+
+    def canonical_labelling(self,shift=1):
+        """
+        Returns a labelled version of ``self``.
+
+        The actual canonical labelling is currently unspecified. However, it
+        is guaranteed to have labels in `1...n` where `n` is the number of
+        node of the tree. Moreover, two (unlabelled) trees compare as equal if
+        and only if they canonical labelled trees compare as equal.
+
+        EXAMPLES::
+
+            sage: BinaryTree().canonical_labelling()
+            .
+            sage: BinaryTree([]).canonical_labelling()
+            1[., .]
+            sage: BinaryTree([[[], [[], None]], [[], []]]).canonical_labelling()
+            5[2[1[., .], 4[3[., .], .]], 7[6[., .], 8[., .]]]
+        """
+        LTR = self.parent().labelled_trees()
+        if self:
+            sz0 = self[0].node_number()
+            return LTR([self[0].canonical_labelling(shift),
+                        self[1].canonical_labelling(shift+1+sz0)],
+                       label=shift+sz0)
+        else:
+            return LTR(None)
+
+    def show(self):
+        """
+        TESTS::
+
+            sage: t1 = BinaryTree([[], [[], None]])
+            sage: t1.show()
+        """
+        self.graph().show(layout='tree', tree_root=0, tree_orientation="down")
+
+    def make_node(self, child_list = [None, None]):
+        """
+        Modify ``self`` so that it becomes a node with children ``childlist``
+
+        INPUT:
+
+        - ``child_list`` -- a pair of binary trees (or objects convertible to)
+
+        .. note:: ``self`` must be in a mutable state.
+
+        .. seealso::
+            :meth:`make_leaf <sage.combinat.binary_tree.BinaryTree.make_leaf>`
+
+        EXAMPLES::
+
+            sage: t = BinaryTree()
+            sage: t.make_node([None, None])
+            Traceback (most recent call last):
+            ...
+            ValueError: object is immutable; please change a copy instead.
+            sage: with t.clone() as t1:
+            ...    t1.make_node([None, None])
+            sage: t, t1
+            (., [., .])
+            sage: with t.clone() as t:
+            ...    t.make_node([BinaryTree(), BinaryTree(), BinaryTree([])])
+            Traceback (most recent call last):
+            AssertionError: the list must have length 2
+            sage: with t1.clone() as t2:
+            ...    t2.make_node([t1, t1])
+            sage: with t2.clone() as t3:
+            ...    t3.make_node([t1, t2])
+            sage: t1, t2, t3
+            ([., .], [[., .], [., .]], [[., .], [[., .], [., .]]])
+        """
+        self._require_mutable()
+        child_lst = [self.__class__(self.parent(), x) for x in child_list]
+        assert(len(child_lst) == 2), "the list must have length 2"
+        self.__init__(self.parent(), child_lst, check=False)
+
+    def make_leaf(self):
+        """
+        Modify ``self`` so that it became a leaf
+
+        .. note:: ``self`` must be in a mutable state.
+
+        .. seealso::
+            :meth:`make_node <sage.combinat.binary_tree.BinaryTree.make_node>`
+
+        EXAMPLES::
+
+            sage: t = BinaryTree([None, None])
+            sage: t.make_leaf()
+            Traceback (most recent call last):
+            ...
+            ValueError: object is immutable; please change a copy instead.
+            sage: with t.clone() as t1:
+            ...    t1.make_leaf()
+            sage: t, t1
+            ([., .], .)
+        """
+        self._require_mutable()
+        self.__init__(self.parent(), None)
+
+    def _to_dyck_word_rec(self):
+        r"""
+        EXAMPLES::
+
+            sage: BinaryTree()._to_dyck_word_rec()
+            []
+            sage: BinaryTree([])._to_dyck_word_rec()
+            [1, 0]
+            sage: BinaryTree([[[], [[], None]], [[], []]])._to_dyck_word_rec()
+            [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0]
+        """
+        if self:
+            return ([1]+self[0]._to_dyck_word_rec()+
+                    [0]+self[1]._to_dyck_word_rec())
+        else:
+            return []
+
+    def to_dyck_word(self):
+        r"""
+        Return the Dyck word associated to ``self``
+
+        The bijection is defined recursively as follows:
+
+        - a leaf is associated to the empty Dyck Word
+
+        - a tree with chidren `l,r` is associated to the Dyck word
+          `1 T(l) 0 T(r)` where `T(l)` and `T(r)` are the trees
+          associated to `l` and `r`.
+
+        EXAMPLES::
+
+            sage: BinaryTree().to_dyck_word()
+            []
+            sage: BinaryTree([]).to_dyck_word()
+            [1, 0]
+            sage: BinaryTree([[[], [[], None]], [[], []]]).to_dyck_word()
+            [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0]
+        """
+        from sage.combinat.dyck_word import DyckWord
+        return DyckWord(self._to_dyck_word_rec())
+
+    def canopee(self):
+        """
+        Returns the canopee of ``self``
+
+        The *canopee* of a non empty binary tree `T` with `n` internal nodes is
+        the list `l` of `0` and `1` of length `n-1` obtained by going along the
+        leaves of `T` from left to right except the two extremal ones, writing
+        `0` if the leaf is a right leaf and `1` is a left leaf.
+
+        EXAMPLES::
+
+            sage: BinaryTree([]).canopee()
+            []
+            sage: BinaryTree([None, []]).canopee()
+            [1]
+            sage: BinaryTree([[], None]).canopee()
+            [0]
+            sage: BinaryTree([[], []]).canopee()
+            [0, 1]
+            sage: BinaryTree([[[], [[], None]], [[], []]]).canopee()
+            [0, 1, 0, 0, 1, 0, 1]
+
+        The number of pairs `(t_1, t_2)` of binary trees of size `n` such that
+        the canopee of `t_1` is the complementary of the canopee of `t_2` is
+        also the number of Baxter permutations (see [DG]_, see also sequences
+        A001181 in Sloane's database). We check this in small cases::
+
+            sage: [len([(u,v) for u in BinaryTrees(n) for v in BinaryTrees(n)
+            ...       if map(lambda x:1-x, u.canopee()) == v.canopee()])
+            ...    for n in range(1, 5)]
+            [1, 2, 6, 22]
+
+        Here is a less trivial implementation of this::
+
+            sage: from sage.sets.finite_set_map_cy import fibers
+            sage: from sage.misc.all import attrcall
+            sage: def baxter(n):
+            ...      f = fibers(lambda t: tuple(t.canopee()),
+            ...                   BinaryTrees(n))
+            ...      return sum(len(f[i])*len(f[tuple(1-x for x in i)])
+            ...                 for i in f)
+            sage: [baxter(n) for n in range(1, 7)]
+            [1, 2, 6, 22, 92, 422]
+
+        TESTS::
+
+            sage: t = BinaryTree().canopee()
+            Traceback (most recent call last):
+            ...
+            ValueError: canopee is only defined for non empty binary trees
+
+        REFERENCES:
+
+            .. [DG] \S. Dulucq and O, Guibert. Mots de piles, tableaux
+               standards et permutations de Baxter, proceedings of
+               Formal Power Series and Algebraic Combinatorics, 1994.
+        """
+        if not self:
+            raise ValueError, "canopee is only defined for non empty binary trees"
+        res = []
+        def add_leaf_rec(tr):
+            for i in range(2):
+                if tr[i]:
+                    add_leaf_rec(tr[i])
+                else:
+                    res.append(1-i)
+        add_leaf_rec(self)
+        return res[1:-1]
+
+
+from sage.structure.parent import Parent
+from sage.structure.unique_representation import UniqueRepresentation
+from sage.misc.classcall_metaclass import ClasscallMetaclass
+
+from sage.sets.non_negative_integers import NonNegativeIntegers
+from sage.sets.disjoint_union_enumerated_sets import DisjointUnionEnumeratedSets
+from sage.sets.family import Family
+from sage.misc.cachefunc import cached_method
+
+
+# Abstract class to serve as a Factory no instance are created.
+class BinaryTrees(UniqueRepresentation, Parent):
+    """
+    Factory for binary trees.
+
+    INPUT:
+
+    - ``size`` -- (optional) an integer
+
+    OUPUT:
+
+    - the set of all binary trees (of the given ``size`` if specified)
+
+    EXAMPLES::
+
+        sage: BinaryTrees()
+        Binary trees
+
+        sage: BinaryTrees(2)
+        Binary trees of size 2
+
+    .. note:: this in a factory class whose constructor returns instances of
+              subclasses.
+
+    .. note:: the fact that OrderedTrees is a class instead a simple callable
+              is an implementation detail. It could be changed in the future
+              and one should not rely on it.
+    """
+    @staticmethod
+    def __classcall_private__(cls, n=None):
+        """
+        TESTS::
+
+            sage: from sage.combinat.binary_tree import BinaryTrees_all, BinaryTrees_size
+            sage: isinstance(BinaryTrees(2), BinaryTrees)
+            True
+            sage: isinstance(BinaryTrees(), BinaryTrees)
+            True
+            sage: BinaryTrees(2) is BinaryTrees_size(2)
+            True
+            sage: BinaryTrees(5).cardinality()
+            42
+            sage: BinaryTrees() is BinaryTrees_all()
+            True
+        """
+        if n is None:
+            return BinaryTrees_all()
+        else:
+            assert (isinstance(n, (Integer, int)) and n >= 0), "n must be a non negative integer"
+            return BinaryTrees_size(Integer(n))
+
+    @cached_method
+    def leaf(self):
+        """
+        Return a left tree with ``self`` as parent.
+
+        EXAMPLES::
+
+            sage: BinaryTrees().leaf()
+            .
+
+        TEST::
+
+            sage: (BinaryTrees().leaf() is
+            ...    sage.combinat.binary_tree.BinaryTrees_all().leaf())
+            True
+        """
+        return self(None)
+
+#################################################################
+# Enumerated set of all binary trees
+#################################################################
+class BinaryTrees_all(DisjointUnionEnumeratedSets, BinaryTrees):
+
+    def __init__(self):
+        """
+        TESTS::
+
+            sage: from sage.combinat.binary_tree import BinaryTrees_all
+            sage: B = BinaryTrees_all()
+            sage: B.cardinality()
+            +Infinity
+
+            sage: it = iter(B)
+            sage: (it.next(), it.next(), it.next(), it.next(), it.next())
+            (., [., .], [., [., .]], [[., .], .], [., [., [., .]]])
+            sage: it.next().parent()
+            Binary trees
+            sage: B([])
+            [., .]
+
+            sage: B is BinaryTrees_all()
+            True
+            sage: TestSuite(B).run()
+            """
+        DisjointUnionEnumeratedSets.__init__(
+            self, Family(NonNegativeIntegers(), BinaryTrees_size),
+            facade=True, keepkey = False)
+
+    def _repr_(self):
+        """
+        TEST::
+
+            sage: BinaryTrees()   # indirect doctest
+            Binary trees
+        """
+        return "Binary trees"
+
+    def __contains__(self, x):
+        """
+        TESTS::
+
+            sage: S = BinaryTrees()
+            sage: 1 in S
+            False
+            sage: S([]) in S
+            True
+        """
+        return isinstance(x, self.element_class)
+
+    def __call__(self, x=None, *args, **keywords):
+        """
+        Ensure that ``None`` instead of ``0`` is passed by default.
+
+        TESTS::
+
+            sage: B = BinaryTrees()
+            sage: B()
+            .
+        """
+        return super(BinaryTrees, self).__call__(x, *args, **keywords)
+
+    def unlabelled_trees(self):
+        """
+        Returns the set of unlabelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: BinaryTrees().unlabelled_trees()
+            Binary trees
+        """
+        return self
+
+    def labelled_trees(self):
+        """
+        Returns the set of labelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: BinaryTrees().labelled_trees()
+            Labelled binary trees
+        """
+        return LabelledBinaryTrees()
+
+    def _element_constructor_(self, *args, **keywords):
+        """
+        EXAMPLES::
+
+            sage: B = BinaryTrees()
+            sage: B._element_constructor_([])
+            [., .]
+            sage: B([[],[]]) # indirect doctest
+            [[., .], [., .]]
+            sage: B(None)    # indirect doctest
+            .
+        """
+        return self.element_class(self, *args, **keywords)
+
+    Element = BinaryTree
+
+from sage.misc.lazy_attribute import lazy_attribute
+from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
+from combinat import catalan_number
+#################################################################
+# Enumerated set of binary trees of a given size
+#################################################################
+class BinaryTrees_size(BinaryTrees):
+    """
+    The enumerated sets of binary trees of given size
+
+    TESTS::
+
+        sage: from sage.combinat.binary_tree import BinaryTrees_size
+        sage: for i in range(6): TestSuite(BinaryTrees_size(i)).run()
+    """
+    def __init__(self, size):
+        """
+        TESTS::
+
+            sage: S = BinaryTrees(3)
+            sage: S == loads(dumps(S))
+            True
+
+            sage: S is BinaryTrees(3)
+            True
+        """
+        super(BinaryTrees_size, self).__init__(category = FiniteEnumeratedSets())
+        self._size = size
+
+    def _repr_(self):
+        """
+        TESTS::
+
+            sage: BinaryTrees(3)   # indirect doctest
+            Binary trees of size 3
+        """
+        return "Binary trees of size %s"%(self._size)
+
+    def __contains__(self, x):
+        """
+        TESTS::
+
+            sage: S = BinaryTrees(3)
+            sage: 1 in S
+            False
+            sage: S([[],[]]) in S
+            True
+        """
+        return isinstance(x, self.element_class) and x.node_number() == self._size
+
+    def _an_element_(self):
+        """
+        TESTS::
+
+            sage: BinaryTrees(0).an_element()  # indirect doctest
+            .
+        """
+        return self.first()
+
+    def cardinality(self):
+        """
+        The cardinality of self
+
+        This is a Catalan number.
+
+        TESTS::
+
+            sage: BinaryTrees(0).cardinality()
+            1
+            sage: BinaryTrees(5).cardinality()
+            42
+        """
+        return catalan_number(self._size)
+
+    def __iter__(self):
+        """
+        A basic generator.
+
+        .. todo:: could be optimized.
+
+        TESTS::
+
+            sage: BinaryTrees(0).list()
+            [.]
+            sage: BinaryTrees(1).list()
+            [[., .]]
+            sage: BinaryTrees(3).list()
+            [[., [., [., .]]], [., [[., .], .]], [[., .], [., .]], [[., [., .]], .], [[[., .], .], .]]
+        """
+        if self._size == 0:
+            yield self._element_constructor_()
+        else:
+            for i in range(0, self._size):
+                for lft in self.__class__(i):
+                    for rgt in self.__class__(self._size-1-i):
+                        yield self._element_constructor_([lft, rgt])
+
+    @lazy_attribute
+    def _parent_for(self):
+        """
+        The parent of the element generated by ``self``
+
+        TESTS::
+
+            sage: S = BinaryTrees(3)
+            sage: S._parent_for
+            Binary trees
+        """
+        return BinaryTrees_all()
+
+    @lazy_attribute
+    def element_class(self):
+        """
+        TESTS::
+
+            sage: S = BinaryTrees(3)
+            sage: S.element_class
+            <class 'sage.combinat.binary_tree.BinaryTrees_all_with_category.element_class'>
+            sage: S.first().__class__ == BinaryTrees().first().__class__
+            True
+        """
+        return self._parent_for.element_class
+
+    def _element_constructor_(self, *args, **keywords):
+        """
+        EXAMPLES::
+
+            sage: S = BinaryTrees(0)
+            sage: S([])   # indirect doctest
+            Traceback (most recent call last):
+            ...
+            ValueError: Wrong number of nodes
+            sage: S(None)   # indirect doctest
+            .
+
+            sage: S = BinaryTrees(1)   # indirect doctest
+            sage: S([])
+            [., .]
+        """
+        res = self.element_class(self._parent_for, *args, **keywords)
+        if res.node_number() != self._size:
+            raise ValueError, "Wrong number of nodes"
+        return res
+
+
+
+class LabelledBinaryTree(AbstractLabelledClonableTree, BinaryTree):
+    """
+    The class of labelled binary tree
+
+    EXAMPLE::
+
+        sage: LBT = LabelledBinaryTree
+        sage: t1 = LBT([[LBT([], label=2), None], None], label=4); t1
+        4[None[2[., .], .], .]
+    """
+    __metaclass__ = ClasscallMetaclass
+
+    @staticmethod
+    def __classcall_private__(cls, *args, **opts):
+        """
+        Ensure that trees created by the sets and directly are the same and
+        that they are instance of :class:`LabelledTree`
+
+        TESTS::
+
+            sage: issubclass(LabelledBinaryTrees().element_class, LabelledBinaryTree)
+            True
+            sage: t0 = LabelledBinaryTree([[],[[], None]], label = 3)
+            sage: t0.parent()
+            Labelled binary trees
+            sage: type(t0)
+            <class 'sage.combinat.binary_tree.LabelledBinaryTrees_with_category.element_class'>
+        """
+        return cls._auto_parent.element_class(cls._auto_parent, *args, **opts)
+
+    @lazy_class_attribute
+    def _auto_parent(cls):
+        """
+        The automatic parent of the element of this class
+
+        When calling the constructor of an element of this class, one need a
+        parent. This class attribute specifies which parent is used.
+
+        EXAMPLES::
+
+            sage: LabelledBinaryTree._auto_parent
+            Labelled binary trees
+            sage: LabelledBinaryTree([], label = 3).parent()
+            Labelled binary trees
+         """
+        return LabelledBinaryTrees()
+
+    def _repr_(self):
+        """
+        TESTS::
+
+            sage: LBT = LabelledBinaryTree
+            sage: t1 = LBT([[LBT([], label=2), None], None], label=4); t1
+            4[None[2[., .], .], .]
+            sage: LBT([[],[[], None]], label = 3)   # indirect doctest
+            3[None[., .], None[None[., .], .]]
+        """
+        if not self:
+            if self._label is not None:
+                return repr(self._label)
+            else:
+                return "."
+        else:
+            return "%s%s"%(self._label, self[:])
+
+    def binary_search_insert(self, letter):
+        """
+        Insert a letter in a binary search tree
+
+        INPUT:
+
+        - ``letter`` -- any object comparable with the label of ``self``
+
+        .. note:: ``self`` is supposed to be a binary search tree. No check is
+                  performed.
+
+        EXAMPLES::
+
+            sage: LBT = LabelledBinaryTree
+            sage: LBT(None).binary_search_insert(3)
+            3[., .]
+            sage: LBT([], label = 1).binary_search_insert(3)
+            1[., 3[., .]]
+            sage: LBT([], label = 3).binary_search_insert(1)
+            3[1[., .], .]
+            sage: res = LBT(None)
+            sage: for i in [3,1,5,2,4,6]:
+            ...       res = res.binary_search_insert(i)
+            sage: res
+            3[1[., 2[., .]], 5[4[., .], 6[., .]]]
+        """
+        LT = self.parent()._element_constructor_
+        if not self:
+            return LT([], label = letter)
+        else:
+            if letter <= self.label():
+                fils = self[0].binary_search_insert(letter)
+                return LT([fils, self[1]], label=self.label())
+            else:
+                fils = self[1].binary_search_insert(letter)
+                return LT([self[0], fils], label=self.label())
+
+    _UnLabelled = BinaryTree
+
+
+class LabelledBinaryTrees(LabelledOrderedTrees):
+    """
+    This is a parent stub to serve as a factory class for trees with various
+    labels constraints
+    """
+    def _repr_(self):
+        """
+        TESTS::
+
+            sage: LabelledBinaryTrees()   # indirect doctest
+            Labelled binary trees
+        """
+        return "Labelled binary trees"
+
+    def _an_element_(self):
+        """
+        Returns a labelled binary tree
+
+        EXAMPLE::
+
+            sage: LabelledBinaryTrees().an_element()   # indirect doctest
+            toto[42[3[., .], 3[., .]], 5[None[., .], None[., .]]]
+        """
+        LT = self._element_constructor_
+        t  = LT([], label = 3)
+        t1 = LT([t,t], label = 42)
+        t2  = LT([[], []], label = 5)
+        return LT([t1,t2], label = "toto")
+
+    def unlabelled_trees(self):
+        """
+        Returns the set of unlabelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: LabelledBinaryTrees().unlabelled_trees()
+            Binary trees
+
+        This is used to compute the shape::
+
+            sage: t = LabelledBinaryTrees().an_element().shape(); t
+            [[[., .], [., .]], [[., .], [., .]]]
+            sage: t.parent()
+            Binary trees
+
+        TESTS::
+
+            sage: t = LabelledBinaryTrees().an_element()
+            sage: t.canonical_labelling()
+            4[2[1[., .], 3[., .]], 6[5[., .], 7[., .]]]
+        """
+        return BinaryTrees_all()
+
+    def labelled_trees(self):
+        """
+        Returns the set of labelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: LabelledBinaryTrees().labelled_trees()
+            Labelled binary trees
+        """
+        return self
+
+    Element = LabelledBinaryTree
+
+
+
+################################################################
+# Interface attempt with species...
+#
+# Kept here for further reference when species will be improved
+################################################################
+# from sage.combinat.species.library import (
+#     CombinatorialSpecies, EmptySetSpecies, SingletonSpecies)
+
+# BT = CombinatorialSpecies()
+# F =  EmptySetSpecies()
+# N =  SingletonSpecies()
+# BT.define(F+N*(BT*BT))
+# # b3 = BT.isotypes(range(3))
+# # tr = b3.list()[1]
+
+# def BTsp_to_bintrees(bt):
+#     """
+#     sage: from sage.combinat.binary_tree import BT, BTsp_to_bintrees
+#     sage: BTsp_to_bintrees(BT.isotypes(range(5))[0])
+#     [., [., [., [., [., .]]]]]
+#     sage: def spls(size):
+#     ...    return map(BTsp_to_bintrees, BT.isotypes(range(size)).list())
+#     sage: spls(3)
+#     [[., [., [., .]]], [., [[., .], .]], [[., .], [., .]], [[., [., .]], .], [[[., .], .], .]]
+#     sage: all(spls(i) == BinaryTrees(i).list() for i in range(5))
+#     True
+#     """
+#     if len(bt) == 0:
+#         return BinaryTree()
+#     elif len(bt) == 2 and len(bt[1]) == 2:
+#         return BinaryTree(map(BTsp_to_bintrees, list(bt[1])))
+#     else:
+#         raise ValueError
diff --git a/sage/combinat/ordered_tree.py b/sage/combinat/ordered_tree.py
new file mode 100644
--- /dev/null
+++ b/sage/combinat/ordered_tree.py
@@ -0,0 +1,748 @@
+"""
+Ordered Rooted Trees
+
+AUTHORS:
+
+- Florent Hivert (2010-2011): initial revision
+- Frederic Chapoton (2010): contributed some methods
+"""
+#*****************************************************************************
+#       Copyright (C) 2010 Florent Hivert <Florent.Hivert@univ-rouen.fr>,
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#  as published by the Free Software Foundation; either version 2 of
+#  the License, or (at your option) any later version.
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+from sage.structure.list_clone import ClonableArray, ClonableList
+from sage.structure.parent import Parent
+from sage.structure.unique_representation import UniqueRepresentation
+from sage.misc.classcall_metaclass import ClasscallMetaclass
+from sage.misc.lazy_attribute import lazy_class_attribute
+from sage.combinat.abstract_tree import (AbstractClonableTree,
+                                         AbstractLabelledClonableTree)
+
+class OrderedTree(AbstractClonableTree, ClonableList):
+    """
+    The class for (ordered rooted) Trees
+
+    An ordered tree is a constructed from a node called the root on which one
+    has grafted a possibly empty list of trees. There is a total order on the
+    children of a node which is given by the the order of the element in the
+    list. Note that there is no empty ordered tree.
+
+    One can create a tree from any list (or more generally iterable) of trees
+    or objects convertible to a tree.
+
+    EXAMPLES::
+
+        sage: x = OrderedTree([])
+        sage: x1 = OrderedTree([x,x])
+        sage: x2 = OrderedTree([[],[]])
+        sage: x1 == x2
+        True
+        sage: tt1 = OrderedTree([x,x1,x2])
+        sage: tt2 = OrderedTree([[], [[], []], x2])
+        sage: tt1 == tt2
+        True
+
+        sage: OrderedTree([]) == OrderedTree()
+        True
+
+    TESTS::
+
+        sage: x1.__hash__() == x2.__hash__()
+        True
+        sage: tt1.__hash__() == tt2.__hash__()
+        True
+
+    Trees are usually immutable. However they inherits from
+    :class:`sage.structure.list_clone.ClonableList`. So that they can be
+    modified using the clone protocol:
+
+    Trying to modify a non mutable tree raise an error::
+
+        sage: tt1[1] = tt2
+        Traceback (most recent call last):
+        ...
+        ValueError: object is immutable; please change a copy instead.
+
+    Here is the correct way to do it::
+
+        sage: with tt2.clone() as tt2:
+        ...    tt2[1] = tt1
+        sage: tt2
+        [[], [[], [[], []], [[], []]], [[], []]]
+
+    It is also possible to append a child to a tree::
+
+        sage: with tt2.clone() as tt3:
+        ...    tt3.append(OrderedTree([]))
+        sage: tt3
+        [[], [[], [[], []], [[], []]], [[], []], []]
+
+    Or to insert a child in a tree::
+
+        sage: with tt2.clone() as tt3:
+        ...    tt3.insert(2, OrderedTree([]))
+        sage: tt3
+        [[], [[], [[], []], [[], []]], [], [[], []]]
+
+    We check that ``tt1`` is not modified and that everything is correct with
+    respect to equality::
+
+        sage: tt1
+        [[], [[], []], [[], []]]
+        sage: tt1 == tt2
+        False
+        sage: tt1.__hash__() == tt2.__hash__()
+        False
+
+    TESTS::
+
+        sage: tt1bis = OrderedTree(tt1)
+        sage: with tt1.clone() as tt1:
+        ...    tt1[1] = tt1bis
+        sage: tt1
+        [[], [[], [[], []], [[], []]], [[], []]]
+        sage: tt1 == tt2
+        True
+        sage: tt1.__hash__() == tt2.__hash__()
+        True
+        sage: len(tt1)
+        3
+        sage: tt1[2]
+        [[], []]
+        sage: tt1[3]
+        Traceback (most recent call last):
+        ...
+        IndexError: list index out of range
+        sage: tt1[1:2]
+        [[[], [[], []], [[], []]]]
+
+    Various tests involving construction, equality and hashing::
+
+        sage: OrderedTree() == OrderedTree()
+        True
+        sage: t1 = OrderedTree([[],[[]]])
+        sage: t2 = OrderedTree([[],[[]]])
+        sage: t1 == t2
+        True
+        sage: t2 = OrderedTree(t1)
+        sage: t1 == t2
+        True
+        sage: t1 = OrderedTree([[],[[]]])
+        sage: t2 = OrderedTree([[[]],[]])
+        sage: t1 == t2
+        False
+
+        sage: t1 = OrderedTree([[],[[]]])
+        sage: t2 = OrderedTree([[],[[]]])
+        sage: t1.__hash__() == t2.__hash__()
+        True
+        sage: t2 = OrderedTree([[[]],[]])
+        sage: t1.__hash__() == t2.__hash__()
+        False
+        sage: OrderedTree().__hash__() == OrderedTree([]).__hash__()
+        True
+        sage: tt1 = OrderedTree([t1,t2,t1])
+        sage: tt2 = OrderedTree([t1, [[[]],[]], t1])
+        sage: tt1.__hash__() == tt2.__hash__()
+        True
+
+    Check that the hash value is correctly updated after modification::
+
+        sage: with tt2.clone() as tt2:
+        ...    tt2[1,1] = tt1
+        sage: tt1.__hash__() == tt2.__hash__()
+        False
+    """
+
+    __metaclass__ = ClasscallMetaclass
+
+    @staticmethod
+    def __classcall_private__(cls, *args, **opts):
+        """
+        Ensure that trees created by the enumerated sets and directly
+        are the same and that they are instance of :class:`OrderedTree`
+
+        TESTS::
+
+            sage: issubclass(OrderedTrees().element_class, OrderedTree)
+            True
+            sage: t0 = OrderedTree([[],[[], []]])
+            sage: t0.parent()
+            Ordered trees
+            sage: type(t0)
+            <class 'sage.combinat.ordered_tree.OrderedTrees_all_with_category.element_class'>
+
+            sage: t1 = OrderedTrees()([[],[[], []]])
+            sage: t1.parent() is t0.parent()
+            True
+            sage: type(t1) is type(t0)
+            True
+
+            sage: t1 = OrderedTrees(4)([[],[[]]])
+            sage: t1.parent() is t0.parent()
+            True
+            sage: type(t1) is type(t0)
+            True
+        """
+        return cls._auto_parent.element_class(cls._auto_parent, *args, **opts)
+
+    @lazy_class_attribute
+    def _auto_parent(cls):
+        """
+        The automatic parent of the element of this class
+
+        When calling the constructor of an element of this class, one need a
+        parent. This class attribute specifies which parent is used.
+
+        EXAMPLES::
+
+            sage: OrderedTree([[],[[]]])._auto_parent
+            Ordered trees
+            sage: OrderedTree([[],[[]]]).parent()
+            Ordered trees
+
+        .. note::
+
+            It is possible to bypass the automatic parent mechanism using:
+
+                sage: t1 = OrderedTree.__new__(OrderedTree, Parent(), [])
+                sage: t1.__init__(Parent(), [])
+                sage: t1
+                []
+                sage: t1.parent()
+                <type 'sage.structure.parent.Parent'>
+        """
+        return OrderedTrees_all()
+
+    def __init__(self, parent=None, children=[], check=True):
+        """
+        TESTS::
+
+            sage: t1 = OrderedTrees(4)([[],[[]]])
+            sage: TestSuite(t1).run()
+        """
+        if (children.__class__ is self.__class__ and
+            children.parent() == parent):
+            children = list(children)
+        else:
+            children = [self.__class__(parent, x) for x in children]
+        ClonableArray.__init__(self, parent, children, check=check)
+
+    def is_empty(self):
+        """
+        Return if ``self`` is the empty tree
+
+        For ordered trees, returns always ``False``
+
+        .. note:: this is different from ``bool(t)`` which returns whether
+                  ``t`` has some child or not.
+
+        EXAMPLES::
+
+            sage: t = OrderedTrees(4)([[],[[]]])
+            sage: t.is_empty()
+            False
+            sage: bool(t)
+            True
+        """
+        return False
+
+from sage.categories.sets_cat import Sets, EmptySetError
+from sage.rings.integer import Integer
+from sage.sets.non_negative_integers import NonNegativeIntegers
+from sage.sets.disjoint_union_enumerated_sets import DisjointUnionEnumeratedSets
+from sage.sets.family import Family
+from sage.misc.cachefunc import cached_method
+
+# Abstract class to serve as a Factory no instance are created.
+class OrderedTrees(UniqueRepresentation, Parent):
+    """
+    Factory for ordered trees
+
+    INPUT:
+
+    - ``size`` -- (optional) an integer
+
+    OUPUT:
+
+    - the set of all ordered trees (of the given ``size`` if specified)
+
+    EXAMPLES::
+
+        sage: OrderedTrees()
+        Ordered trees
+
+        sage: OrderedTrees(2)
+        Ordered trees of size 2
+
+    .. note:: this in a factory class whose constructor returns instances of
+              subclasses.
+
+    .. note:: the fact that OrderedTrees is a class instead a simple callable
+              is an implementation detail. It could be changed in the future
+              and one should not rely on it.
+    """
+    @staticmethod
+    def __classcall_private__(cls, n=None):
+        """
+        TESTS::
+
+            sage: from sage.combinat.ordered_tree import OrderedTrees_all, OrderedTrees_size
+            sage: isinstance(OrderedTrees(2), OrderedTrees)
+            True
+            sage: isinstance(OrderedTrees(), OrderedTrees)
+            True
+            sage: OrderedTrees(2) is OrderedTrees_size(2)
+            True
+            sage: OrderedTrees(5).cardinality()
+            14
+            sage: OrderedTrees() is OrderedTrees_all()
+            True
+        """
+        if n is None:
+            return OrderedTrees_all()
+        else:
+            assert (isinstance(n, (Integer, int)) and n >= 0), "n must be a non negative integer"
+            return OrderedTrees_size(Integer(n))
+
+    @cached_method
+    def leaf(self):
+        """
+        Return a leaf tree with ``self`` as parent
+
+        EXAMPLES::
+
+            sage: OrderedTrees().leaf()
+            []
+
+        TEST::
+
+            sage: (OrderedTrees().leaf() is
+            ...    sage.combinat.ordered_tree.OrderedTrees_all().leaf())
+            True
+        """
+        return self([])
+
+class OrderedTrees_all(DisjointUnionEnumeratedSets, OrderedTrees):
+    """
+    The set of all ordered trees
+
+    EXAMPLES::
+
+        sage: OT = OrderedTrees(); OT
+        Ordered trees
+        sage: OT.cardinality()
+        +Infinity
+    """
+
+    def __init__(self):
+        """
+        TESTS::
+
+            sage: from sage.combinat.ordered_tree import OrderedTrees_all
+            sage: B = OrderedTrees_all()
+            sage: B.cardinality()
+            +Infinity
+
+            sage: it = iter(B)
+            sage: (it.next(), it.next(), it.next(), it.next(), it.next())
+            ([], [[]], [[], []], [[[]]], [[], [], []])
+            sage: it.next().parent()
+            Ordered trees
+            sage: B([])
+            []
+
+            sage: B is OrderedTrees_all()
+            True
+            sage: TestSuite(B).run()
+            """
+        DisjointUnionEnumeratedSets.__init__(
+            self, Family(NonNegativeIntegers(), OrderedTrees_size),
+            facade=True, keepkey=False)
+
+    def _repr_(self):
+        """
+        TEST::
+
+            sage: OrderedTrees()   # indirect doctest
+            Ordered trees
+        """
+        return "Ordered trees"
+
+    def __contains__(self, x):
+        """
+        TESTS::
+
+            sage: T = OrderedTrees()
+            sage: 1 in T
+            False
+            sage: T([]) in T
+            True
+        """
+        return isinstance(x, self.element_class)
+
+    def unlabelled_trees(self):
+        """
+        Returns the set of unlabelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: OrderedTrees().unlabelled_trees()
+            Ordered trees
+        """
+        return self
+
+    def labelled_trees(self):
+        """
+        Returns the set of unlabelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: OrderedTrees().labelled_trees()
+            Labelled ordered trees
+        """
+        return LabelledOrderedTrees()
+
+    def _element_constructor_(self, *args, **keywords):
+        """
+        EXAMPLES::
+
+            sage: T = OrderedTrees()
+            sage: T([])     # indirect doctest
+            []
+        """
+        return self.element_class(self, *args, **keywords)
+
+    Element = OrderedTree
+
+
+
+from sage.misc.lazy_attribute import lazy_attribute
+from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
+from combinat import catalan_number
+from sage.combinat.composition import Compositions
+from sage.combinat.cartesian_product import CartesianProduct
+#################################################################
+# Enumerated set of binary trees of a given size
+#################################################################
+class OrderedTrees_size(OrderedTrees):
+    """
+    The enumerated sets of binary trees of a given size
+
+    EXAMPLES::
+
+        sage: S = OrderedTrees(3); S
+        Ordered trees of size 3
+        sage: S.cardinality()
+        2
+        sage: S.list()
+        [[[], []], [[[]]]]
+    """
+    def __init__(self, size):
+        """
+        TESTS::
+
+            sage: from sage.combinat.ordered_tree import OrderedTrees_size
+            sage: TestSuite(OrderedTrees_size(0)).run()
+            sage: for i in range(6): TestSuite(OrderedTrees_size(i)).run()
+        """
+        super(OrderedTrees_size, self).__init__(category = FiniteEnumeratedSets())
+        self._size = size
+
+    def _repr_(self):
+        """
+        TESTS::
+
+            sage: OrderedTrees(3)   # indirect doctest
+            Ordered trees of size 3
+        """
+        return "Ordered trees of size %s"%(self._size)
+
+    def __contains__(self, x):
+        """
+        TESTS::
+
+            sage: T = OrderedTrees(3)
+            sage: 1 in T
+            False
+            sage: T([[],[]]) in T
+            True
+        """
+        return isinstance(x, self.element_class) and x.node_number() == self._size
+
+    def _an_element_(self):
+        """
+        TESTS::
+
+            sage: OrderedTrees(3).an_element()   # indirect doctest
+            [[], []]
+        """
+        if self._size == 0:
+            raise EmptySetError
+        return self.first()
+
+    def cardinality(self):
+        """
+        The cardinality of ``self``
+
+        This is a Catalan number
+
+        TESTS::
+
+            sage: OrderedTrees(0).cardinality()
+            0
+            sage: OrderedTrees(1).cardinality()
+            1
+            sage: OrderedTrees(6).cardinality()
+            42
+        """
+        if self._size == 0:
+            return Integer(0)
+        else:
+            return catalan_number(self._size-1)
+
+    def __iter__(self):
+        """
+        A basic generator
+
+        .. todo:: could be optimized.
+
+        TESTS::
+
+            sage: OrderedTrees(0).list()
+            []
+            sage: OrderedTrees(1).list()
+            [[]]
+            sage: OrderedTrees(2).list()
+            [[[]]]
+            sage: OrderedTrees(3).list()
+            [[[], []], [[[]]]]
+            sage: OrderedTrees(4).list()
+            [[[], [], []], [[], [[]]], [[[]], []], [[[], []]], [[[[]]]]]
+        """
+        if self._size == 0:
+            return
+        else:
+            for c in Compositions(self._size-1):
+                for lst in CartesianProduct(*(map(self.__class__, c))):
+                    yield self._element_constructor_(lst)
+
+    @lazy_attribute
+    def _parent_for(self):
+        """
+        Return the parent of the element generated by ``self``
+
+        TESTS::
+
+            sage: OrderedTrees(3)._parent_for
+            Ordered trees
+        """
+        return OrderedTrees_all()
+
+    @lazy_attribute
+    def element_class(self):
+        """
+        The class of the element of ``self``
+
+        EXAMPLES::
+
+            sage: from sage.combinat.ordered_tree import OrderedTrees_size, OrderedTrees_all
+            sage: S = OrderedTrees_size(3)
+            sage: S.element_class is OrderedTrees().element_class
+            True
+            sage: S.first().__class__ == OrderedTrees_all().first().__class__
+            True
+        """
+        return self._parent_for.element_class
+
+    def _element_constructor_(self, *args, **keywords):
+        """
+        EXAMPLES::
+
+            sage: S = OrderedTrees(0)
+            sage: S([])   # indirect doctest
+            Traceback (most recent call last):
+            ...
+            ValueError: Wrong number of nodes
+
+            sage: S = OrderedTrees(1)   # indirect doctest
+            sage: S([])
+            []
+        """
+        res = self.element_class(self._parent_for, *args, **keywords)
+        if res.node_number() != self._size:
+            raise ValueError, "Wrong number of nodes"
+        return res
+
+
+class LabelledOrderedTree(AbstractLabelledClonableTree, OrderedTree):
+    """
+    Labelled ordered trees
+
+    A labellel ordered tree is an ordered tree with a label attached at each
+    node
+
+    INPUT:
+
+    - ``children`` -- a list or tuple or more generally any iterable
+                      of trees or object convertible to trees
+    - ``label`` -- any Sage object default to ``None``
+
+    EXAMPLES::
+
+        sage: x = LabelledOrderedTree([], label = 3); x
+        3[]
+        sage: LabelledOrderedTree([x, x, x], label = 2)
+        2[3[], 3[], 3[]]
+        sage: LabelledOrderedTree((x, x, x), label = 2)
+        2[3[], 3[], 3[]]
+        sage: LabelledOrderedTree([[],[[], []]], label = 3)
+        3[None[], None[None[], None[]]]
+    """
+    __metaclass__ = ClasscallMetaclass
+
+    @staticmethod
+    def __classcall_private__(cls, *args, **opts):
+        """
+        Ensure that trees created by the sets and directly are the same and
+        that they are instance of :class:`LabelledOrderedTree`
+
+        TESTS::
+
+            sage: issubclass(LabelledOrderedTrees().element_class, LabelledOrderedTree)
+            True
+            sage: t0 = LabelledOrderedTree([[],[[], []]], label = 3)
+            sage: t0.parent()
+            Labelled ordered trees
+            sage: type(t0)
+            <class 'sage.combinat.ordered_tree.LabelledOrderedTrees_with_category.element_class'>
+        """
+        return cls._auto_parent.element_class(cls._auto_parent, *args, **opts)
+
+    @lazy_class_attribute
+    def _auto_parent(cls):
+        """
+        The automatic parent of the element of this class
+
+        When calling the constructor of an element of this class, one need a
+        parent. This class attribute specifies which parent is used.
+
+        EXAMPLES::
+
+            sage: LabelledOrderedTree._auto_parent
+            Labelled ordered trees
+            sage: LabelledOrderedTree([], label = 3).parent()
+            Labelled ordered trees
+         """
+        return LabelledOrderedTrees()
+
+    _UnLabelled = OrderedTree
+
+
+from sage.rings.infinity import Infinity
+class LabelledOrderedTrees(UniqueRepresentation, Parent):
+    """
+    This is a parent stub to serve as a factory class for trees with various
+    labels constraints
+
+    EXAMPLES::
+
+        sage: LOT = LabelledOrderedTrees(); LOT
+        Labelled ordered trees
+        sage: x = LOT([], label = 3); x
+        3[]
+        sage: x.parent() is LOT
+        True
+        sage: y = LOT([x, x, x], label = 2); y
+        2[3[], 3[], 3[]]
+        sage: y.parent() is LOT
+        True
+    """
+    def __init__(self, category=None):
+        """
+        TESTS::
+
+            sage: TestSuite(LabelledOrderedTrees()).run()
+        """
+        if category is None:
+            category = Sets()
+        Parent.__init__(self, category = category)
+
+    def _repr_(self):
+        """
+        TESTS::
+
+            sage: LabelledOrderedTrees()   # indirect doctest
+            Labelled ordered trees
+        """
+        return "Labelled ordered trees"
+
+    def cardinality(self):
+        """
+        Returns the cardinality of `self`
+
+        EXAMPLE::
+
+            sage: LabelledOrderedTrees().cardinality()
+            +Infinity
+        """
+        return Infinity
+
+    def _an_element_(self):
+        """
+        Returns a labelled tree
+
+        EXAMPLE::
+
+            sage: LabelledOrderedTrees().an_element()   # indirect doctest
+            toto[3[], 42[3[], 3[]], 5[None[]]]
+        """
+        LT = self._element_constructor_
+        t  = LT([], label = 3)
+        t1 = LT([t,t], label = 42)
+        t2  = LT([[]], label = 5)
+        return LT([t,t1,t2], label = "toto")
+
+    def _element_constructor_(self, *args, **keywords):
+        """
+        EXAMPLES::
+
+            sage: T = LabelledOrderedTrees()
+            sage: T([], label=2)     # indirect doctest
+            2[]
+        """
+        return self.element_class(self, *args, **keywords)
+
+    def unlabelled_trees(self):
+        """
+        Returns the set of unlabelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: LabelledOrderedTrees().unlabelled_trees()
+            Ordered trees
+        """
+        return OrderedTrees_all()
+
+    def labelled_trees(self):
+        """
+        Returns the set of labelled trees associated to ``self``
+
+        EXAMPLES::
+
+            sage: LabelledOrderedTrees().labelled_trees()
+            Labelled ordered trees
+            sage: LOT = LabelledOrderedTrees()
+            sage: x = LOT([], label = 3)
+            sage: y = LOT([x, x, x], label = 2)
+            sage: y.canonical_labelling()
+            1[2[], 3[], 4[]]
+        """
+        return self
+
+    Element = LabelledOrderedTree
+
diff --git a/sage/combinat/permutation.py b/sage/combinat/permutation.py
--- a/sage/combinat/permutation.py
+++ b/sage/combinat/permutation.py
@@ -2930,6 +2930,68 @@ class Permutation_class(CombinatorialObj
         """
         return RSK(self)[1]
 
+    def increasing_tree(self, compare=min):
+        """
+        Return the increasing tree associated to ``self``
+
+        EXAMPLES::
+
+            sage: Permutation([1,4,3,2]).increasing_tree()
+            1[., 2[3[4[., .], .], .]]
+            sage: Permutation([4,1,3,2]).increasing_tree()
+            1[4[., .], 2[3[., .], .]]
+
+        By passing the option ``compare=max`` one can have the decreasing
+        tree instead::
+
+            sage: Permutation([2,3,4,1]).increasing_tree(max)
+            4[3[2[., .], .], 1[., .]]
+            sage: Permutation([2,3,1,4]).increasing_tree(max)
+            4[3[2[., .], 1[., .]], .]
+        """
+        from sage.combinat.binary_tree import LabelledBinaryTree as LBT
+        def rec(perm):
+            if len(perm) == 0: return LBT(None)
+            mn = compare(perm)
+            k = perm.index(mn)
+            return LBT([rec(perm[:k]), rec(perm[k+1:])], label = mn)
+        return rec(self)
+
+    def binary_search_tree(self, left_to_right=True):
+        """
+        Return the binary search tree associated to ``self``
+
+        EXAMPLES::
+
+            sage: Permutation([1,4,3,2]).binary_search_tree()
+            1[., 4[3[2[., .], .], .]]
+            sage: Permutation([4,1,3,2]).binary_search_tree()
+            4[1[., 3[2[., .], .]], .]
+
+        By passing the option ``compare=max`` one can have the decreasing
+        tree instead::
+
+            sage: Permutation([1,4,3,2]).binary_search_tree(False)
+            2[1[., .], 3[., 4[., .]]]
+            sage: Permutation([4,1,3,2]).binary_search_tree(False)
+            2[1[., .], 3[., 4[., .]]]
+
+        TESTS::
+
+            sage: Permutation([]).binary_search_tree()
+            .
+        """
+        from sage.combinat.binary_tree import LabelledBinaryTree as LBT
+        res = LBT(None)
+        if left_to_right:
+            gen = self
+        else:
+            gen = self[::-1]
+        for i in gen:
+            res = res.binary_search_insert(i)
+        return res
+
+
     @combinatorial_map(name='Robinson-Schensted tableau shape')
     def RS_partition(self):
         """
diff --git a/sage/misc/all.py b/sage/misc/all.py
--- a/sage/misc/all.py
+++ b/sage/misc/all.py
@@ -160,8 +160,6 @@ from lazy_import import lazy_import
 
 from abstract_method import abstract_method
 
-from binary_tree import BinaryTree
-
 from randstate import seed, set_random_seed, initial_seed, current_randstate
 
 from prandom import *
diff --git a/sage/misc/binary_tree.pyx b/sage/misc/binary_tree.pyx
--- a/sage/misc/binary_tree.pyx
+++ b/sage/misc/binary_tree.pyx
@@ -197,6 +197,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.insert(1)
             sage: t.insert(0)
@@ -220,6 +221,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.insert(3,3)
             sage: t.insert(1,1)
@@ -261,6 +263,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.insert(0,Matrix([[0,0],[1,1]]))
             sage: t.insert(0,1)
@@ -279,6 +282,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.contains(1)
             False
@@ -322,6 +326,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.insert(4,'e')
             sage: t.insert(2,'c')
@@ -361,6 +366,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.insert(4,'e')
             sage: t.insert(2,'c')
@@ -399,6 +405,7 @@ cdef class BinaryTree:
 
         EXAMPLES::
 
+            sage: from sage.misc.binary_tree import BinaryTree
             sage: t = BinaryTree()
             sage: t.is_empty()
             True
diff --git a/sage/structure/list_clone.pyx b/sage/structure/list_clone.pyx
--- a/sage/structure/list_clone.pyx
+++ b/sage/structure/list_clone.pyx
@@ -146,10 +146,9 @@ cdef class ClonableElement(Element):
     """
     Abstract class for elements with clone protocol
 
-    This class is a subclasse of
-    :class:`Element<sage.structure.element.Element>` and implements the
-    "prototype" design pattern (see [Pro]_, [GOF]_). The role of this class
-    is:
+    This class is a subclass of :class:`Element<sage.structure.element.Element>`
+    and implements the "prototype" design pattern (see [Pro]_, [GOF]_). The role
+    of this class is:
 
     - to manage copy and mutability and hashing of elements
     - to ensure that at the end of a piece of code an object is restored in a
