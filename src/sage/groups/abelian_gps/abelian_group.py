r"""
Multiplicative Abelian Groups

This module lets you compute with finitely generated Abelian groups of the form

.. MATH::

    G = \ZZ^r \oplus \ZZ_{k_1} \oplus \cdots \oplus \ZZ_{k_t}

It is customary to denote the infinite cyclic group `\ZZ` as having
order `0`, so the data defining the Abelian group can be written as an
integer vector

.. MATH::

    \vec{k} = (0, \dots, 0, k_1, \dots, k_t)

where there are `r` zeroes and `t` non-zero values. To construct this
Abelian group in Sage, you can either specify all entries of `\vec{k}`
or only the non-zero entries together with the total number of
generators::

    sage: AbelianGroup([0,0,0,2,3])
    Multiplicative Abelian group isomorphic to Z x Z x Z x C2 x C3
    sage: AbelianGroup(5, [2,3])
    Multiplicative Abelian group isomorphic to Z x Z x Z x C2 x C3

It is also legal to specify `1` as the order. The corresponding
generator will be the neutral element, but it will still take up an
index in the labelling of the generators::

    sage: G = AbelianGroup([2,1,3], names='g')
    sage: G.gens()
    (g0, 1, g2)

Note that this presentation is not unique, for example
`\ZZ_6 \cong \ZZ_2 \times \ZZ_3`. The orders of the generators
`\vec{k}=(0,\dots,0,k_1,\dots, k_t)` has previously been called
invariants in Sage, even though they are not necessarily the (unique)
invariant factors of the group. You should now use
:meth:`~AbelianGroup_class.gens_orders` instead::

   sage: J = AbelianGroup([2,0,3,2,4]);  J
   Multiplicative Abelian group isomorphic to C2 x Z x C3 x C2 x C4
   sage: J.gens_orders()            # use this instead
   (2, 0, 3, 2, 4)
   sage: J.invariants()             # deprecated
   (2, 0, 3, 2, 4)
   sage: J.elementary_divisors()    # these are the "invariant factors"
   (2, 2, 12, 0)
   sage: for i in range(J.ngens()):
   ....:     print((i, J.gen(i), J.gen(i).order()))     # or use this form
   (0, f0, 2)
   (1, f1, +Infinity)
   (2, f2, 3)
   (3, f3, 2)
   (4, f4, 4)

Background on invariant factors and the Smith normal form
(according to section 4.1 of [Cohen1]_): An abelian group is a
group `A` for which there exists an exact sequence
`\ZZ^k \rightarrow \ZZ^\ell \rightarrow A \rightarrow 1`,
for some positive integers
`k,\ell` with `k\leq \ell`. For example, a finite abelian group has a
decomposition

.. MATH::

    A = \langle a_1\rangle \times \dots \times  \langle a_\ell\rangle ,

where `\mathrm{ord}(a_i)=p_i^{c_i}`, for some primes `p_i` and some
positive integers `c_i`, `i=1,...,\ell`. GAP calls the
list (ordered by size) of the `p_i^{c_i}` the *abelian invariants*.
In Sage they will be called *invariants*.
In this situation, `k=\ell` and `\phi:  \ZZ^\ell \rightarrow A` is the map
`\phi(x_1,...,x_\ell) = a_1^{x_1}...a_\ell^{x_\ell}`,
for `(x_1,...,x_\ell)\in \ZZ^\ell`. The matrix of relations
`M:\ZZ^k \rightarrow \ZZ^\ell` is the matrix
whose rows generate the kernel of `\phi` as a `\ZZ`-module.
In other words, `M=(M_{ij})` is a `\ell\times \ell`
diagonal matrix with `M_{ii}=p_i^{c_i}`. Consider now the
subgroup `B\subset A` generated by
`b_1 = a_1^{f_{1,1}}...a_\ell^{f_{\ell,1}}`, ...,
`b_m = a_1^{f_{1,m}}...a_\ell^{f_{\ell,m}}`.
The kernel of the map `\phi_B:  \ZZ^m \rightarrow B` defined by
`\phi_B(y_1,...,y_m) = b_1^{y_1}...b_m^{y_m}`,
for `(y_1,...,y_m)\in \ZZ^m`, is the kernel of the matrix

.. MATH::

    F=
    \left(
    \begin{array}{cccc}
    f_{11} & f_{12} & \dots & f_{1m}\\
    f_{21} & f_{22} & \dots & f_{2m}\\
    \vdots &        & \ddots & \vdots \\
    f_{\ell,1} & f_{\ell,2} & \dots & f_{\ell,m}
    \end{array}
    \right),

regarded as a map
`\ZZ^m\rightarrow (\ZZ/p_1^{c_1}\ZZ)\times ...\times (\ZZ/p_\ell^{c_\ell}\ZZ)`.
In particular, `B\cong \ZZ^m/\ker(F)`. If `B=A` then the
Smith normal form (SNF) of a generator matrix of
`\ker(F)` and the SNF of `M` are the same. The diagonal entries `s_i` of the
SNF `S = \mathrm{diag}[s_1,s_2,s_3, ... s_r,0,0,...0]`,
are called *determinantal divisors* of `F`.
where `r` is the rank. The *invariant factors* of `A` are:

.. MATH::

    s_1, s_2/s_1, s_3/s_2, ... s_r/s_{r-1}.

Sage supports multiplicative abelian groups on any prescribed finite
number `n \geq 0` of generators.  Use the :func:`AbelianGroup`
function to create an abelian group, and the
:meth:`~AbelianGroup_class.gen` and :meth:`~AbelianGroup_class.gens`
methods to obtain the corresponding generators.  You can print the
generators as arbitrary strings using the optional ``names`` argument
to the :func:`AbelianGroup` function.

EXAMPLE 1:

We create an abelian group in zero or more variables; the syntax ``T(1)``
creates the identity element even in the rank zero case::

    sage: T = AbelianGroup(0, [])
    sage: T
    Trivial Abelian group
    sage: T.gens()
    ()
    sage: T(1)
    1

EXAMPLE 2:

An Abelian group uses a multiplicative representation of elements, but
the underlying representation is lists of integer exponents::

    sage: F = AbelianGroup(5, [3,4,5,5,7], names = list("abcde"))
    sage: F
    Multiplicative Abelian group isomorphic to C3 x C4 x C5 x C5 x C7
    sage: (a,b,c,d,e) = F.gens()
    sage: a*b^2*e*d
    a*b^2*d*e
    sage: x = b^2*e*d*a^7
    sage: x
    a*b^2*d*e
    sage: x.list()
    [1, 2, 0, 1, 1]

REFERENCES:

.. [Cohen1] \H. Cohen, Advanced topics in computational number theory,
  Springer, 2000.

.. [Cohen2] \H. Cohen, A course in computational algebraic number theory,
  Springer, 1996.

.. [Rotman] \J. Rotman, An introduction to the theory of
  groups, 4th ed, Springer, 1995.

.. warning::

   Many basic properties for infinite abelian groups are not
   implemented.

AUTHORS:

- William Stein, David Joyner (2008-12): added (user requested) is_cyclic,
  fixed elementary_divisors.

- David Joyner (2006-03): (based on free abelian monoids by David
  Kohel)

- David Joyner (2006-05) several significant bug fixes

- David Joyner (2006-08) trivial changes to docs, added random, fixed
  bug in how invariants are recorded

- David Joyner (2006-10) added dual_group method

- David Joyner (2008-02) fixed serious bug in word_problem

- David Joyner (2008-03) fixed bug in trivial group case

- David Loeffler (2009-05) added subgroups method

- Volker Braun (2012-11) port to new Parent base. Use tuples for
  immutables. Rename invariants to gens_orders.
"""

# ****************************************************************************
#       Copyright (C) 2006 William Stein <wstein@gmail.com>
#       Copyright (C) 2006 David Joyner <wdjoyner@gmail.com>
#       Copyright (C) 2012 Volker Braun <vbraun.name@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.rings.integer import Integer
from sage.rings.integer_ring import ZZ
from sage.structure.category_object import normalize_names
from sage.structure.unique_representation import UniqueRepresentation
from sage.rings.infinity import infinity
from sage.arith.all import divisors, gcd, lcm
from sage.groups.abelian_gps.abelian_group_element import AbelianGroupElement
from sage.misc.cachefunc import cached_method
from sage.misc.misc_c import prod
from sage.misc.mrange import mrange, cartesian_product_iterator
from sage.groups.group import AbelianGroup as AbelianGroupBase
from sage.categories.groups import Groups
from sage.matrix.constructor import matrix
from sage.matrix.special import diagonal_matrix
from sage.modules.free_module_element import vector


# TODO: this uses perm groups - the AbelianGroupElement instance method
# uses a different implementation.
def word_problem(words, g, verbose=False):
    r"""
    G and H are abelian, g in G, H is a subgroup of G generated by a
    list (words) of elements of G. If g is in H, return the expression
    for g as a word in the elements of (words).

    The 'word problem' for a finite abelian group G boils down to the
    following matrix-vector analog of the Chinese remainder theorem.

    Problem: Fix integers `1<n_1\leq n_2\leq ...\leq n_k`
    (indeed, these `n_i` will all be prime powers), fix a
    generating set `g_i=(a_{i1},...,a_{ik})` (with
    `a_{ij}\in \mathrm{Z}/n_j\mathrm{Z}`), for `1\leq i\leq \ell`,
    for the group `G`, and let `d = (d_1,...,d_k)` be
    an element of the direct product
    `\mathrm{Z}/n_1\mathrm{Z} \times ...\times \mathrm{Z}/n_k\mathrm{Z}`. Find, if they
    exist, integers `c_1,...,c_\ell` such that
    `c_1g_1+...+c_\ell g_\ell = d`. In other words, solve
    the equation `cA=d` for `c\in \mathrm{Z}^\ell`, where
    `A` is the matrix whose rows are the `g_i`'s. Of
    course, it suffices to restrict the `c_i`'s to the range
    `0\leq c_i\leq N-1`, where `N` denotes the least
    common multiple of the integers `n_1,...,n_k`.

    This function does not solve this directly, as perhaps it should.
    Rather (for both speed and as a model for a similar function valid
    for more general groups), it pushes it over to GAP, which has optimized
    (non-deterministic) algorithms for the word problem. Essentially,
    this function is a wrapper for the GAP function 'Factorization'.

    EXAMPLES::

        sage: G.<a,b,c> = AbelianGroup(3,[2,3,4]); G
        Multiplicative Abelian group isomorphic to C2 x C3 x C4
        sage: w = word_problem([a*b,a*c], b*c); w #random
        [[a*b, 1], [a*c, 1]]
        sage: prod([x^i for x,i in w]) == b*c
        True
        sage: w = word_problem([a*c,c],a); w #random
        [[a*c, 1], [c, -1]]
        sage: prod([x^i for x,i in w]) == a
        True
        sage: word_problem([a*c,c],a,verbose=True) #random
        a = (a*c)^1*(c)^-1
        [[a*c, 1], [c, -1]]

    ::

        sage: A.<a,b,c,d,e> = AbelianGroup(5,[4, 5, 5, 7, 8])
        sage: b1 = a^3*b*c*d^2*e^5
        sage: b2 = a^2*b*c^2*d^3*e^3
        sage: b3 = a^7*b^3*c^5*d^4*e^4
        sage: b4 = a^3*b^2*c^2*d^3*e^5
        sage: b5 = a^2*b^4*c^2*d^4*e^5
        sage: w = word_problem([b1,b2,b3,b4,b5],e); w #random
        [[a^3*b*c*d^2*e^5, 1], [a^2*b*c^2*d^3*e^3, 1], [a^3*b^3*d^4*e^4, 3], [a^2*b^4*c^2*d^4*e^5, 1]]
        sage: prod([x^i for x,i in w]) == e
        True
        sage: word_problem([a,b,c,d,e],e)
        [[e, 1]]
        sage: word_problem([a,b,c,d,e],b)
        [[b, 1]]

    .. warning::

       1. Might have unpleasant effect when the word problem
          cannot be solved.

       2. Uses permutation groups, so may be slow when group is large.
          The instance method word_problem of the class
          AbelianGroupElement is implemented differently (wrapping
          GAP's 'EpimorphismFromFreeGroup' and
          'PreImagesRepresentative') and may be faster.
    """
    from sage.libs.gap.libgap import libgap
    A = libgap.AbelianGroup(g.parent().gens_orders())
    gens = libgap.GeneratorsOfGroup(A)

    gap_g = libgap.Product([gi**Li for gi, Li in zip(gens, g.list())])

    gensH = [libgap.Product([gi**Li for gi, Li in zip(gens, w.list())])
             for w in words]
    H = libgap.Group(gensH)

    x = libgap.Factorization(H, gap_g)

    resu = libgap.ExtRepOfObj(x).sage()  # (indice, power, indice, power, etc)
    indices = resu[0::2]
    powers = resu[1::2]
    if verbose:
        v = '*'.join('(%s)^%s' % (words[indi - 1], powi)
                     for indi, powi in zip(indices, powers))
        print('%s = %s' % (g, v))
    return [[words[indi - 1], powi] for indi, powi in zip(indices, powers)]


def _normalize(n, gens_orders=None, names="f"):
    """
    Helper function for :func:`AbelianGroup`. Beat some sense into the
    arguments.

    This function is also used by some descendents of
    :class:`AbelianGroup_class`.

    INPUT:

    See :func:`AbelianGroup`

    OUTPUT:

    Unique data for defining a :class:`AbelianGroup_class`. Raises an
    exception if the input is invalid.

    EXAMPLES::

        sage: from sage.groups.abelian_gps.abelian_group import _normalize
        sage: _normalize(5, [2,1,0], names='abc')
        ((0, 0, 2, 1, 0), 'abc')
        sage: _normalize(5, (2.0, 1.0, 0/1), names=list('abc'))
        ((0, 0, 2, 1, 0), ('a', 'b', 'c'))
        sage: _normalize([0,2,1,0], names='a')
        ((0, 2, 1, 0), 'a')

    TESTS::

        sage: _normalize(5, (2.0, 1.5, 0/1), names=list('abc'))
        Traceback (most recent call last):
        ...
        TypeError: Attempt to coerce non-integral RealNumber to Integer
        sage: _normalize('1', '[2]', names='a')
        Traceback (most recent call last):
        ...
        TypeError: unable to convert '[' to an integer
        sage: _normalize(3, 'str', names='a')
        Traceback (most recent call last):
        ...
        TypeError: unable to convert 's' to an integer
   """
    if gens_orders is None:
        if isinstance(n, (list, tuple)):
            gens_orders = n
            n = len(n)
        else:
            gens_orders = []
    n = ZZ(n)
    if len(gens_orders) < n:
        gens_orders = [0] * (n - len(gens_orders)) + list(gens_orders)
    gens_orders = tuple(ZZ(i) for i in gens_orders)
    if len(gens_orders) > n:
        raise ValueError('gens_orders (='+str(gens_orders)+') must have length n (='+str(n)+')')
    if isinstance(names, list):
        names = tuple(names)
    return (gens_orders, names)

def AbelianGroup(n, gens_orders=None, names="f"):
    r"""
    Create the multiplicative abelian group in `n` generators
    with given orders of generators (which need not be prime powers).

    INPUT:

    - ``n`` -- integer (optional). If not specified, will be derived
       from ``gens_orders``.

    - ``gens_orders`` -- a list of non-negative integers in the form
       `[a_0, a_1, \dots, a_{n-1}]`, typically written in increasing
       order. This list is padded with zeros if it has length less
       than `n`. The orders of the commuting generators, with `0`
       denoting an infinite cyclic factor.

    -  ``names`` -- (optional) names of generators

    Alternatively, you can also give input in the form
    ``AbelianGroup(gens_orders, names="f")``, where the names keyword
    argument must be explicitly named.

    OUTPUT:

    Abelian group with generators and invariant type. The default name
    for generator ``A.i`` is ``fi``, as in GAP.

    EXAMPLES::

        sage: F = AbelianGroup(5, [5,5,7,8,9], names='abcde')
        sage: F(1)
        1
        sage: (a, b, c, d, e) = F.gens()
        sage: mul([ a, b, a, c, b, d, c, d ], F(1))
        a^2*b^2*c^2*d^2
        sage: d * b**2 * c**3
        b^2*c^3*d
        sage: F = AbelianGroup(3,[2]*3); F
        Multiplicative Abelian group isomorphic to C2 x C2 x C2
        sage: H = AbelianGroup([2,3], names="xy"); H
        Multiplicative Abelian group isomorphic to C2 x C3
        sage: AbelianGroup(5)
        Multiplicative Abelian group isomorphic to Z x Z x Z x Z x Z
        sage: AbelianGroup(5).order()
        +Infinity

    Notice that `0`'s are prepended if necessary::

        sage: G = AbelianGroup(5, [2,3,4]);  G
        Multiplicative Abelian group isomorphic to Z x Z x C2 x C3 x C4
        sage: G.gens_orders()
        (0, 0, 2, 3, 4)

    The invariant list must not be longer than the number of generators::

        sage: AbelianGroup(2, [2,3,4])
        Traceback (most recent call last):
        ...
        ValueError: gens_orders (=(2, 3, 4)) must have length n (=2)
    """
    gens_orders, names = _normalize(n, gens_orders, names)
    M = AbelianGroup_class(gens_orders, names)
    return M

def is_AbelianGroup(x):
    """
    Return True if ``x`` is an Abelian group.

    EXAMPLES::

        sage: from sage.groups.abelian_gps.abelian_group import is_AbelianGroup
        sage: F = AbelianGroup(5,[5,5,7,8,9],names = list("abcde")); F
        Multiplicative Abelian group isomorphic to C5 x C5 x C7 x C8 x C9
        sage: is_AbelianGroup(F)
        True
        sage: is_AbelianGroup(AbelianGroup(7, [3]*7))
        True
    """
    return isinstance(x, AbelianGroup_class)


class AbelianGroup_class(UniqueRepresentation, AbelianGroupBase):
    """
    The parent for Abelian groups with chosen generator orders.

    .. warning::

        You should use :func:`AbelianGroup` to construct Abelian
        groups and not instantiate this class directly.

    INPUT:

    - ``generator_orders`` -- list of integers. The orders of the
      (commuting) generators. Zero denotes an infinite cyclic
      generator.

    - ``names`` -- names of the group generators (optional).

    EXAMPLES::

        sage: Z2xZ3 = AbelianGroup([2,3])
        sage: Z6 = AbelianGroup([6])
        sage: Z2xZ3 is Z2xZ3, Z6 is Z6
        (True, True)
        sage: Z2xZ3 is Z6
        False
        sage: Z2xZ3 == Z6
        False
        sage: Z2xZ3.is_isomorphic(Z6)
        True

        sage: F = AbelianGroup(5,[5,5,7,8,9],names = list("abcde")); F
        Multiplicative Abelian group isomorphic to C5 x C5 x C7 x C8 x C9
        sage: F = AbelianGroup(5,[2, 4, 12, 24, 120],names = list("abcde")); F
        Multiplicative Abelian group isomorphic to C2 x C4 x C12 x C24 x C120
        sage: F.elementary_divisors()
        (2, 4, 12, 24, 120)

        sage: F.category()
        Category of finite enumerated commutative groups

    TESTS::

        sage: AbelianGroup([]).gens_orders()
        ()
        sage: AbelianGroup([1]).gens_orders()
        (1,)
        sage: AbelianGroup([1,1]).gens_orders()
        (1, 1)
        sage: AbelianGroup(0).gens_orders()
        ()
    """
    Element = AbelianGroupElement

    def __init__(self, generator_orders, names, category=None):
        """
        The Python constructor

        TESTS::

            sage: G = AbelianGroup([0,5,0,7],names = list("abcd")); G
            Multiplicative Abelian group isomorphic to Z x C5 x Z x C7
            sage: TestSuite(G).run()

        We check that :trac:`15140` is fixed::

            sage: A = AbelianGroup([3,3])
            sage: A.category()
            Category of finite enumerated commutative groups
            sage: A = AbelianGroup([3,0,7])
            sage: A.category()
            Category of infinite commutative groups
        """
        assert isinstance(names, (str, tuple))
        assert isinstance(generator_orders, tuple)
        assert all(isinstance(order,Integer) for order in generator_orders)
        self._gens_orders = generator_orders
        n = len(generator_orders)
        names = normalize_names(n, names)
        self._assign_names(names)
        if category is None:
            category = Groups().Commutative()
        if all(order > 0 for order in generator_orders):
            category = category.Finite().Enumerated()
        else:
            category = category.Infinite()
        AbelianGroupBase.__init__(self, category=category)

    def is_isomorphic(left, right):
        """
        Check whether ``left`` and ``right`` are isomorphic

        INPUT:

        - ``right`` -- anything.

        OUTPUT:

        Boolean. Whether ``left`` and ``right`` are isomorphic as abelian groups.

        EXAMPLES::

            sage: G1 = AbelianGroup([2,3,4,5])
            sage: G2 = AbelianGroup([2,3,4,5,1])
            sage: G1.is_isomorphic(G2)
            True
        """
        if not is_AbelianGroup(right):
            return False
        return left.elementary_divisors() == right.elementary_divisors()

    def is_subgroup(left, right):
        """
        Test whether ``left`` is a subgroup of ``right``.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,4,5])
            sage: G.is_subgroup(G)
            True

            sage: H = G.subgroup([G.1])
            sage: H.is_subgroup(G)
            True

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: H < G
            False
       """
        for l in left.gens():
            if l not in right:
                return False
        return True

    __le__ = is_subgroup

    def __ge__(left, right):
        """
        Test whether ``right`` is a subgroup of ``left``

        EXAMPLES::

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: G >= H
            False
        """
        return right <= left

    def __lt__(left, right):
        """
        Test whether ``left`` is a strict subgroup of ``right``

        EXAMPLES::

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: H < G
            False
        """
        return left <= right and left != right

    def __gt__(left, right):
        """
        Test whether ``right`` is a strict subgroup of ``left``

        EXAMPLES::

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: G > H
            False
        """
        return left >= right and left != right

    def is_trivial(self):
        """
        Return whether the group is trivial

        A group is trivial if it has precisely one element.

        EXAMPLES::

            sage: AbelianGroup([2, 3]).is_trivial()
            False
            sage: AbelianGroup([1, 1]).is_trivial()
            True
        """
        return self.elementary_divisors() == ()

    def __bool__(self):
        """
        Returns True if this group is nontrivial.

        EXAMPLES::

            sage: T = AbelianGroup([2, 3])
            sage: bool(T) # indirect doctest
            True
            sage: bool(AbelianGroup([]))
            False
            sage: bool(AbelianGroup([1,1,1]))
            False
        """
        return not self.is_trivial()

    __nonzero__ = __bool__

    @cached_method
    def dual_group(self, names="X", base_ring=None):
        """
        Return the dual group.

        INPUT:

        - ``names`` -- string or list of strings. The generator names
          for the dual group.

        - ``base_ring`` -- the base ring. If ``None`` (default), then
          a suitable cyclotomic field is picked automatically.

        OUTPUT:

        The :class:`dual abelian group <sage.groups.abelian_gps.dual_abelian_group.DualAbelianGroup_class>`.

        EXAMPLES::

            sage: G = AbelianGroup([2])
            sage: G.dual_group()
            Dual of Abelian Group isomorphic to Z/2Z over Cyclotomic Field of order 2 and degree 1
            sage: G.dual_group().gens()
            (X,)
            sage: G.dual_group(names='Z').gens()
            (Z,)

            sage: G.dual_group(base_ring=QQ)
            Dual of Abelian Group isomorphic to Z/2Z over Rational Field


        TESTS::

            sage: H = AbelianGroup(1)
            sage: H.dual_group()
            Traceback (most recent call last):
            ...
            ValueError: group must be finite
        """
        from sage.groups.abelian_gps.dual_abelian_group import DualAbelianGroup_class
        if not self.is_finite():
            raise ValueError('group must be finite')
        if base_ring is None:
            from sage.rings.number_field.number_field import CyclotomicField
            base_ring = CyclotomicField(lcm(self.gens_orders()))
        return DualAbelianGroup_class(self, names=names, base_ring=base_ring)

    @cached_method
    def elementary_divisors(self):
        r"""
        This returns the elementary divisors of the group, using Pari.

        .. note::

            Here is another algorithm for computing the elementary divisors
            `d_1, d_2, d_3, \ldots`, of a finite abelian group (where `d_1 | d_2 | d_3 | \ldots`
            are composed of prime powers dividing the invariants of the group
            in a way described below). Just factor the invariants `a_i` that
            define the abelian group.  Then the biggest `d_i` is the product
            of the maximum prime powers dividing some `a_j`. In other words, the
            largest `d_i` is the product of `p^v`, where
            `v = \max(\mathrm{ord}_p(a_j) \text{ for all } j`).
            Now divide out all those `p^v`'s into the list of invariants `a_i`,
            and get a new list of "smaller invariants". Repeat the above procedure
            on these "smaller invariants" to compute `d_{i-1}`, and so on.
            (Thanks to Robert Miller for communicating this algorithm.)

        OUTPUT:

        A tuple of integers.

        EXAMPLES::

            sage: G = AbelianGroup(2,[2,3])
            sage: G.elementary_divisors()
            (6,)
            sage: G = AbelianGroup(1, [6])
            sage: G.elementary_divisors()
            (6,)
            sage: G = AbelianGroup(2,[2,6])
            sage: G
            Multiplicative Abelian group isomorphic to C2 x C6
            sage: G.gens_orders()
            (2, 6)
            sage: G.elementary_divisors()
            (2, 6)
            sage: J = AbelianGroup([1,3,5,12])
            sage: J.elementary_divisors()
            (3, 60)
            sage: G = AbelianGroup(2,[0,6])
            sage: G.elementary_divisors()
            (6, 0)
            sage: AbelianGroup([3,4,5]).elementary_divisors()
            (60,)
        """
        from sage.matrix.constructor import diagonal_matrix
        ed = diagonal_matrix(ZZ, self.gens_orders()).elementary_divisors()
        return tuple(d for d in ed if d!=1)

    @cached_method
    def exponent(self):
        """
        Return the exponent of this abelian group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,7]); G
            Multiplicative Abelian group isomorphic to C2 x C3 x C7
            sage: G.exponent()
            42
            sage: G = AbelianGroup([2,4,6]); G
            Multiplicative Abelian group isomorphic to C2 x C4 x C6
            sage: G.exponent()
            12
        """
        return lcm(self.gens_orders())

    def identity(self):
        r"""
        Return the identity element of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,2])
            sage: e = G.identity()
            sage: e
            1
            sage: g = G.gen(0)
            sage: g*e
            f0
            sage: e*g
            f0
        """
        return self(1)

    def _group_notation(self, eldv):
        """
        Return abstract group notation for generator orders ``eldv``

        INPUT:

        - ``eldv`` -- iterable of integers.

        OUTPUT:

        String.

        EXAMPLES::

            sage: G = AbelianGroup([2,2])
            sage: G._group_notation([0,1,2,3])
            'Z x C1 x C2 x C3'
        """
        v = []
        for x in eldv:
            if x:
                v.append("C%s"%x)
            else:
                v.append("Z")
        return ' x '.join(v)

    def _latex_(self):
        r"""
        Return latex representation of this group.

        EXAMPLES::

            sage: F = AbelianGroup(10, [2]*10)
            sage: F._latex_()
            '$\\mathrm{AbelianGroup}( 10, (2, 2, 2, 2, 2, 2, 2, 2, 2, 2) )$'
        """
        return r"$\mathrm{AbelianGroup}( %s, %s )$" % (self.ngens(),
                                                       self.gens_orders())

    @cached_method
    def _libgap_(self):
        r"""
        Return a GAP group corresponding to this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9])
            sage: libgap(G)
            <pc group of size 54 with 3 generators>

        The result is cached::

            sage: libgap(G) is libgap(G)
            True

        Requires the optional ``gap_packages`` for infinite groups::

            sage: G = AbelianGroup(3, [0,3,4], names="abc")
            sage: libgap(G)   # optional - gap_packages
            Pcp-group with orders [ 0, 3, 4 ]
        """
        from sage.libs.gap.libgap import libgap

        if self.is_finite():
            return libgap.AbelianGroup(self.gens_orders())

        # Make sure to LoadPackage("Polycyclic") in gap
        from sage.features.gap import GapPackage
        GapPackage("polycyclic", spkg="gap_packages").require()
        return libgap.AbelianPcpGroup(self.gens_orders())

    def _gap_init_(self):
        r"""
        Return string that defines corresponding abelian group in GAP.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9])
            sage: G._gap_init_()
            'AbelianGroup([2, 3, 9])'
            sage: gap(G)
            Group( [ f1, f2, f3 ] )

        Requires the optional ``gap_packages`` for infinite groups::

            sage: G = AbelianGroup(3,[0,3,4], names="abc"); G
            Multiplicative Abelian group isomorphic to Z x C3 x C4
            sage: G._gap_init_()   # optional - gap_packages
            'AbelianPcpGroup([0, 3, 4])'
        """
        if self.is_finite():
            return 'AbelianGroup(%s)'%list(self.gens_orders())

        from sage.features.gap import GapPackage
        # Make sure to LoadPackage("Polycyclic") in gap
        GapPackage("polycyclic", spkg="gap_packages").require()
        return 'AbelianPcpGroup(%s)'%list(self.gens_orders())

    def gen(self, i=0):
        """
        The `i`-th generator of the abelian group.

        EXAMPLES::

            sage: F = AbelianGroup(5,[],names='a')
            sage: F.0
            a0
            sage: F.2
            a2
            sage: F.gens_orders()
            (0, 0, 0, 0, 0)

            sage: G = AbelianGroup([2,1,3])
            sage: G.gens()
            (f0, 1, f2)
        """
        n = self.ngens()
        if i < 0 or i >= n:
            raise IndexError("Argument i (= %s) must be between 0 and %s."%(i, n-1))
        x = [0]*n
        if self._gens_orders[i] != 1:
            x[i] = 1
        return self.element_class(self, x)

    def gens(self):
        """
        Return the generators of the group.

        OUTPUT:

        A tuple of group elements. The generators according to the
        chosen :meth:`gens_orders`.

        EXAMPLES::

            sage: F = AbelianGroup(5,[3,2],names='abcde')
            sage: F.gens()
            (a, b, c, d, e)
            sage: [ g.order() for g in F.gens() ]
            [+Infinity, +Infinity, +Infinity, 3, 2]
        """
        return tuple( self.gen(i) for i in range(self.ngens()) )

    def gens_orders(self):
        """
        Return the orders of the cyclic factors that this group has
        been defined with.

        Use :meth:`elementary_divisors` if you are looking for an
        invariant of the group.

        OUTPUT:

        A tuple of integers.

        EXAMPLES::

            sage: Z2xZ3 = AbelianGroup([2,3])
            sage: Z2xZ3.gens_orders()
            (2, 3)
            sage: Z2xZ3.elementary_divisors()
            (6,)

            sage: Z6 = AbelianGroup([6])
            sage: Z6.gens_orders()
            (6,)
            sage: Z6.elementary_divisors()
            (6,)

            sage: Z2xZ3.is_isomorphic(Z6)
            True
            sage: Z2xZ3 is Z6
            False

        TESTS::

            sage: F = AbelianGroup(3, [2], names='abc')
            sage: list(map(type, F.gens_orders()))
            [<class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>]
        """
        return self._gens_orders

    def invariants(self):
        """
        Return the orders of the cyclic factors that this group has
        been defined with.

        For historical reasons this has been called invariants in
        Sage, even though they are not necessarily the invariant
        factors of the group. Use :meth:`gens_orders` instead::

            sage: J = AbelianGroup([2,0,3,2,4]);  J
            Multiplicative Abelian group isomorphic to C2 x Z x C3 x C2 x C4
            sage: J.invariants()    # deprecated
            (2, 0, 3, 2, 4)
            sage: J.gens_orders()   # use this instead
            (2, 0, 3, 2, 4)
            sage: for i in range(J.ngens()):
            ....:     print((i, J.gen(i), J.gen(i).order()))     # or this
            (0, f0, 2)
            (1, f1, +Infinity)
            (2, f2, 3)
            (3, f3, 2)
            (4, f4, 4)

        Use :meth:`elementary_divisors` if you are looking for an
        invariant of the group.

        OUTPUT:

        A tuple of integers. Zero means infinite cyclic factor.

        EXAMPLES::

            sage: J = AbelianGroup([2,3])
            sage: J.invariants()
            (2, 3)
            sage: J.elementary_divisors()
            (6,)

        TESTS::

            sage: F = AbelianGroup(3, [2], names='abc')
            sage: list(map(type, F.gens_orders()))
            [<class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>]
        """
        # TODO: deprecate
        return self.gens_orders()

    def is_cyclic(self):
        """
        Return True if the group is a cyclic group.

        EXAMPLES::

            sage: J = AbelianGroup([2,3])
            sage: J.gens_orders()
            (2, 3)
            sage: J.elementary_divisors()
            (6,)
            sage: J.is_cyclic()
            True
            sage: G = AbelianGroup([6])
            sage: G.gens_orders()
            (6,)
            sage: G.is_cyclic()
            True
            sage: H = AbelianGroup([2,2])
            sage: H.gens_orders()
            (2, 2)
            sage: H.is_cyclic()
            False
            sage: H = AbelianGroup([2,4])
            sage: H.elementary_divisors()
            (2, 4)
            sage: H.is_cyclic()
            False
            sage: H.permutation_group().is_cyclic()
            False
            sage: T = AbelianGroup([])
            sage: T.is_cyclic()
            True
            sage: T = AbelianGroup(1,[0]); T
            Multiplicative Abelian group isomorphic to Z
            sage: T.is_cyclic()
            True
            sage: B = AbelianGroup([3,4,5])
            sage: B.is_cyclic()
            True
        """
        return len(self.elementary_divisors()) <= 1

    @cached_method
    def ngens(self):
        """
        The number of free generators of the abelian group.

        EXAMPLES::

            sage: F = AbelianGroup(10000)
            sage: F.ngens()
            10000
        """
        return len(self.gens_orders())

    @cached_method
    def order(self):
        """
        Return the order of this group.

        EXAMPLES::

            sage: G = AbelianGroup(2,[2,3])
            sage: G.order()
            6
            sage: G = AbelianGroup(3,[2,3,0])
            sage: G.order()
            +Infinity
        """
        length = prod(self.gens_orders())
        if length == 0:
            return infinity
        return length

    cardinality = order

    @cached_method
    def permutation_group(self):
        r"""
        Return the permutation group isomorphic to this abelian group.

        If the invariants are `q_1, \ldots, q_n` then the
        generators of the permutation will be of order
        `q_1, \ldots, q_n`, respectively.

        EXAMPLES::

            sage: G = AbelianGroup(2,[2,3]); G
            Multiplicative Abelian group isomorphic to C2 x C3
            sage: G.permutation_group()
            Permutation Group with generators [(3,4,5), (1,2)]

        TESTS:

        Check that :trac:`25692` is fixed::

            sage: G = AbelianGroup([0])
            sage: G.permutation_group()
            Traceback (most recent call last):
            ...
            TypeError: Abelian group must be finite
        """
        # GAP does not support infinite permutation groups
        if not self.is_finite():
            raise TypeError('Abelian group must be finite')
        from sage.groups.perm_gps.permgroup import PermutationGroup
        s = 'Image(IsomorphismPermGroup(%s))'%self._gap_init_()
        return PermutationGroup(gap_group=s)

    def is_commutative(self):
        """
        Return True since this group is commutative.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9, 0])
            sage: G.is_commutative()
            True
            sage: G.is_abelian()
            True
        """
        return True

    def random_element(self):
        """
        Return a random element of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9])
            sage: G.random_element().parent() is G
            True
        """
        from sage.misc.prandom import randint
        result = self.one()
        for g in self.gens():
            order = g.order()
            if order not in ZZ:
                order = 42  # infinite order; randomly chosen maximum
            result *= g**(randint(0,order))
        return result

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9])
            sage: G._repr_()
            'Multiplicative Abelian group isomorphic to C2 x C3 x C9'
       """
        eldv = self.gens_orders()
        if len(eldv) == 0:
            return "Trivial Abelian group"
        g = self._group_notation(eldv)
        return "Multiplicative Abelian group isomorphic to " + g

    def subgroup(self, gensH, names="f"):
        """
         Create a subgroup of this group. The "big" group must be defined
         using "named" generators.

         INPUT:

         - ``gensH`` -- list of elements which are products of the
            generators of the ambient abelian group G = self

         EXAMPLES::

             sage: G.<a,b,c> = AbelianGroup(3, [2,3,4]); G
             Multiplicative Abelian group isomorphic to C2 x C3 x C4
             sage: H = G.subgroup([a*b,a]); H
             Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {a*b, a}
             sage: H < G
             True
             sage: F = G.subgroup([a,b^2])
             sage: F
             Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {a, b^2}
             sage: F.gens()
             (a, b^2)
             sage: F = AbelianGroup(5,[30,64,729],names = list("abcde"))
             sage: a,b,c,d,e = F.gens()
             sage: F.subgroup([a,b])
             Multiplicative Abelian subgroup isomorphic to Z x Z generated by {a, b}
             sage: F.subgroup([c,e])
             Multiplicative Abelian subgroup isomorphic to C2 x C3 x C5 x C729 generated by {c, e}
         """
        G = self
        gensH = tuple(gensH)
        if isinstance(names, list):
            names = tuple(names)
        for h in gensH:
            if h not in G:
                raise TypeError('Subgroup generators must belong to the given group.')
        return self.Subgroup(self, gensH, names)

    def list(self):
        """
        Return tuple of all elements of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3], names = "ab")
            sage: G.list()
            (1, b, b^2, a, a*b, a*b^2)

        ::

            sage: G = AbelianGroup([]); G
            Trivial Abelian group
            sage: G.list()
            (1,)
        """
        if not self.is_finite():
           raise NotImplementedError("group must be finite")
        return tuple(iter(self))

    def __len__(self):
        """
        Return the length of ``self``.

        EXAMPLES::

            sage: G = AbelianGroup(2,[2,3])
            sage: len(G)
            6
            sage: G = AbelianGroup(3,[2,3,0])
            sage: len(G)
            Traceback (most recent call last):
            ...
            NotImplementedError: group must be finite
        """
        length = prod(self.gens_orders())
        if length == 0:
            raise NotImplementedError("group must be finite")
        return int(length)

    def __iter__(self):
        """
        Return an iterator over the elements of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3], names = "ab")
            sage: [a for a in G]
            [1, b, b^2, a, a*b, a*b^2]
            sage: L = list(G); L
            [1, b, b^2, a, a*b, a*b^2]

        The returned list is a reference; mutating it does not allow the
        user to (accidentally?) alter the computed generators::

            sage: L[0] = 0
            sage: list(G)
            [1, b, b^2, a, a*b, a*b^2]
            sage: G = AbelianGroup([1], names="a")
            sage: list(G)
            [1]
            sage: G = AbelianGroup([])
            sage: G.list()
            (1,)
            sage: list(G)
            [1]
        """
        invs = self.gens_orders()
        for t in mrange(invs):
            yield self(t)

    def number_of_subgroups(self, order=None):
        r"""
        Return the number of subgroups of this group, possibly only of a
        specific order.

        INPUT:

        - ``order`` -- (default: ``None``) find the number of subgroups of this
          order; if ``None``, this defaults to counting all subgroups

        ALGORITHM:

        An infinite group has infinitely many subgroups. All finite subgroups of
        any group are contained in the torsion subgroup, which for finitely
        generated abelian group is itself finite. Hence, we can assume the
        group is finite. A finite abelian group is isomorphic to a direct
        product of its Sylow subgroups, and so we can reduce the problem
        further to counting subgroups of finite abelian `p`-groups.

        Assume a Sylow subgroup is a `p`-group of type `\lambda`, and using
        :func:`~sage.combinat.q_analogues.q_subgroups_of_abelian_group`
        sum the number of subgroups of type `\mu` in an abelian `p`-group of
        type `\lambda` for all `\mu` contained in `\lambda`.

        EXAMPLES::

            sage: AbelianGroup([2,3]).number_of_subgroups()
            4
            sage: AbelianGroup([2,0,0,3,0]).number_of_subgroups()
            +Infinity
            sage: AbelianGroup([2,4,8]).number_of_subgroups()
            81
            sage: AbelianGroup([2,4,8]).number_of_subgroups(order=4)
            19
            sage: AbelianGroup([10,15,25,12]).number_of_subgroups()
            5760
            sage: AbelianGroup([10,15,25,12]).number_of_subgroups(order=45000)
            1
            sage: AbelianGroup([10,15,25,12]).number_of_subgroups(order=14)
            0

        TESTS::

            sage: AbelianGroup([]).number_of_subgroups()
            1
            sage: AbelianGroup([1,3,1]).number_of_subgroups()
            2
            sage: AbelianGroup([]).number_of_subgroups(order=2)
            0
            sage: AbelianGroup([1,3,1]).number_of_subgroups(order=2)
            0
            sage: AbelianGroup([1,3,0,1]).number_of_subgroups(order=3)
            1
            sage: AbelianGroup([1,3,1]).number_of_subgroups(order=-2)
            Traceback (most recent call last):
            ...
            ValueError: subgroups order must be positive or None
        """
        if not self.is_finite():
            if order is None:
                return infinity
            else:
                # Finite order subgroups are all contained in the torsion subgroup
                return self.torsion_subgroup().number_of_subgroups(order=order)

        from itertools import chain
        from collections import defaultdict
        from sage.arith.misc import factor
        from sage.combinat.q_analogues import q_subgroups_of_abelian_group
        from sage.combinat.integer_lists import IntegerListsLex

        # The group order is prod(p^e for (p,e) in primary_factors)
        primary_factors = list(chain.from_iterable(
                        factor(ed) for ed in self.elementary_divisors()))
        sylow_types = defaultdict(list)
        for p, e in primary_factors:
            sylow_types[p].append(e)
        subgroups_orders_kwds = dict()

        if order is None:
            for p, p_exps in sylow_types.items():
                subgroups_orders_kwds[p] = dict(max_sum=sum(p_exps))
        else:
            order = Integer(order)
            if order < 1:
                raise ValueError('subgroups order must be positive or None')
            if not order.divides(self.order()):
                return Integer(0)
            order_exps = dict(factor(order))

            for p in (set(sylow_types) - set(order_exps)):
                del sylow_types[p]
            for p in sylow_types:
                subgroups_orders_kwds[p] = dict(n=order_exps[p])

        result = Integer(1)
        for p, p_exps in sylow_types.items():
            p_exps.sort(reverse=True)
            # The sum is over all partitions mu contained in p_exps whose size
            # is determined by subgroups_orders_kwds.
            result *= sum(q_subgroups_of_abelian_group(p_exps, mu, q=p)
                          for mu in IntegerListsLex(max_slope=0,
                                                    min_part=1,
                                                    max_length=len(p_exps),
                                                    ceiling=p_exps,
                                                    element_constructor=list,
                                                    **subgroups_orders_kwds[p]))
        return result

    def subgroups(self, check=False):
        r"""
        Compute all the subgroups of this abelian group (which must be finite).

        INPUT:

        - check: if ``True``, performs the same computation in GAP and
          checks that the number of subgroups generated is the
          same. (I don't know how to convert GAP's output back into
          Sage, so we don't actually compare the subgroups).

        ALGORITHM:

        If the group is cyclic, the problem is easy. Otherwise, write it as
        a direct product A x B, where B is cyclic. Compute the subgroups of
        A (by recursion).

        Now, for every subgroup C of A x B, let G be its *projection onto*
        A and H its *intersection with* B. Then there is a well-defined
        homomorphism f: G -> B/H that sends a in G to the class mod H of b,
        where (a,b) is any element of C lifting a; and every subgroup C
        arises from a unique triple (G, H, f).

        .. TODO::

            This is *many orders of magnitude* slower than Magma.  Consider
            using the much faster method
            :meth:`~AbelianGroup_class.number_of_subgroups` in case you only
            need the number of subgroups, possibly of a specific order.

        EXAMPLES::

            sage: AbelianGroup([2,3]).subgroups()
            [Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {f0*f1^2},
             Multiplicative Abelian subgroup isomorphic to C2 generated by {f0},
             Multiplicative Abelian subgroup isomorphic to C3 generated by {f1},
             Trivial Abelian subgroup]
            sage: len(AbelianGroup([2,4,8]).subgroups())
            81

        TESTS::

            sage: AbelianGroup([]).subgroups()
            [Trivial Abelian group]

        Check that :trac:`14196` is fixed::

            sage: B = AbelianGroup([1,2])
            sage: B.subgroups()
            [Multiplicative Abelian subgroup isomorphic to C2 generated by {f1},
             Trivial Abelian subgroup]
            sage: B.subgroups(check=True)
            [Multiplicative Abelian subgroup isomorphic to C2 generated by {f1},
             Trivial Abelian subgroup]
        """
        if not self.is_finite():
            raise ValueError("group must be finite")
        from sage.misc.verbose import verbose

        if self.is_trivial():
            return [self]
        if self.ngens() == 1:
            n = self.gen(0).order()
            return [self.subgroup([self.gen(0)**i]) for i in divisors(n)]

        v = self.gens_orders()
        A = AbelianGroup(v[:-1])
        x = v[-1]

        Wsubs = A.subgroups()

        subgps = []
        for G in Wsubs:
            ngens = len(G.gens())
            verbose("G = subgp generated by %s" % list(G.gens()))
            verbose("invariants are: %s" % [t.order() for t in G.gens()])
            for H in divisors(x):
                # H = the subgroup of *index* H.
                its = [range(0, H, H // gcd(H, G.gen(i).order()))
                       for i in range(ngens)]
                for f in cartesian_product_iterator(its):
                    verbose("using hom from G to C_%s sending gens to %s" % (H, f))
                    new_sub = []
                    for a in range(ngens):
                        val = G.gen(a).list() + [f[a]]
                        if any(l != 0 for l in val):
                            new_sub.append(val)
                    if H != x:
                        new_sub.append([0] * A.ngens() + [H])
                    subgps.append(self.subgroup_reduced(new_sub))

        if check:
            verbose("Running Gap cross-check")
            from sage.libs.gap.libgap import libgap
            t = libgap(v).AbelianGroup().SubgroupsSolvableGroup().Size().sage()
            if t != len(subgps):
                raise ArithmeticError("For %s Gap finds %s subgroups, I found %s" % (v, t, len(subgps)))
            verbose("Gap check OK for %s: %s" % (v, t))
        return subgps

    def subgroup_reduced(self, elts, verbose=False):
        r"""
        Given a list of lists of integers (corresponding to elements of self),
        find a set of independent generators for the subgroup generated by
        these elements, and return the subgroup with these as generators,
        forgetting the original generators.

        This is used by the ``subgroups`` routine.

        An error will be raised if the elements given are not linearly
        independent over QQ.

        EXAMPLES::

            sage: G = AbelianGroup([4,4])
            sage: G.subgroup( [ G([1,0]), G([1,2]) ])
            Multiplicative Abelian subgroup isomorphic to C2 x C4
            generated by {f0, f0*f1^2}
            sage: AbelianGroup([4,4]).subgroup_reduced( [ [1,0], [1,2] ])
            Multiplicative Abelian subgroup isomorphic to C2 x C4
            generated by {f0^2*f1^2, f0^3}
        """
        from sage.matrix.constructor import matrix
        d = self.ngens()
        X = ZZ**d
        try:
            elt_lattice = X.submodule_with_basis(elts)
        except ValueError as e:
            # can't happen?
            print("Vectors not LI: {}".format(elts))
            raise e
        rel_lattice = X.span([X.gen(i) * self.gens_orders()[i] for i in range(d)])
        isect = elt_lattice.intersection(rel_lattice)
        mat = matrix([elt_lattice.coordinate_vector(x) for x in isect.gens()]).change_ring(ZZ)
        D,U,V = mat.smith_form()
        new_basis = [(elt_lattice.linear_combination_of_basis((~V).row(i)).list(), D[i,i]) for i in range(U.ncols())]
        return self.subgroup([self([x[0][i] % self.gens_orders()[i]
                                    for i in range(d)]) for x in new_basis if x[1] != 1])

    def torsion_subgroup(self):
        """
        Return the torsion subgroup of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2, 3])
            sage: G.torsion_subgroup()
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated
            by {f0, f1}
            sage: G = AbelianGroup([2, 0, 0, 3, 0])
            sage: G.torsion_subgroup()
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated
            by {f0, f3}
            sage: G = AbelianGroup([])
            sage: G.torsion_subgroup()
            Trivial Abelian subgroup
            sage: G = AbelianGroup([0, 0])
            sage: G.torsion_subgroup()
            Trivial Abelian subgroup
        """
        torsion_generators = [g for g in self.gens() if g.order() != infinity]
        return self.subgroup(torsion_generators)


class AbelianGroup_subgroup(AbelianGroup_class):
    """
    Subgroup subclass of AbelianGroup_class, so instance methods are
    inherited.

    .. TODO::

        There should be a way to coerce an element of a subgroup
        into the ambient group.
    """
    def __init__(self, ambient, gens, names="f", category=None):
        """
        EXAMPLES::

            sage: F = AbelianGroup(5,[30,64,729],names = list("abcde"))
            sage: a,b,c,d,e = F.gens()
            sage: F.subgroup([a^3,b])
            Multiplicative Abelian subgroup isomorphic to Z x Z generated by {a^3, b}
            sage: F.subgroup([c])
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x C5 generated by {c}
            sage: F.subgroup([a, c])
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x C5 x Z generated by {a, c}
            sage: F.subgroup([a, b*c])
            Multiplicative Abelian subgroup isomorphic to Z x Z generated by {a, b*c}
            sage: F.subgroup([b*c, d])
            Multiplicative Abelian subgroup isomorphic to C64 x Z generated by {b*c, d}
            sage: F.subgroup([a*b, c^6, d],names=list("xyz"))
            Multiplicative Abelian subgroup isomorphic to C5 x C64 x Z generated by {a*b, c^6, d}
            sage: H.<x,y,z> = F.subgroup([a*b, c^6, d]); H
            Multiplicative Abelian subgroup isomorphic to C5 x C64 x Z generated by {a*b, c^6, d}
            sage: G = F.subgroup([a*b, c^6, d],names = list("xyz")); G
            Multiplicative Abelian subgroup isomorphic to C5 x C64 x Z generated by {a*b, c^6, d}
            sage: x,y,z = G.gens()
            sage: x.order()
            +Infinity
            sage: y.order()
            5
            sage: z.order()
            64
            sage: A = AbelianGroup(5,[3, 5, 5, 7, 8], names = "abcde")
            sage: a,b,c,d,e = A.gens()
            sage: A.subgroup([a,b])
            Multiplicative Abelian subgroup isomorphic to C3 x C5 generated by {a, b}
            sage: A.subgroup([a,b,c,d^2,e])
            Multiplicative Abelian subgroup isomorphic to C3 x C5 x C5 x C7 x C8 generated by {a, b, c, d^2, e}
            sage: A.subgroup([a, b, c, d^2, e^2])
            Multiplicative Abelian subgroup isomorphic to C3 x C4 x C5 x C5 x C7 generated by {a, b, c, d^2, e^2}
            sage: B = A.subgroup([a^3, b, c, d, e^2]); B
            Multiplicative Abelian subgroup isomorphic to C4 x C5 x C5 x C7 generated by {b, c, d, e^2}
            sage: B.gens_orders()
            (4, 5, 5, 7)
            sage: A = AbelianGroup(4,[1009, 2003, 3001, 4001], names = "abcd")
            sage: a,b,c,d = A.gens()
            sage: B = A.subgroup([a^3,b,c,d])
            sage: B.gens_orders()
            (1009, 2003, 3001, 4001)
            sage: A.order()
            24266473210027
            sage: B.order()
            24266473210027
            sage: A = AbelianGroup(4,[1008, 2003, 3001, 4001], names = "abcd")
            sage: a,b,c,d = A.gens()
            sage: B = A.subgroup([a^3,b,c,d]); B
            Multiplicative Abelian subgroup isomorphic
            to C3 x C7 x C16 x C2003 x C3001 x C4001 generated by {a^3, b, c, d}

        Infinite groups can also be handled::

            sage: G = AbelianGroup([3,4,0], names = "abc")
            sage: a,b,c = G.gens()
            sage: F = G.subgroup([a, b^2, c]); F
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x Z generated by {a, b^2, c}

            sage: F.gens_orders()
            (2, 3, 0)
            sage: F.gens()
            (a, b^2, c)
            sage: F.order()
            +Infinity

        Testing ticket :trac:`18863`::

            sage: G = AbelianGroup(5,[2])
            sage: G.subgroup([prod(g^k for g,k in zip(G.gens(),[1,-2,3,-4,5]))])
            Multiplicative Abelian subgroup isomorphic to Z generated by {f0*f1^-2*f2^3*f3^-4*f4}
        """
        from sage.interfaces.all import gap
        if not isinstance(ambient, AbelianGroup_class):
            raise TypeError("ambient (=%s) must be an abelian group."%ambient)
        if not isinstance(gens, tuple):
            raise TypeError("gens (=%s) must be a tuple"%gens)

        self._ambient_group = ambient
        Hgens = tuple(x for x in gens if x != ambient.one())  ## in case someone puts 1 in the list of generators
        self._gens = Hgens
        ambient_invs = ambient.gens_orders()
        invsf = [x for x in ambient_invs if x > 0]    ## fixes the problem with
        invs0 = [x for x in ambient_invs if x == 0]   ## the infinite parts
        Ggens = list(ambient.variable_names())
        if invs0!=[]:
            Gfgens = [x for x in ambient.variable_names() if
                        ambient_invs[Ggens.index(x)] != 0]
            Gf = AbelianGroup(invsf, names=Gfgens)
            s1 = "G:= %s; gens := GeneratorsOfGroup(G)"%Gf._gap_init_()
            gap.eval(s1)
            Hgens0 = [
                x for x in Hgens if
                any(e!=0 and (g.order() not in ZZ) for e,g in zip(x.exponents(),ambient.gens()))
            ]
            Hgensf = [x for x in Hgens if x not in Hgens0]
            # the "infinite" generators of H
            for i in range(len(Gfgens)):
               cmd = ("%s := gens["+str(i+1)+"]")%Gfgens[i]
               gap.eval(cmd)
        else:  # invs0==[]:
            Hgensf = Hgens
            Hgens0 = []  # added for consistency
            G = ambient
            s1 = "G:= %s; gens := GeneratorsOfGroup(G)"%G._gap_init_()
            gap.eval(s1)
            for i in range(len(Ggens)):
                cmd = '%s := gens[%s]'%(Ggens[i], i+1)
                gap.eval(cmd)
        s2 = "gensH:=%s"%list(Hgensf) #### remove from this the ones <--> 0 invar
        gap.eval(s2)
        s3 = 'H:=Subgroup(G,gensH)'
        gap.eval(s3)
        # a GAP command which returns the "invariants" of the
        # subgroup as an AbelianPcpGroup, RelativeOrdersOfPcp(Pcp(G)),
        # works if G is the subgroup declared as a AbelianPcpGroup
        self._abinvs = eval(gap.eval("AbelianInvariants(H)"))
        invs = self._abinvs
        if Hgens0 != []:
            for x in Hgens0:
               invs.append(0)
        invs = tuple(ZZ(i) for i in invs)
        if category is None:
            category = Groups().Commutative().Subobjects()
        AbelianGroup_class.__init__(self, invs, names, category=category)

    def __contains__(self, x):
        """
        Test whether ``x`` is an element of this subgroup.

        EXAMPLES::

            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: a in G
            True
            sage: a in A
            True

        TESTS:

        Check that :trac:`32910` is fixed::

            sage: G.<a,b> = AbelianGroup(2, [4, 576])
            sage: Hgens = [a^2, a*b^2]
            sage: H = G.subgroup(Hgens)
            sage: [g in H for g in (a^3, b^2, b^3, a^3*b^2, "junk")]
            [False, False, False, True, False]

        Check that :trac:`31507` is fixed::

            sage: G = AbelianGroup(2, gens_orders=[16, 16])
            sage: f0, f1 = G.gens()
            sage: H = G.subgroup([f0*f1^3])
            sage: [g in H for g in (f0, f0*f1^2, f0*f1^3, f0*f1^4)]
            [False, False, True, False]

            sage: G.<a,b> = AbelianGroup(2)
            sage: Hgens =  [a*b, a*b^-1]
            sage: H = G.subgroup(Hgens)
            sage: b^2 in H
            True
        """
        if not isinstance(x, AbelianGroupElement):
            return False
        if x.parent() is self:
            return True
        elif x in self.ambient_group():
            amb_inv = self.ambient_group().gens_orders()
            inv_basis = diagonal_matrix(ZZ, amb_inv)
            gens_basis = matrix(
                ZZ, len(self._gens), len(amb_inv),
                [g.list() for g in self._gens]
            )
            return (vector(ZZ, x.list())
                in inv_basis.stack(gens_basis).row_module())
        return False

    def ambient_group(self):
        """
        Return the ambient group related to self.

        OUTPUT:

        A multiplicative Abelian group.

        EXAMPLES::

            sage: G.<a,b,c> = AbelianGroup([2,3,4])
            sage: H = G.subgroup([a, b^2])
            sage: H.ambient_group() is G
            True
        """
        return self._ambient_group

    def equals(left, right):
        """
        Check whether ``left`` and ``right`` are the same (sub)group.

        INPUT:

        - ``right`` -- anything.

        OUTPUT:

        Boolean. If ``right`` is a subgroup, test whether ``left`` and
        ``right`` are the same subset of the ambient group. If
        ``right`` is not a subgroup, test whether they are isomorphic
        groups, see :meth:`~AbelianGroup_class.is_isomorphic`.

        EXAMPLES::

            sage: G = AbelianGroup(3, [2,3,4], names="abc"); G
            Multiplicative Abelian group isomorphic to C2 x C3 x C4
            sage: a,b,c = G.gens()
            sage: F = G.subgroup([a,b^2]); F
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {a, b^2}
            sage: F<G
            True

            sage: A = AbelianGroup(1, [6])
            sage: A.subgroup(list(A.gens())) == A
            True

            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: B = G.subgroup([b])
            sage: A.equals(B)
            False
            sage: A == B        # sames as A.equals(B)
            False
            sage: A.is_isomorphic(B)
            True
        """
        left_ambient = left.ambient_group()
        try:
            right_ambient = right.ambient_group()
        except AttributeError:
            # right is not a subgroup
            return left.is_isomorphic(right)
        if left_ambient is not right_ambient:
            return False
        return left <= right and right <= left

    __eq__ = equals

    def _repr_(self):
        """
        Return a string representation

        EXAMPLES::

            sage: G.<a,b> = AbelianGroup(2)
            sage: G._repr_()
            'Multiplicative Abelian group isomorphic to Z x Z'
            sage: A = G.subgroup([a])
            sage: A._repr_()
            'Multiplicative Abelian subgroup isomorphic to Z generated by {a}'
       """
        eldv = self.gens_orders()
        if self.is_trivial():
            return "Trivial Abelian subgroup"
        s = 'Multiplicative Abelian subgroup isomorphic to '
        s += self._group_notation(eldv)
        s += ' generated by '
        s += '{' + ', '.join(map(str, self.gens())) + '}'
        return s

    def gens(self):
        """
        Return the generators for this subgroup.

        OUTPUT:

        A tuple of group elements generating the subgroup.

        EXAMPLES::

            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: G.gens()
            (a, b)
            sage: A.gens()
            (a,)
        """
        return self._gens

    def gen(self, n):
        """
        Return the nth generator of this subgroup.

        EXAMPLES::

            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: A.gen(0)
            a
        """
        return self._gens[n]

# We allow subclasses to override this, analogous to Element
AbelianGroup_class.Subgroup = AbelianGroup_subgroup

