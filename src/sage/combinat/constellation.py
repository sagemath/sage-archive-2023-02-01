r"""
Constellations

A constellation is a tuple `(g_0, g_1, \dots, g_k)` of permutations
such that the product `g_0 g_1 ... g_k` is the identity. One often
assumes that the group generated by `g_0, g_1, \dots, g_k` acts
transitively ([LaZv04]_ definition 1). Geometrically, it corresponds
to a covering of the 2-sphere ramified over `k` points (the transitivity
condition corresponds to the connectivity of the covering).

.. NOTE::

    The permutations are on `[0, n-1]` and not on `[1, n]` for
    algorithmic and practical reasons.

EXAMPLES::

    sage: c = Constellation(['(0,1)', '(0,2)', None])
    sage: c
    Constellation of length 3 and degree 3
    g0 (0,1)(2)
    g1 (0,2)(1)
    g2 (0,2,1)
    sage: C = Constellations(3,4); C
    Connected constellations of length 3 and degree 4
    sage: C.cardinality()
    426

REFERENCES:

.. [LaZv04] S. Lando and A. Zvonkine, "Graphs on surfaces and their
            applications", Springer-Verlag, 2004.
"""

from sage.structure.parent import Parent
from sage.structure.element import Element
from sage.structure.unique_representation import UniqueRepresentation
from sage.groups.perm_gps.permgroup_named import SymmetricGroup

from sage.rings.integer import Integer
from sage.combinat.partition import Partition
from sage.graphs.graph import Graph

# we import everything from sage.misc.permutation
from sage.misc.permutation import *

# constructors


def Constellations(*data, **options):
    r"""
    Build a set of constellations.

    INPUT:

    - ``profile`` -- an optional profile

    - ``length`` -- an optional length

    - ``degree`` -- an optional degree

    - ``connected`` -- an optional boolean

    EXAMPLES:

    The set of all constellations::

        sage: Constellations()
        Connected constellations

    Constellations with constrained length and degree::

        sage: Constellations(4,2)
        Connected constellations of length 4 and degree 2
    """
    profile = options.get('profile', None)
    length = options.get('length', None)
    degree = options.get('degree', None)
    connected = options.get('connected', True)

    if data:
        if len(data) == 1:
            if isinstance(data[0], (tuple, list)):
                profile = data[0]
            else:
                length = Integer(data[0])
        elif len(data) == 2:
            length = Integer(data[0])
            degree = Integer(data[1])

    if profile:
        profile = tuple(map(Partition, profile))
        return Constellations_p(profile, bool(connected))
    if degree is None and length is None:
        return Constellations_all(bool(connected))
    elif degree is not None and length is not None:
        return Constellations_ld(Integer(length), Integer(degree),
                                 bool(connected))
    else:
        raise NotImplementedError("one cannot give just degree or just length")


def Constellation(g=None, mutable=False, connected=True, check=True):
    r"""
    Constellation

    INPUT:

    - ``g`` -- a list of permutations

    - ``mutable`` -- whether the result is mutable or not. Default is ``False``.

    - ``connected`` -- whether the result should be connected. Default is
      ``True``.

    - ``check`` -- whether or not to check. If it is ``True``, then the
      list g must contains no ``None``.

    EXAMPLES:

    Simple initialization::

        sage: Constellation(['(0,1)','(0,3)(1,2)','(0,3,1,2)'])
        Constellation of length 3 and degree 4
        g0 (0,1)(2)(3)
        g1 (0,3)(1,2)
        g2 (0,3,1,2)

    One of the permutation can be omitted::

        sage: Constellation(['(0,1)', None, '(0,4)(1,2,3)'])
        Constellation of length 3 and degree 5
        g0 (0,1)(2)(3)(4)
        g1 (0,3,2,1,4)
        g2 (0,4)(1,2,3)

    One can define mutable constellations::

        sage: Constellation(([0,2,1], [2,1,0], [1,2,0]), mutable=True)
        Constellation of length 3 and degree 3
        g0 (0)(1,2)
        g1 (0,2)(1)
        g2 (0,1,2)
    """
    return Constellations(connected=connected)(g, check=check, mutable=mutable)

# classes


class Constellation_class(Element):
    r"""
    Constellation

    A constellation or a tuple of permutations `(g_0,g_1,...,g_k)`
    such that the product `g_0 g_1 ... g_k` is the identity.
    """
    def __init__(self, parent, g, check=True, connected=True, mutable=False):
        r"""
        TESTS::

            sage: c = Constellation([[1,2,0],[0,2,1],[1,0,2],None])
            sage: c == loads(dumps(c))
            True
            sage: g0 = '(0,1)(2,4)'
            sage: g1 = '(0,3)(1,4)'
            sage: g2 = '(2,4,3)'
            sage: g3 = '(0,3)(1,2)'
            sage: c0 = Constellation([g0,g1,g2,g3])
            sage: c0 == Constellation([None,g1,g2,g3])
            True
            sage: c0 == Constellation([g0,None,g2,g3])
            True
            sage: c0 == Constellation([g0,g1,None,g3])
            True
            sage: c0 == Constellation([g0,g1,g2,None])
            True
        """
        Element.__init__(self, parent)
        self._connected = connected
        self._mutable = mutable
        self._g = g
        d = Integer(0) if len(self._g) == 0 else Integer(len(self._g[0]))
        self._degree = d
        Sd = SymmetricGroup(range(d))
        newg = []
        for s in g:
            if s is None:
                newg.append(None)
            else:
                newg.append(Sd(s))
        self._newg = newg
        if check:
            self._check()

    def __hash__(self):
        r"""
        Return a hash for ``self``.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: c.__hash__()
            2148362403144019871
        """
        if self._mutable:
            raise ValueError("can not hash mutable constellation")
        return hash(tuple(map(tuple, self._g)))

    def set_immutable(self):
        r"""
        Do nothing, as ``self`` is already immutable.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: c.set_immutable()
            sage: c.is_mutable()
            False
        """
        self._mutable = False

    def is_mutable(self):
        r"""
        Return ``False`` as ``self`` is immutable.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: c.is_mutable()
            False
        """
        return self._mutable

    def switch(self, i, j0, j1):
        r"""
        Swith the vertices and edges at `i` and `i + 1`.

        The modification is local in the sense that it modifies `g_i`
        and `g_{i+1}` but does not modify the product `g_i g_{i+1}`.

        |  j0 -- g_i   --> k0 -- g_i0  --> l0
        |  j1 -- g_i+1 --> k1 -- g_i+1 --> l1

        becomes

        |  j0 -- g_i   --> k1 -- g_i   --> l0
        |  j1 -- g_i+1 --> k1 -- g_i+1 --> l1

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None], mutable=True); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: c.switch(1,2,3); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2,3)
            g2 (0,1,3,4)(2)
        """
        if not self._mutable:
            raise ValueError("this constellation is immutable."
                             " Take a mutable copy first.")
        perm_switch(self._g[i], self._g[i + 1], j0, j1)
        tr = SymmetricGroup(range(self.degree()))((j0, j1))
        self._newg[i] = tr * self._newg[i]
        self._newg[i + 1] = tr * self._newg[i + 1]

    def euler_characteristic(self):
        r"""
        Return the Euler characteristic of the surface.

        ALGORITHM:

        Hurwitz formula

        EXAMPLES::

            sage: c = Constellation(['(0,1)', '(0,2)', None])
            sage: c.euler_characteristic()
            2
        """
        return Integer(self.degree() * 2 -
                       sum(sum(i - 1 for i in self.profile(i))
                           for i in xrange(self.length())))

    def genus(self):
        r"""
        Return the genus of the surface.

        EXAMPLES::

            sage: c = Constellation(['(0,1)', '(0,2)', None])
            sage: c.genus()
            0
        """
        return 1 - self.euler_characteristic() / 2

    def _check(self):
        r"""
        Check that the constellation is valid and if not raise ValueError.

        TESTS::

            sage: c = Constellation([[0,1],[1,0]], mutable=True, check=False)
            sage: c._check()
            Traceback (most recent call last):
            ...
            ValueError: The product is not identity

            sage: c = Constellation([[0,1],[0,1]], mutable=True, check=False)
            sage: c._check()
            Traceback (most recent call last):
            ...
            ValueError: not connected
        """
        d = self.degree()
        Sd = SymmetricGroup(range(d))
        for i in xrange(self.length()):
            Sd(self._g[i])

        h = range(self.degree())
        for p in self._g:
            h = perm_compose(h, p)
        for i in xrange(self.degree()):
            if h[i] != i:
                raise ValueError("The product is not identity")

        if self._connected and not perms_are_connected(self._g, self.degree()):
            raise ValueError("not connected")

    def __copy__(self):
        r"""
        TESTS::

            sage: c = Constellation([[0,2,1],[1,0,2],[2,1,0],None])
            sage: c == copy(c)
            True
            sage: c is copy(c)
            False
            sage: c = Constellation([[0,2,1],[1,0,2],[2,1,0],None],mutable=True)
            sage: c == copy(c)
            True
            sage: c is copy(c)
            False
        """
        return self.parent()([gg[:] for gg in self._g],
                             check=False,
                             mutable=self._mutable)

    copy = __copy__

    def mutable_copy(self):
        r"""
        Return a mutable copy of ``self``.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: d = c.mutable_copy()
            sage: d.is_mutable()
            True
        """
        return self.parent()([gg[:] for gg in self._g],
                             check=False,
                             mutable=True)

    ## GENERAL PROPERTIES

    def is_connected(self):
        r"""
        Test of connectedness.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2)', None, '(0,1)(2)'], connected=False)
            sage: c.is_connected()
            False
            sage: c = Constellation(['(0,1,2)', None], connected=False)
            sage: c.is_connected()
            True
        """
        if self._connected:
            return True
        else:
            return perms_are_connected(self._g, self.degree())

    def connected_components(self):
        """
        Return the connected components.

        OUTPUT:

        A list of connected constellations.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2)', None, '(0,1)(2)'], connected=False)
            sage: cc = c.connected_components(); cc
            [Constellation of length 3 and degree 2
            g0 (0,1)
            g1 (0)(1)
            g2 (0,1),
            Constellation of length 3 and degree 1
            g0 (0)
            g1 (0)
            g2 (0)]
            sage: all(c2.is_connected() for c2 in cc)
            True

            sage: c = Constellation(['(0,1,2)', None], connected=False)
            sage: c.connected_components()
            [Constellation of length 2 and degree 3
            g0 (0,1,2)
            g1 (0,2,1)]
        """
        if self._connected:
            return [self]
        G = Graph()
        G.add_vertices(range(self.degree()))
        for p in self._g:
            G.add_edges(enumerate(p))
        m = G.connected_components()
        if len(m) == 1:
            return [self]
        for mm in m:
            mm.sort()
        m.sort()
        g = [[] for _ in xrange(len(m))]
        m_inv = [None] * self.degree()
        for t in xrange(len(m)):
            for i in xrange(len(m[t])):
                m_inv[m[t][i]] = i
            for k in xrange(self.length()):
                tmp = [None] * len(m[t])
                for i in xrange(len(m[t])):
                    tmp[i] = m_inv[self._g[k][m[t][i]]]
                g[t].append(tmp)
        return [Constellation(g=g[i], check=False) for i in xrange(len(m))]

    def __eq__(self, other):
        r"""
        Test of equality.

        TESTS::

            sage: Constellation(['(0,1,2)', None]) == Constellation(['(0,1,2)', None])
            True
            sage: Constellation(['(0,1)','(0,2)',None]) == Constellation(['(0,1)',None,'(0,2)'])
            False
        """
        if not isinstance(other, Constellation_class):
            return False
        return (self._g == other._g)

    def __ne__(self, other):
        r"""
        Test of inequality.

        TESTS::

            sage: Constellation(['(0,1,2)', None]) != Constellation(['(0,1,2)', None])
            False
            sage: Constellation(['(0,1)','(0,2)',None]) != Constellation(['(0,1)',None,'(0,2)'])
            True
        """
        if not isinstance(other, Constellation_class):
            return True
        return (self._g != other._g)

    def is_isomorphic(self, other, return_map=False):
        r"""
        Test of isomorphism.

        Return ``True`` if the constellations are isomorphic
        (i.e. related by a common conjugacy) and return the permutation that
        conjugate the two permutations if ``return_map`` is ``True`` in
        such a way that self.relabel(m) == other

        ALGORITHM:

        uses canonical labels obtained from the method :meth:`relabel`.

        EXAMPLES::

            sage: c = Constellation([[1,0,2],[2,1,0],[0,2,1],None])
            sage: d = Constellation([[2,1,0],[0,2,1],[1,0,2],None])
            sage: answer, mapping = c.is_isomorphic(d,return_map=True)
            sage: print answer
            True
            sage: c.relabel(mapping) == d
            True
        """
        if return_map:
            if not(self.degree() == other.degree() and
                   self.length() == other.length()):
                return False, None
            sn, sn_map = self.relabel(return_map=True)
            on, on_map = other.relabel(return_map=True)
            if sn != on:
                return False, None
            return True, perm_compose(sn_map, perm_invert(on_map))

        return (self.degree() == other.degree() and
                self.length() == other.length() and
                self.relabel() == other.relabel())

    def __cmp__(self, other):
        r"""
        TESTS::

            sage: c1 = Constellation([[1,2,0],None])
            sage: c2 = Constellation([[2,0,1],None])
            sage: c1 < c2
            True
            sage: c2 > c1
            True
        """
        if self.length() != other.length():
            return self.length().__cmp__(other.length())
        if self.degree() != other.degree():
            return self.degree().__cmp__(other.degree())
        for i in xrange(self.length() - 1):
            for j in xrange(self.degree() - 1):
                if self._g[i][j] != other._g[i][j]:
                    return self._g[i][j].__cmp__(other._g[i][j])
        return 0

    def _repr_(self):
        r"""
        String representation

        EXAMPLES::

            sage: c = Constellation([[1,0,2],[2,1,0],[0,2,1],None])
            sage: c._repr_()
            'Constellation of length 4 and degree 3\ng0 (0,1)(2)\ng1 (0,2)(1)\ng2 (0)(1,2)\ng3 (0,2)(1)'
        """
        s = "Constellation of length {} and degree {}".format(self.length(),
                                                              self.degree())
        for i in xrange(self.length()):
            s += "\ng{} {}".format(i, self._newg[i].cycle_string(True))
        return s

    def degree(self):
        r"""
        Return the degree of the constellation

        The degree of a constellation is the number `n` that
        corresponds to the symmetric group `S(n)` in which the
        permutations of the constellation are defined.

        EXAMPLES::

            sage: c = Constellation([])
            sage: c.degree()
            0
            sage: c = Constellation(['(0,1)',None])
            sage: c.degree()
            2
            sage: c = Constellation(['(0,1)','(0,3,2)(1,5)',None,'(4,3,2,1)'])
            sage: c.degree()
            6
        """
        return self._degree

    def length(self):
        r"""
        Return the number of permutations.

        EXAMPLES::

            sage: c = Constellation(['(0,1)','(0,2)','(0,3)',None])
            sage: c.length()
            4
            sage: c = Constellation(['(0,1,3)',None,'(1,2)'])
            sage: c.length()
            3
        """
        return len(self._g)

    def profile(self, i=None):
        r"""
        Return the profile of ``self``.

        The profile of a constellation is the tuple of partitions
        associated to the conjugacy classes of the permutations of the
        constellation.

        EXAMPLES::

            sage: c = Constellation(['(0,1,2)(3,4)','(0,3)',None])
            sage: c.profile()
            ([3, 2], [2, 1, 1, 1], [5])
        """
        if i is None:
            return tuple(self.profile(j) for j in xrange(self.length()))
        else:
            parts = [len(cy) for cy in self._newg[i].cycle_tuples(True)]
            return Partition(sorted(parts, reverse=True))

    passport = profile

    ## ACCESS TO INDIVIDUAL PERMUTATION

    def g(self, i=None):
        r"""
        Return the permutation i of the constellation as a list

        EXAMPLES::

            sage: c = Constellation(['(0,1,2)(3,4)','(0,3)',None])
            sage: c.g(0)
            [1, 2, 0, 4, 3]
            sage: c.g(1)
            [3, 1, 2, 0, 4]
            sage: c.g(2)
            [4, 0, 1, 2, 3]
        """
        from copy import copy
        if i is None:
            return map(copy, self._g)
        else:
            return copy(self._g[i])

    def g_cycle_tuples(self, i, singletons=False):
        r"""
        Return the tuples associated to the cycles of the permutations
        of ``self``

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(0,4)(1,3)',None])
            sage: c.g_cycle_tuples(0)
            [(0, 1), (2, 3, 4)]
            sage: c.g_cycle_tuples(1)
            [(0, 4), (1, 3)]
        """
        if i is None:
            return [s.cycle_tuples(singletons) for s in self._newg]
        else:
            return self._newg[i].cycle_tuples(singletons)

    def g_cycle_string(self, i, singletons=False):
        r"""
        Return the permutations of a constellation, as cycles

        If `i` is ``None``, return all of them

        Otherwise, return just the permutation `g_i` as a cycle

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(0,4)(1,3)',None])
            sage: c.g_cycle_string(None)
            ['(0,1)(2,3,4)', '(0,4)(1,3)', '(0,3)(1,2,4)']
            sage: c.g_cycle_string(2)
            '(0,3)(1,2,4)'
        """
        if i is None:
            return [s.cycle_string(singletons) for s in self._newg]
        else:
            return self._newg[i].cycle_string(singletons)

    def g_next(self, i, j):
        r"""
        Return the image of `j` for the permutation `g_i` in constant time

        EXAMPLES::

            sage: c = Constellation(['(1,2,0,5)','(2,3,4)(5,1)',None])
            sage: c.g_next(0,0)
            5
            sage: all(c.g(i)[j] == c.g_next(i,j) for i in xrange(3) for j in xrange(6))
            True
        """
        if i is None:
            return map(lambda x: x[j], self._g)
        else:
            return self._g[i][j]

    def g_prev(self, i, j):
        r"""
        Return the image of `j` for the permutation `g_i` in constant time

        EXAMPLES::

            sage: c = Constellation(['(0,1,2)(3,4)','(0,4,2)',None])
            sage: c.g_prev(0,0)
            2
            sage: all(c.g(i)[c.g_prev(i,j)] == j for i in xrange(3) for j in xrange(5))
            True
        """
        if i is None:
            return [self.g_prev(k, j) for k in xrange(self.length())]
        else:
            for k in xrange(i + 1, self.length()):
                j = self._g[k][j]
            for k in xrange(0, i):
                j = self._g[k][j]
            return j

    def g_orbit(self, i, j):
        r"""
        Return the orbit of `j` under `g_i`.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None])
            sage: c.g_orbit(0,3)
            [3, 4, 2]
            sage: c.g_orbit(1,0)
            [0]
        """
        if i is None:
            return [self.g_orbit(k, j) for k in xrange(self.length())]
        else:
            return perm_orbit(self._g[i], j)

    def relabel(self, perm=None, return_map=False):
        r"""
        Relabel ``self``.

        If ``perm`` is provided then relabel with respect to ``perm``. Otherwise
        use canonical labels. In that case, if ``return_map`` is provided, the
        return also the map used for canonical labels.

        Algorithm:

        the cycle for g(0) are adjacent and the cycle are joined with
        respect to the other permutations. The minimum is taken for
        all possible renumerotations.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None]); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: c2 = c.relabel(); c2
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,2)(3)(4)
            g2 (0,1,4,3,2)

        The map returned when the option ``return_map`` is set to True can be
        used to set the relabelling::

            sage: c3, perm = c.relabel(return_map=True)
            sage: c3 == c2 and c3 == c.relabel(perm=perm)
            True

            sage: d = c.relabel([4,3,1,0,2]); d
            Constellation of length 3 and degree 5
            g0 (0,2,1)(3,4)
            g1 (0)(1)(2,3)(4)
            g2 (0,1,2,4,3)
            sage: d.is_isomorphic(c)
            True

        We check that after a random relabelling the new constellation is
        isomorphic to the initial one::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None])
            sage: p = SymmetricGroup(c.degree()).random_element()
            sage: cc = c.relabel([x-1 for x in p.domain()]).relabel()
            sage: cc.is_isomorphic(c)
            True
        """
        if perm is not None:
            perm.extend(xrange(len(perm), self.degree()))
            g = [[None] * self.degree() for _ in xrange(self.length())]
            for i in xrange(len(perm)):
                for k in xrange(self.length()):
                    g[k][perm[i]] = perm[self._g[k][i]]
            return Constellation(g=g, check=False, mutable=self.is_mutable())

        if return_map:
            try:
                return self._normal_form, self._normal_form_map
            except AttributeError:
                pass
        else:
            try:
                return self._normal_form
            except AttributeError:
                pass

        # compute canonical labels
        if not self.is_connected():
            raise ValueError("No canonical labels implemented for"
                             " non connected constellation")

        c_win, m_win = perms_canonical_labels(self._g)
        c_win = self.parent()(c_win, mutable=False, check=False)

        if not self.is_mutable():
            self._normal_form = c_win
            self._normal_form_map = m_win

        c_win._normal_form = c_win
        c_win._normal_form_map = m_win

        if return_map:
            return c_win, m_win
        else:
            return c_win

    # BRAID GROUP ACTION

    def braid_group_action(self, i):
        r"""
        Acts on self as the braid group generator that exchanges
        position `i` and `i+1`

        INPUT:

        - ``i`` -- integer in `[0, n-1]` where `n` is the length of self

        EXAMPLES::

            sage: sigma = lambda c, i: c.braid_group_action(i)

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None]); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: sigma(c, 1)
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0,1,3,2,4)
            g2 (0,3)(1)(2)(4)

        Check the commutation relation::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)','(2,5)(0,4)',None])
            sage: d = Constellation(['(0,1,3,5)','(2,3,4)','(0,3,5)',None])
            sage: c13 = sigma(sigma(c, 0), 2)
            sage: c31 = sigma(sigma(c, 2), 0)
            sage: c13 == c31
            True
            sage: d13 = sigma(sigma(d, 0), 2)
            sage: d31 = sigma(sigma(d, 2), 0)
            sage: d13 == d31
            True

        Check the braid relation::

            sage: c121 = sigma(sigma(sigma(c, 1), 2), 1)
            sage: c212 = sigma(sigma(sigma(c, 2), 1), 2)
            sage: c121 == c212
            True
            sage: d121 = sigma(sigma(sigma(d, 1), 2), 1)
            sage: d212 = sigma(sigma(sigma(d, 2), 1), 2)
            sage: d121 == d212
            True
        """
        if i < 0 or i >= self.length():
            raise ValueError("i should be between 0 and %d" % (self.length() - 1))
        j = i + 1
        if j == self.length():   # wrap around the cylinder
            j = 0
        h = self.copy()
        si = self._g[i]
        sj = self._g[j]
        newsi = self._newg[i]
        newsj = self._newg[j]
        h._g[i] = sj
        h._newg[i] = newsj
        h._g[j] = perm_compose(perm_compose(perm_invert(sj), si), sj)
        h._newg[j] = newsj.inverse() * newsi * newsj
        return h

    def braid_group_orbit(self):
        r"""
        Return the graph of the action of the braid group.

        The action is considered up to isomorphism of constellation.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None]); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: G = c.braid_group_orbit()
            sage: G.num_verts()
            4
            sage: G.num_edges()
            12
        """
        from sage.graphs.digraph import DiGraph

        G = DiGraph(multiedges=True, loops=True)
        waiting = [self.relabel()]

        while waiting:
            c = waiting.pop()
            G.add_vertex(c)
            for i in xrange(self.length()):
                cc = self.braid_group_action(i).relabel()
                if cc not in G:
                    waiting.append(cc)
                G.add_edge(c, cc, i)
        return G


class Constellations_all(UniqueRepresentation, Parent):
    Element = Constellation_class

    def __init__(self, connected=True):
        r"""
        TESTS::

            sage: TestSuite(Constellations()).run()
        """
        from sage.categories.infinite_enumerated_sets import InfiniteEnumeratedSets
        Parent.__init__(self, category=InfiniteEnumeratedSets())
        self._connected = connected

    def __contains__(self, elt):
        r"""
        TESTS::

            sage: C = Constellations(connected=True)
            sage: D = Constellations(connected=False)
            sage: C([[1,0],None]) in C
            True
            sage: C([[1,0],None]) in D
            True
            sage: D([[1,0],None]) in C
            True
            sage: D([[1,0],None]) in D
            True
            sage: D([[0,1],None]) in C
            False
            sage: D([[0,1],None]) in D
            True
        """
        return isinstance(elt, Constellation_class) and (not self._connected or elt.is_connected())

    def _repr_(self):
        r"""
        String representation.

        TESTS::

            sage: Constellations()    # indirect doctest
            Connected constellations
        """
        if self._connected:
            return "Connected constellations"
        else:
            return "Constellations"

    def _element_constructor_(self, g, check=True, mutable=False):
        r"""
        Return a constellation.

        EXAMPLES::

            sage: Constellation([[1,0],[1,0]])  # indirect doctest
            Constellation of length 2 and degree 2
            g0 (0,1)
            g1 (0,1)
        """
        if g is None or len(g) == 0:
            gg = []

        else:
            if g.count(None) == 0:
                i = None
            elif g.count(None) == 1:
                i = g.index(None)
                del g[i]
            else:
                raise ValueError("only one permutation must be None")

            gg = map(init_perm, g)
            equalize_perms(gg)

            if i is not None:
                h = range(len(gg[0]))
                for p in gg[i:]:
                    h = perm_compose(h, p)
                for p in gg[:i]:
                    h = perm_compose(h, p)
                gg.insert(i, perm_invert(h))

        return self.element_class(self, gg, check, self._connected, mutable)

    def an_element(self):
        r"""
        Return a constellation.

        EXAMPLES::

            sage: Constellations().an_element()
            Constellation of length 2 and degree 2
            g0 (0,1)
            g1 (0,1)
        """
        return Constellations(2, 2).an_element()

    def __iter__(self):
        r"""
        TESTS::

            sage: I = iter(Constellations())
            sage: for _ in xrange(100): print I.next()
            Constellation of length 1 and degree 1
            g0 (0)
            Constellation of length 2 and degree 1
            g0 (0)
            g1 (0)
            Constellation of length 3 and degree 1
            g0 (0)
            g1 (0)
            g2 (0)
            Constellation of length 2 and degree 2
            g0 (0,1)
            g1 (0,1)
            ...
            Constellation of length 4 and degree 3
            g0 (0)(1,2)
            g1 (0)(1,2)
            g2 (0,2,1)
            g3 (0,1,2)
            Constellation of length 4 and degree 3
            g0 (0)(1,2)
            g1 (0)(1,2)
            g2 (0,2)(1)
            g3 (0,2)(1)
        """
        n = 2
        while True:
            for d in xrange(1, n):
                l = n - d
                for c in Constellations(l, d, connected=self._connected):
                    yield c
            n += 1


class Constellations_ld(UniqueRepresentation, Parent):
    r"""
    Constellations of given length and degree.

    EXAMPLES::

        sage: C = Constellations(2,3); C
        Connected constellations of length 2 and degree 3
        sage: C([[1,2,0],[2,0,1]])
        Constellation of length 2 and degree 3
        g0 (0,1,2)
        g1 (0,2,1)
        sage: C.cardinality()
        2
        sage: Constellations(2,3,connected=False).cardinality()
        6
    """
    def __init__(self, length, degree, connected=True):
        """
        TESTS::

            sage: TestSuite(Constellations(length=6,degree=4)).run(skip='_test_cardinality')
        """
        from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
        Parent.__init__(self, facade=Constellations_all(),
                        category=FiniteEnumeratedSets())
        self._length = Integer(length)
        self._degree = Integer(degree)
        if self._length <= 0:
            raise ValueError("length should be a positive integer")
        if self._degree <= 0:
            raise ValueError("degree should be a positive integer")
        self._connected = bool(connected)

    def __contains__(self, elt):
        r"""
        TESTS::

            sage: C = Constellations(2,3,connected=True)
            sage: D = Constellations(2,3,connected=False)
            sage: C([[2,0,1],None]) in C
            True
            sage: D([[2,0,1],None]) in C
            True
            sage: D([[2,0,1],None]) in D
            True
            sage: D([[0,1,2],None]) in C
            False
            sage: D([[0,1,2],None]) in D
            True
        """
        if elt not in Constellations(connected=self._connected):
            return False
        return elt.length() == self._length and elt.degree() == self._degree

    def first(self):
        r"""
        Return the first element in lexicographic order.

        EXAMPLES::

            sage: const = Constellations(3,3); const
            Connected constellations of length 3 and degree 3
            sage: const.first()
            Constellation of length 3 and degree 3
            g0 (0,1,2)
            g1 (0,1,2)
            g2 (0,1,2)
        """
        if self._connected:
            g = [str(tuple(range(self._degree)))] * self._length
        else:
            g = [range(self._degree)] * self._length
        return self(g, check=False)

    def last(self):
        r"""
        Return the last element in lexicographic order.

        EXAMPLES::

            sage: const=Constellations(3,3);const
            Connected constellations of length 3 and degree 3
            sage: const.last()
            Constellation of length 3 and degree 3
            g0 (0,2,1)
            g1 (0,2,1)
            g2 (0,2,1)
        """
        if self._connected:
            g = [str(tuple(range(self._degree - 1, -1, -1)))] * self._length
        else:
            g = [range(self._degree - 1, -1, -1)] * self._length
        return Constellation(g, check=False, mutable=False)

    def _repr_(self):
        """
        TESTS::

            sage: Constellations(3,3)._repr_()
            'Connected constellations of length 3 and degree 3'
            sage: Constellations(3,3,connected=False)._repr_()
            'Constellations of length 3 and degree 3'
        """
        s = "of length {} and degree {}".format(self._length, self._degree)
        if self._connected:
            return "Connected constellations " + s
        return "Constellations " + s

    def __iter__(self):
        """
        iterator over all constellations of given degree and length

        EXAMPLES::

            sage: const = Constellations(3,3); const
            Connected constellations of length 3 and degree 3
            sage: len([v for v in const])
            26

        One can check the first few terms of sequence :oeis:`220754`::

            sage: Constellations(4,1).cardinality()
            1
            sage: Constellations(4,2).cardinality()
            7
            sage: Constellations(4,3).cardinality()
            194
            sage: Constellations(4,4).cardinality()  # long time
            12858
        """
        from sage.misc.misc import srange
        from itertools import product, permutations

        if self._length == 1:
            if self._degree == 1:
                yield self([[0]])
            return

        for p in product(permutations(srange(self._degree)),
                         repeat=self._length - 1):
            if self._connected and not perms_are_connected(p, self._degree):
                continue
            yield self(map(list, p) + [None], check=False)

    def random_element(self, mutable=False):
        r"""
        a random element

        EXAMPLES::

            sage: const = Constellations(3,3)
            sage: const.random_element()
            Constellation of length 3 and degree 3
            ...
            ...
            ...
            sage: c = const.random_element()
            sage: c.degree() == 3 and c.length() == 3
            True
        """
        from sage.groups.perm_gps.permgroup import PermutationGroup

        l = self._length
        d = self._degree
        Sd = SymmetricGroup(range(d))

        g = [Sd.random_element() for _ in xrange(l - 1)]
        G = PermutationGroup(g)
        while not G.degree() == d or (self._connected and
                                      not G.is_transitive()):
            g = [Sd.random_element() for _ in xrange(l - 1)]
            G = PermutationGroup(g)

        return self([sigma.domain() for sigma in g] + [None], mutable=mutable)

    def _element_constructor_(self, *data, **options):
        r"""
        Build an element of ``self``.

        EXAMPLES::

            sage: C = Constellations(2,3)
            sage: C([[1,2,0],[2,0,1]])
            Constellation of length 2 and degree 3
            g0 (0,1,2)
            g1 (0,2,1)
            sage: C([[2,1,0],[2,1,0]])
            Traceback (most recent call last):
            ...
            ValueError: not connected
        """
        c = Constellations(connected=self._connected)(*data, **options)
        if c.degree() != self._degree:
            raise ValueError("not able to build a constellation of degree %d from the given data" % self._degree)
        if c.length() != self._length:
            raise ValueError("not able to build a constellation of length %d from the given data" % self._length)
        return c

    def an_element(self):
        r"""
        Return a constellation in ``self``.

        EXAMPLES::

            sage: Constellations(2,3).an_element()
            Constellation of length 2 and degree 3
            g0 (0,2,1)
            g1 (0,1,2)
            sage: Constellations(7,3).an_element()
            Constellation of length 7 and degree 3
            g0 (0,2,1)
            g1 (0,1,2)
            g2 (0)(1)(2)
            g3 (0)(1)(2)
            g4 (0)(1)(2)
            g5 (0)(1)(2)
            g6 (0)(1)(2)
        """
        if self._degree == 0 and self._length == 0:
            return self()([])
        elif self._length == 1:
            if self._degree > 1:
                from sage.categories.sets_cat import EmptySetError
                raise EmptySetError
            return self()([[0]])

        d = self._degree
        if self._connected:
            g = [[d - 1] + range(d - 1), range(1, d) + [0]]
            g += [range(d)] * (self._length - 2)
        else:
            g = [range(d)] * self._length
        return self(g)

    def braid_group_action(self):
        r"""
        Return a list of graphs that corresponds to the braid group action on
        ``self`` up to isomorphism.

        OUTPUT:

        - list of graphs

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: C.braid_group_action()
            [Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 1 vertex]
        """
        G = []
        for c in self:
            c = c.relabel()
            if any(c in g for g in G):
                continue
            G.append(c.braid_group_orbit())
        return G

    def braid_group_orbits(self):
        r"""
        Return the orbits under the action of braid group.

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: O = C.braid_group_orbits()
            sage: len(O)
            3
            sage: [x.profile() for x in O[0]]
            [([1, 1, 1], [3], [3]), ([3], [1, 1, 1], [3]), ([3], [3], [1, 1, 1])]
            sage: [x.profile() for x in O[1]]
            [([2, 1], [2, 1], [3]), ([2, 1], [3], [2, 1]), ([3], [2, 1], [2, 1])]
            sage: [x.profile() for x in O[2]]
            [([3], [3], [3])]
        """
        return [g.vertices() for g in self.braid_group_action()]


class Constellations_p(UniqueRepresentation, Parent):
    r"""
    Constellations with fixed profile.

    EXAMPLES::

        sage: C = Constellations([[3,1],[3,1],[2,2]]); C
        Constellations with profile ([3, 1], [3, 1], [2, 2])
        sage: C.cardinality()
        24
        sage: C.first()
        Constellation of length 3 and degree 4
        g0 (0)(1,2,3)
        g1 (0,1,2)(3)
        g2 (0,1)(2,3)
        sage: C.last()
        Constellation of length 3 and degree 4
        g0 (0,3,2)(1)
        g1 (0,3,1)(2)
        g2 (0,1)(2,3)

    Note that the cardinality can also be computed using characters of the
    symmetric group (Frobenius formula)::

        sage: P = Partitions(4)
        sage: p1 = Partition([3,1])
        sage: p2 = Partition([3,1])
        sage: p3 = Partition([2,2])
        sage: i1 = P.cardinality() - P.rank(p1) - 1
        sage: i2 = P.cardinality() - P.rank(p2) - 1
        sage: i3 = P.cardinality() - P.rank(p3) - 1
        sage: s = 0
        sage: for c in SymmetricGroup(4).irreducible_characters():
        ....:     v = c.values()
        ....:     s += v[i1] * v[i2] * v[i3] / v[0]
        sage: c1 = p1.conjugacy_class_size()
        sage: c2 = p2.conjugacy_class_size()
        sage: c3 = p3.conjugacy_class_size()
        sage: print c1 * c2 * c3 / factorial(4)**2 * s
        1

    The number obtained above is up to isomorphism. And we can check::

        sage: len(C.isomorphism_representatives())
        1
    """
    def __init__(self, profile, connected=True):
        r"""
        OPTIONS:

        - ``profile`` -- a list of integer partitions of the same integer

        - ``connected`` -- a boolean (default: True) that specify if we consider
          only connected constellations.

        TESTS::

            sage: C = Constellations([(3,1),(3,1),(2,2)])
            sage: TestSuite(C).run()
        """
        l = Integer(len(profile))
        d = Integer(sum(profile[0]))
        for p in profile[1:]:
            if sum(p) != d:
                raise ValueError("all partition in the passport should "
                                 "have the same sum.")

        from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
        Parent.__init__(self, facade=Constellations_all(), category=FiniteEnumeratedSets())
        self._profile = profile
        self._degree = d
        self._length = l
        self._connected = connected

    def _repr_(self):
        r"""
        TESTS::

            sage: Constellations(([3,2],[2,2,1]))
            Constellations with profile ([3, 2], [2, 2, 1])
        """
        return "Constellations with profile %s" % (self._profile,)

    def isomorphism_representatives(self):
        r"""
        Return a set of isomorphism representative of ``self``.

        EXAMPLES::

            sage: C = Constellations([[5], [4,1], [3,2]])
            sage: C.cardinality()
            240
            sage: ir = sorted(C.isomorphism_representatives())
            sage: len(ir)
            2
            sage: ir[0]
            Constellation of length 3 and degree 5
            g0 (0,1,2,3,4)
            g1 (0)(1,2,3,4)
            g2 (0,4,2)(1,3)
            sage: ir[1]
            Constellation of length 3 and degree 5
            g0 (0,1,2,3,4)
            g1 (0)(1,4,2,3)
            g2 (0,4)(1,2,3)
        """
        result = set()
        for c in self:
            cc = c.relabel()
            if cc not in result:
                result.add(cc)
        return result

    def _element_constructor_(self, *data, **options):
        r"""
        Build an element of ``self``.

        TESTS::

            sage: C = Constellations([(3,1),(3,1),(2,2)])
            sage: c = C(['(1,2,3)','(0,1,2)','(0,1)(2,3)']); c
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,1,2)(3)
            g2 (0,1)(2,3)
            sage: C(['(1,2,3)','(0,1,3)',None])
            Traceback (most recent call last):
            ...
            ValueError: not able to build a constellation with profile ([3, 1], [3, 1], [2, 2]) from the given data
        """
        c = Constellations(connected=self._connected)(*data, **options)
        if options.get('check', True):
            if c.profile() != self._profile:
                raise ValueError("not able to build a constellation with profile %s from the given data" % (self._profile,))
        return c

    def __iter__(self):
        r"""
        Iterator of the elements in ``self``.

        .. NOTE::

            The algorithm is highly non optimized and is *very* slow for large
            entries! In order to make a better one, we need an iterator over
            conjugacy classes of the symmetric group.

        TESTS::

            sage: C = Constellations([(3,1),(3,1),(2,2)])
            sage: for c in C: print c
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,1,2)(3)
            g2 (0,1)(2,3)
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,2,3)(1)
            g2 (0,2)(1,3)
            ...
            Constellation of length 3 and degree 4
            g0 (0,3,2)(1)
            g1 (0,1,2)(3)
            g2 (0,3)(1,2)
            Constellation of length 3 and degree 4
            g0 (0,3,2)(1)
            g1 (0,3,1)(2)
            g2 (0,1)(2,3)
        """
        from sage.misc.misc import srange
        from itertools import product, permutations

        if self._length == 1:
            if self._degree == 1:
                yield self([[0]])
            return

        for p in product(permutations(srange(self._degree)),
                         repeat=self._length - 1):
            if self._connected and not perms_are_connected(p, self._degree):
                continue
            c = Constellations(connected=self._connected)(map(list, p) + [None], check=False)
            if c.profile() == self._profile:
                yield c

    def braid_group_action(self):
        r"""
        List of graphs that corresponds to the braid group action on
        ``self`` up to isomorphism.

        OUTPUT:

        - list of graphs

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: C.braid_group_action()
            [Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 1 vertex]
        """
        G = []
        for c in self:
            c = c.relabel()
            if any(c in g for g in G):
                continue
            G.append(c.braid_group_orbit())
        return G

    def braid_group_orbits(self):
        r"""
        Orbits under the action of braid group.

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: O = C.braid_group_orbits()
            sage: len(O)
            3
            sage: [x.profile() for x in O[0]]
            [([1, 1, 1], [3], [3]), ([3], [1, 1, 1], [3]), ([3], [3], [1, 1, 1])]
            sage: [x.profile() for x in O[1]]
            [([2, 1], [2, 1], [3]), ([2, 1], [3], [2, 1]), ([3], [2, 1], [2, 1])]
            sage: [x.profile() for x in O[2]]
            [([3], [3], [3])]
        """
        return [g.vertices() for g in self.braid_group_action()]
