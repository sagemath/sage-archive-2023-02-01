
Присваивание, сравнение и арифметика
======================================

С некоторыми исключениями Sage использует язык программирования Python,
поэтому многие книги, знакомящие с Python, помогут в изучении Sage.

Sage использует ``=`` для присваивания. ``==``, ``<=``, ``>=``, ``<`` и ``>``
используются для сравнения:

::

    sage: a = 5
    sage: a
    5
    sage: 2 == 2
    True
    sage: 2 == 3
    False
    sage: 2 < 3
    True
    sage: a == 5
    True

Sage поддерживает все базовые математические операции:

::

    sage: 2**3    #  ** означает возведение в степень
    8
    sage: 2^3     #  в Sage ^ и ** синонимы (в отличие от Python)
    8
    sage: 10 % 3  #  для целых чисел % означает mod, т.е. взятие остатка
    1
    sage: 10/4
    5/2
    sage: 10//4   #  для целых чисел // означает целочисленное частное
    2
    sage: 4 * (10 // 4) + 10 % 4 == 10
    True
    sage: 3^2*4 + 2%5
    38

Вычисление выражения, такого как ``3^2*4 + 2%5``, производится в соответствии со
старшинством операций, как описано в :ref:`section-precedence`.

Sage также поддерживает многие математические функции:

::

    sage: sqrt(3.4)
    1.84390889145858
    sage: sin(5.135)
    -0.912021158525540
    sage: sin(pi/3)
    1/2*sqrt(3)

Как показывает последний пример, некоторые математические выражения
возвращают 'точные' величины, но не численные приближения. Для того,
чтобы получить численное приближение, используйте функцию ``n`` или
метод ``n`` (оба имеют более длинные названия - ``numerical_approx``;
функция ``N`` - это то же самое, что и ``n``). Они принимают необязательные
аргументы ``prec``, который определяет количество битов точности, и ``digits``,
который определяет количество десятичных цифр точности. По умолчанию,
применяется 53 бита точности.

::

    sage: exp(2)
    e^2
    sage: n(exp(2))
    7.38905609893065
    sage: sqrt(pi).numerical_approx()
    1.77245385090552
    sage: sin(10).n(digits=5)
    -0.54402
    sage: N(sin(10),digits=10)
    -0.5440211109
    sage: numerical_approx(pi, prec=200)
    3.1415926535897932384626433832795028841971693993751058209749

Python имеет динамический контроль типов, так что значение, на
которое ссылается переменная, имеет тип, связанный с ним. Однако,
данная переменная может содержать значение любого типа из языка Python:

::

    sage: a = 5   # a - целое число
    sage: type(a)
    <class 'sage.rings.integer.Integer'>
    sage: a = 5/3  # теперь a - рациональное число
    sage: type(a)
    <class 'sage.rings.rational.Rational'>
    sage: a = 'hello'  # теперь a - строка
    sage: type(a)
    <... 'str'>

Язык C, который имеет статический контроль типов, существенно отличается;
переменная, объявленная как целое число, может содержать только целое число.
