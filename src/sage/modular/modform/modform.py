"""
Modular Forms

TODO:
    - write doctests
    - pickling is broken -- why???

DESIGN NOTES:

The implementation depends the fact that we have dimension formulas
(see dims.py) for spaces of modular forms with character, and new
subspaces, so that we don't have to compute q-expansions for the whole
space in order to compute q-expansions / elements / and dimensions of
certain subspaces.  Also, the following design is much simpler than
the one I used in MAGMA because submodulesq don't have lots of
complicated special labels.  A modular forms module can consist of the
span of any elements; they need not be Hecke equivariant or anything
else.

The internal basis of q-expansions of modular forms for the ambient
space is defined as follows:

  First Block:   Cuspidal Subspace
  Second Block:  Eisenstein Subspace

      Cuspidal Subspace:    Block for each level M dividing N, from highest
                            level to lowest. The block for level M
                            contains the images at level N of the
                            newsubspace of level M (basis, then
                            basis(q**d), then basis(q**e), etc.)

     Eisenstein Subspace:   characters, etc.

Since we can compute dimensions of cuspidal subspaces quickly and
easily, it should be easy to locate any of the above blocks.  Hence,
e.g., to compute basis for new cuspidal subspace, just have to return
first n standard basis vector where n is the dimension.  However, we
can also create completely arbitrary subspaces as well.

The base ring is the ring generated by the character values (or
bigger).  In MAGMA the base was always ZZ, which is confusing.
"""


#*****************************************************************************
#       Copyright (C) 2004--2006 William Stein <wstein@ucsd.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

# system packages
import math
import weakref

# SAGE packages
import sage.rings.arith as arith
import sage.modular.congroup as congroup
import sage.misc.db as db
import sage.modular.dims as dims
import sage.modular.dirichlet as dirichlet
import sage.modular.hecke.all as hecke
import sage.misc.misc as misc
import sage.modular.modsym as modsym
import sage.modules.free_module as free_module
import sage.modules.free_module_element as free_module_element
import sage.rings.all as rings

from sage.misc.all import latex


# The default precision for computation and display of q-expansions of
# modular forms.
DEFAULT_PRECISION = 6


class ModularFormsSpace(hecke.HeckeModule_generic):
    """
    A generic space of modular forms.
    """
    def __init__(self, group, weight, character, base_field):
        if not isinstance(group, congroup.CongruenceSubgroup):
            raise TypeError, "group (=%s) must be a congruence subroup"%group
        weight = int(weight)
        #if not isinstance(weight, int):
        #    raise TypeError, "weight must be an int"
        if not ((character is None) or isinstance(character, dirichlet.DirichletCharacter)):
            raise TypeError, "character must be a Dirichlet character"
        if not isinstance(base_field, rings.Ring):
            raise TypeError, "base_field must be a ring"
        if not base_field.is_field():
            raise ArithmeticError, "base_field must be a field."
        self.__weight, self.__group, self.__character, self.__base_field = \
                      weight, group, character, base_field
        hecke.HeckeModule_generic.__init__(self, base_field, group.level())

    def ambient_space(self):
        raise NotImplementedError   # do not implement this

    def change_ring(self):
        raise NotImplementedError

    def weight(self): return self.__weight

    def group(self): return self.__group

    def character(self): return self.__character

    def base_field(self): return self.__base_field

    def has_character(self): return self.character() != None

    def is_ambient(self): raise NotImplementedError

    def __add__(self, right):
        if self.ambient_space() != right.ambient_space():
            raise ArithmeticError, ("Intersection of %s and %s not defined because they " + \
                                    "do not lie in a common ambient space.")%\
                                   (self, right)
        if self.is_ambient(): return self
        if right.is_ambient(): return right
        V = self.vector_space() + right.vector_space()
        return ModularFormsSubmodule(self.ambient_space(), V)


    def __and__(self, right):
        return self.intersect(right)

    def __call__(self, x, check=True):
        if is_instance(x, ModularForm):
            if x.parent() == self:
                return x
            if not check:
                f = x.copy()
                f.set_parent(self)
                return f
            assert NotImplementedError
        return ModularFormElement(self, x, check=check)

    def __cmp__(self, x):
        if not isinstance(x, ModularFormsSpace):
            return -1
        if self.is_ambient() or x.is_ambient():
            if not (self.is_ambient() and x.is_ambient()): return -1
            if (self.__group, self.__weight, self.__character, self.__base_field) == \
               (x.__group, x.__weight, x.__character, x.__base_field):
                return 0
            else:
                return -1
        if self.vector_space() != x.vector_space():
            return -1
        return 0

    def __contains__(self, x):
        """
        True if x is an element or submodule of self.
        """
        if self.is_ambient() and x.is_ambient():
            return self.key() == x.key()
        raise NotImplementedError

    def __create_newspace(self, basis, level, t, is_cuspidal):
        V = self.vector_space().submodule(basis, check=False)
        S = ModularForms(self.ambient_space(), V)
        S.__newspace_params = {'level':level, 't':t}
        S.__is_cuspidal = is_cuspidal
        S.__is_eisenstein = not is_cuspidal
        return S

    def __newspace_bases(self):
        if hasattr(self, "__newspace_bases_list"):
            return self.__newspace_bases_list
        assert self.is_ambient()
        V = self.vector_space()
        eps, k, N = self.__character, self.__weight, self.__level
        # First the cuspidal new spaces.
        m = eps.conductor()
        levels = [M for M in arith.divisors(N) if M%m==0]
        levels.reverse()
        B = []; i = 0
        for M in levels:
            n = dims.dimension_new_cusp_forms(eps.restrict(M), k)
            for t in arith.divisors(N/M):
                basis = [V.gen(i+j) for j in range(n)]
                print M, basis
                if len(basis) > 0:
                    B.append((M, t, True, basis))
                i += n
        # Now the Eisenstein series
        #x = [0 for _ in range(len(levels))]
        x = {}
        for E in self.eisenstein_series():  # count number of e.s. of each level
            Mt = (E.new_level(), E.t())
            if not x.has_key(Mt):
                x[Mt] = 1
            else:
                x[Mt] += 1
        k = x.keys()
        k.sort()
        k.reverse()
        for M, t in k:
            n = x[(M,t)]
            B.append((M, t, False, [V.gen(i+j) for j in range(n)]))
            i += n
        self.__newspace_bases_list = B
        return self.__newspace_bases_list

    def __submodule_from_subset_of_basis(self, x):
        V = self.vector_space()
        return V.submodule([V.gen(i) for i in x], check=False)

    def basis(self):
        if hasattr(self, "__basis"): return self.__basis
        self.__basis = tuple([ModularFormElement(self, x, check=False) for \
                        x in self.vector_space().basis()])
        return self.__basis

    def gen(self, n):
        return self.basis()[n]

    def gens(self):
        return self.basis()

    def sturm_bound(self, M=None):
        r"""
        For a space M of modular forms, this function returns an integer B
        such that two modular forms in either self or M are equal if and only
        if their q-expansions are equal to precision B.  If M is none, then
        M is set equal to self.

        NOTES:
        Reference for the Sturm bound that we use in the definition of
        of this function:

         J. Sturm, On the congruence of modular forms,
              Number theory (New York, 1984--1985), Springer,
              Berlin, 1987, pp.~275--280.

        Useful Remark:

            Kevin Buzzard pointed out to me (William Stein) in Fall
            2002 that the above bound is fine for Gamma1 with
            character, as one sees by taking a power of $f$.  More
            precisely, if $f\con 0\pmod{p}$ for first $s$
            coefficients, then $f^r = 0 \pmod{p}$ for first $s r$
            coefficents.  Since the weight of $f^r$ is $r
            \text{weight}(f)$, it follows that if $s \geq $ the sturm
            bound for $\Gamma_0$ at weight(f), then $f^r$ has
            valuation large enough to be forced to be $0$ at $r\cdot$
            weight(f) by Sturm bound (which is valid if we choose $r$
            right).  Thus $f \con 0 \pmod{p}$.  Conclusion: For
            $\Gamma_1$ with fixed character, the Sturm bound is
            \emph{exactly} the same as for $\Gamma_0$.  A key point is
            that we are finding $\Z[\eps]$ generators for the Hecke
            algebra here, not $\Z$-generators.  So if one wants
            generators for the Hecke algebra over $\Z$, this bound is
            wrong.

            This bound works over any base, even a finite field.
            There might be much better bounds over $\Q$, or for
            comparing two eigenforms.
        """
        if M != None:
            raise NotImplementedError
        if self.__sturm_bound == None:
            # the +1 below is because O(q^prec) has precision prec.
            self.__sturm_bound = int(\
                math.ceil(self.weight()*dims.idxG0(self.level())/12.0) + 1)
        return self.__sturm_bound

    def character(self):
        return self.__character

    def cuspidal_submodule(self):
        if self.__is_cuspidal == True:
            return self
        if self.__cuspidal_submodule != None:
            return self.__cuspidal_submodule
        if self.is_ambient():
            # By definition the cuspidal submodule of the ambient space
            # is spanned by the first n standard basis vectors, where
            # n is the dimension of the cuspidal submodule.
            n = self.__ambient_cusp_dimension()
            W = self.__submodule_from_subset_of_basis(range(n))
            S = ModularForms(self, W)
            S.__is_cuspidal = True
            S.__is_eisenstein = (n==0)
            self.__cuspidal_submodule = S
            return S
        C = self.ambient_space().cuspidal_submodule()
        S = self.intersect(C)
        if S.dimension() < self.dimension():
            self.__is_cuspidal = False
            self.__cuspidal_submodule = S
        else:
            assert S.dimension() == self.dimension()
            self.__is_cuspidal = True
        S.__is_eisenstein = (S.dimension()==0)

    def decomposition(self):
        """

        This function returns a list of submodules $V(f_i,t)$
        corresponding to newforms $f_i$ of some level dividing the
        level of self, such that the direct sum of the submodules
        equals self, if possible.  The space $V(f_i,t)$ is the image
        under $g(q)$ maps to $g(q^t)$ of the intersection with
        $R[[q]]$ of the space spanned by the conjugates of $f_i$,
        where $R$ is the base ring of self.

        """
        raise NotImplementedError

    def newspaces(self):
        r"""
        This function returns a list of submodules $S(M,t)$ and
        $E(M,t)$, corresponding to levels $M$ dividing $N$ and integers $t$
        dividing $N/M$, such that self is the direct sum of these
        spaces, if possible.  Here $S(M,t)$ is by definition
        the image under $f(q) \mapsto f(q^t)$ of the new submodule of
        cusp forms of level $M$, and similarly $E(M,t)$ is the image of
        Eisenstein series.

        Notes: (1) the submodules $S(M,t)$ need not be stable under
        Hecke operators of index dividing $N/M$.  (2) Since self can
        be an arbitrary submodule, there's no guarantee any $S(M,t)$ or
        $E(M,t)$ is in self, so the return list could be empty.
        """
        V = self.embedded_submodule()
        return [self.__create_newspace(basis=B,level=M,t=t,is_cuspidal=is_cuspidal) \
                for M, t, is_cuspidal, B in self.ambient_space().__newspace_bases() \
                if V.contains_each(B)]


    def eisenstein_submodule(self):
        if self.__is_eisenstein == True:
            return self
        if self.__eisenstein_submodule != None:
            return self.__eisenstein_submodule
        if self.is_ambient():
            # By definition the eisenstein submodule of the ambient space
            # is spanned by the n+1 through n+d standard basis vectors, where
            # n is the dimension of the cuspidal submodule and d
            # is the dimension of the eisenstein submodule (i.e., the
            # number of eisenstein series).
            n = self.__ambient_cusp_dimension()
            d = self.__ambient_eis_dimension()
            W = self.__submodule_from_subset_of_basis(range(n,n+d))
            E = ModularForms(self, W)
            E.__is_eisenstein = True
            E.__is_cuspidal = (d==0)
            self.__eisenstein_submodule = E
            return E
        A = self.ambient_space().eisenstein_submodule()
        E = self.intersect(A)
        if E.dimension() < self.dimension():
            self.__is_eisenstein = False
            self.__eisenstein_submodule = E
        else:
            assert E.dimension() == self.dimension()
            self.__is_eisenstein = True
        E.__is_cuspidal = (E.dimension()==0)

    def embedded_submodule(self):
        if self.is_ambient():
            return self.vector_space()
        return self.__embedded_submodule

    def hecke_matrix(self, n):
        raise NotImplementedError

    def intersect(self, right):
        if self.ambient_space() != right.ambient_space():
            raise ArithmeticError, "Intersection of %s and %s not defined."%\
                                   (self, right)
        V = self.embedded_submodule().intersect(right.embedded_submodule())
        return ModularForms(self.ambient_space(),V)

    def is_ambient(self):
        return self.__ambient == None

    def key(self):
        if self.is_ambient():
            return self.__key
        return self.__ambient

    def level(self):
        return self.group().level()

    def modular_symbols(self):
        raise NotImplementedError


_objsModularForms = {}
class _uniqModularForms(object):
    def __new__(cls, group, weight, base_field=rings.RationalField()):
        key = (weight, group, base_field)
        if _objsModularForms.has_key(key):
            x = _objsModularForms[key]()
            if x != None:
                return x
        R = object.__new__(cls)
        _objsModularForms[key] = weakref.ref(R)
        return R

class ModularForms(_uniqModularForms, ModularFormsSpace):
    """
    An ambient space of modular forms.  Create using the command

        ModularForms(group, weight, character)

    INPUT:
        group -- a congruence subgroup (sage.modular.congroup.CongruenceSubgroup)
        weight -- an integer
        base_field -- a field (default rings.RationalField)
    """

    def __init__(self, group, weight, base_field=rings.RationalField()):
        weight = int(weight)
        if not isinstance(group, congroup.CongruenceSubgroup):
            group = congroup.Gamma0(group)
        if isinstance(group, congroup.Gamma0):
            character = dirichlet.TrivialCharacter(group.level(), base_field)
        else:
            character = None
        ModularFormsSpace.__init__(self, group, weight, character, base_field)

    def __repr__(self):
        #return "Dimension %s ambient space of modular forms of weight %s on %s"%(
        #    self.dimension(), self.weight(), self.group())
        return "Space of modular forms on %s of weight %s and dimension %s over %s"%(
                self.group(), self.weight(), self.dimension(), self.base_field())

    def change_ring(self, F):
        return ModularForms( self.group(), self.weight(), F)

    def dimension(self):
        if hasattr(self, "__dimension"): return self.__dimension
        self.__dimension = self.dim_eisenstein() + self.dim_cuspidal()
        return self.__dimension

    def ambient_space(self):
        return self

    def is_ambient(self):
        return True

    def modular_symbols(self):
        if hasattr(self, "__modsym"): return self.__modsym
        self.__modsym = modsym.ModularSymbols(self.weight(), self.group(),
                                                  self.base_field())
        return self.__modsym

    def vector_space(self):
        if hasattr(self, "__vector_space"): return self.__vector_space
        self.__vector_space = free_module.VectorSpace(self.base_field(),
                                                 self.dimension())
        return self.__vector_space

    def prec(self, set=None):
        """
        Set or get default initial precision for printing modular forms.
        """
        if set == None:
            if hasattr(self, "__prec"): return self.__prec
            self.__prec = DEFAULT_PRECISION
            return self.__prec
        self.__prec = set

    ####################################################################
    # Computation of q-expansions
    ####################################################################
    def qexp(self, vector, prec):
        """
        Compute the $q$-expansion to precision prec of the linear
        combination of the basis for this space given by the vector.
        """
        R = rings.PowerSeriesRing(self.base_field(), name='q')
        return rings.q
        raise NotImplementedError


    ####################################################################
    # Computation of Special Submodules
    ####################################################################

    def cuspidal_submodule(self):
        try:
            return self.__cuspidal_submodule
        except AttributeError:
            n = self.dim_cuspidal()
            V = self.vector_space()
            W = V.submodule([V.gen(i) for i in range(n)])
            self.__cuspidal_submodule = ModularFormsSubmodule(self, W)
        return self.__cuspidal_submodule

    def eisenstein_submodule(self):
        try:
            return self.__eisenstein_submodule
        except AttributeError:
            n = self.dim_cuspidal()
            d = self.dimension()
            V = self.vector_space()
            W = V.submodule([V.gen(i) for i in range(n, d)])
            self.__eisenstein_submodule = ModularFormsSubmodule(self, W)
        return self.__eisenstein_submodule

    def new_submodule(self):
        try:
            return self.__new_submodule
        except AttributeError:
            s = self.dim_new_cuspidal()
            e = self.dim_new_eisenstein()
            d = self.dim_cuspidal()
            B = range(s) + range(d, d+e)
            V = self.vector_space()
            W = V.submodule([V.gen(i) for i in B])
            self.__new_submodule = ModularFormsSubmodule(self, W)
        return self.__new_submodule


    ####################################################################
    # Computations of Dimensions
    ####################################################################
    def dim_cuspidal(self):
        try:
            return self.__the_dim_cuspidal
        except AttributeError:
            self.__the_dim_cuspidal = dims.dimension_cusp_forms(self.group(), self.weight())
        return self.__the_dim_cuspidal

    def dim_eisenstein(self):
        try:
            return self.__the_dim_eisenstein
        except AttributeError:
            if self.weight() == 1:
                self.__the_dim_eisenstein = len(self.eisenstein_params())
            else:
                self.__the_dim_eisenstein = dims.dimension_eis(self.group(), self.weight())
        return self.__the_dim_eisenstein

    def dim_new_cuspidal(self):
        try:
            return self.__the_dim_new_cuspidal
        except AttributeError:
            self.__the_dim_new_cuspidal = dims.dimension_new_cusp_forms_group(
                self.group(), self.weight())
        return self.__the_dim_new_cuspidal

    def dim_new_eisenstein(self):
        try:
            return self.__the_dim_new_eisenstein
        except AttributeError:
            if isinstance(self.group(), congroup.Gamma0) and self.weight() == 2:
                if arith.is_prime(self.level()):
                    d = 1
                else:
                    d = 0
            else:
                E = self.eisenstein_series()
                d = len([g for g in E if g.new_level() == self.level()])
            self.__the_dim_new_eisenstein = d
        return self.__the_dim_new_cuspidal


    ####################################################################
    # Computations of all Eisenstein series in self
    ####################################################################

    def eisenstein_params(self):
        try:
            return self.__eisenstein_params
        except AttributeError:
            eps = self.character()
            if eps == None:
                if isinstance(self.group(), congroup.Gamma1):
                    eps = self.level()
                else:
                    raise NotImplementedError
            params = compute_eisenstein_params(eps, self.weight())
            self.__eisenstein_params = params
        return self.__eisenstein_params

    def eisenstein_series(self):
        try:
            return self.__eisenstein_series
        except AttributeError:
            pass
        time = misc.verbose("Finding eisenstein series.")

        misc.verbose("Finished finding eisenstein series.", time)

        self.__eisenstein_series = []
        c = self.dim_cuspidal()

        V = self.vector_space()
        params = self.eisenstein_params()
        assert V.dimension() - c == len(params)

        for i in range(len(params)):
            chi, psi, t = params[i]
            if chi.base_ring() != self.base_field():
                F = chi.base_ring()
                M = self.change_ring(F)
                v = V.change_ring(F).gen(c+i)
            else:
                M = self
                v = V.gen(c+i)
            E = EisensteinSeries(M, v, t, chi, psi)
            self.__eisenstein_series.append(E)
        return self.__eisenstein_series

_objsModularForms_chars = {}
class _uniqModularForms_chars(object):
    def __new__(cls, character, weight, base_field=None):
        if base_field==None:  base_field=character.base_ring()
        key = (character, weight, base_field)
        if _objsModularForms_chars.has_key(key):
            x = _objsModularForms_chars[key]()
            if x != None:
                return x
        R = object.__new__(cls)
        _objsModularForms_chars[key] = weakref.ref(R)
        return R

class ModularFormsWithCharacter(_uniqModularForms_chars, ModularForms):
    """
    A space of modular forms with character.
    """
    def __init__(self, character, weight, base_field=None):
        """
        weight -- int
        character -- dirichlet.DirichletCharacter
        base_field -- base field
        """
        if base_field==None: base_field=character.base_ring()
        if character.base_ring() != base_field:
            character = character.change_ring(base_field)
        self.__weight, self.__character = weight, character
        group = congroup.Gamma1(character.modulus())
        base_field = character.base_ring()
        ModularFormsSpace.__init__(self, group, weight, character, base_field)

    def __repr__(self):
        return "Space of Modular Forms with character %s, weight %s, and dimension %s over %s"%(
                    self.character(), self.weight(), self.dimension(), self.base_field())

    def change_ring(self, F):
        return ModularFormsWithCharacter(self.weight(), self.character(), F)

    def modular_symbols(self):
        try:
            return self.__modsym
        except AttributeError:
            self.__modsym = modsym.ModularSymbolsWithCharacter(\
                self.character(), self.weight(), self.base_field())
        return self.__modsym

    ####################################################################
    # Computations of Dimensions
    ####################################################################
    def dim_cuspidal(self):
        try:
            return self.__the_dim_cuspidal
        except AttributeError:
            self.__the_dim_cuspidal = dims.dimension_cusp_forms_eps(
                self.character(), self.weight())
        return self.__the_dim_cuspidal

    def dim_eisenstein(self):
        try:
            return self.__the_dim_eisenstein
        except AttributeError:
            if self.character().is_trivial():
                edim = dims.dimension_eis(self.group(), self.weight())
            else:
                # calling self.eisenstein_series() is guaranteed to have the
                # side affect of setting self.__the_dim_eisenstein...
                self.eisenstein_series()  # todo: more direct way?
                edim = len(self.eisenstein_params())
            self.__the_dim_eisenstein = edim
        return self.__the_dim_eisenstein

    def dim_new_cuspidal(self):
        try:
            return self.__the_dim_new_cuspidal
        except AttributeError:
            self.__the_dim_new_cuspidal = dims.dimension_new_cusp_forms(
                self.character(), self.weight())
        return self.__the_dim_new_cuspidal

    def dim_new_eisenstein(self):
        try:
            return self.__the_dim_new_eisenstein
        except AttributeError:
            if self.character().is_trivial() and self.weight() == 2:
                if arith.is_prime(self.level()):
                    d = 1
                else:
                    d = 0
            else:
                E = self.eisenstein_series()
                d = len([g for g in E if g.new_level() == self.level()])
            self.__the_dim_new_eisenstein = d
        return self.__the_dim_new_cuspidal


class ModularFormsSubmodule(ModularFormsSpace):
    """
    A submodule of an ambient space of modular forms.
    """
    def __init__(self, ambient_space, vector_space):
        """
            ambient_space -- ModularFormsSpace
            submodule -- a vector submodule of the underlying vector space of the ambient space.
        """
        self.__ambient_space = ambient_space
        self.__vector_space = vector_space
        A = ambient_space
        ModularFormsSpace.__init__(self, A.group(), A.weight(), A.character(), A.base_field())

    def __repr__(self):
        return "ModularFormsSubmodule(%s,dim=%s)"%(self.ambient_space(), self.dimension())
        #return "Submodule of dimension %s of modular forms of weight %s on %s with character %s."%(
        #    self.dimension(), self.weight(), self.group(), self.character())

    def is_ambient(self):
        return False

    def ambient_space(self):
        return self.__ambient_space

    def change_ring(self):
        raise NotImplementedError, "Base change only currently implemented for ambient spaces."

    def vector_space(self):
        return self.__vector_space

    def dimension(self):
        try:
            return self.__dimension
        except AttributeError:
            self.__dimension = self.vector_space().dimension()
        return self.__dimension



class ModularFormElement:
    """
    An element of a space of modular forms.
    """
    def __init__(self, parent, vector, check=True):
        """
        INPUT:
            parent -- ModularForms (an ambient space of modular forms)
            vector -- a vector on the basis for parent
        OUTPUT:
            ModularFormElement -- a modular form

        EXAMPLES:
            sage: M = ModularForms(Gamma0(11),2)
            sage: f = M.0
            sage: f.parent()
            Space of modular forms on Congruence Subgroup Gamma0(11) of weight 2 and dimension 2 over Rational Field
        """

        if not isinstance(parent, ModularForms):
            raise TypeError, "First argument must be an ambient space of modular forms."
        self.__parent = parent
        if not isinstance(vector, free_module_element.FreeModuleElement):
            raise TypeError, "Second argument must be a vector."
        self.__vector = vector
        if not vector in parent.vector_space():
            raise ArithmeticError, "Vector must be an element of the " +\
                      " vector space of the ambient space."

    def __ensure_is_compatible(self, other):
        if not isinstance(other, ModularFormElement):
            raise TypeError, "Second argument must be a modular form."
        if self.ambient_space() != other.ambient_space():
            raise ArithmeticError, "Modular forms must be in the same ambient space."

    def __add__(self, other):
        self.__ensure_is_compatible(other)
        return ModularFormElement(self.ambient_space(), self.vector() + other.vector())

    def __radd__(self, left):
        return self+left

    def __cmp__(self, other):
        self.__ensure_is_compatible(other)
        return self.__vector == other.__vector

    def coefficients(self, X):
        """
        The coefficients a_n of self, for integers n>=0 in the list X.

        This function caches the results of the compute function.
        """
        try:
            self.__coefficients
        except AttributeError:
            self.__coefficients = {}
        Y = [n for n in X   if    not (n in self.__coefficients.keys())]
        v = self.compute(Y)
        for i in range(len(v)):
            self.__coefficients[X[i]] = v[i]
        return v

    def compute(self, X):
        """
        Compute the coefficients a_n of self, for integers n>=0 in the list X.
        The results need not be cached; use the coefficients method instead
        for cached results.
        """
        return self.__parent.compute_coefficients(self.__vector, X)

    def __getitem__(self, n):
        return self.coefficients([n])[0]

    def __getslice__(self, i, j):
        return self.coefficients(range(i,j))

    def __neg__(self):
        return (-1)*self

    def __pos__(self):
        return self

    def __repr__(self):
        return str(self.qexp())

    def _latex_(self):
        return latex(self.qexp())

    def __sub__(self, right):
        return self + (-right)

    def __rsub__(self, left):
        raise TypeError

    def base_field(self):
        return self.parent().base_field()

    def character(self):
        chi = self.parent().character()
        if chi == None:
            raise NotImplementedError, "Determination of character in this " + \
                  "case not implemented yet."
        return chi

    def is_zero(self):
        return self.vector().is_zero()

    def level(self):
        return self.parent().level()

    def parent(self):
        return self.__parent

    def prec(self):
        try:
            self.__qexp
        except AttributeError:
            return self.parent().prec()
        return self.__qexp.prec()

    def qexp(self, prec=None):
        r"""
        The $q$-expansion of the modular form to precision $O(q^\text{prec})$.
        This function takes one argument, which is the integer prec.
        """
        if prec == None: prec = self.parent().prec()

        R = rings.PowerSeriesRing(self.base_field(), name='q')
        q = R.gen(0)

        try:
            self.__qexp
        except AttributeError:
            self.__qexp = R(0, prec=0)

        pr = self.__qexp.prec()
        if prec > pr:
            v = self.compute(range(pr,prec))
            self.__qexp = R(list(self.__qexp) + v, prec=prec)

        return self.__qexp.O(prec)

    def weight(self):
        return self.parent().weight()

    def valuation(self):
        if self.__valuation != None:
            return self.__valuation
        v = self.qexp().valuation()
        if v != rings.infinity:
            self.__valuation = v
            return v
        v = self.qexp(self.parent().sturm_bound()).valuation()
        self.__valuation = v
        return v


class EisensteinSeries(ModularFormElement):
    def __init__(self, parent, vector, t, chi, psi):
        N = parent.level()
        K = parent.base_field()
        if chi.parent().modulus() != N or psi.parent().modulus() != N:
            raise ArithmeticError, "Incompatible moduli"
        if chi.parent().base_ring() != K or psi.parent().base_ring() != K:
            raise ArithmeticError, "Incompatible base rings"
        t = int(t)
        #if not isinstance(t, int): raise TypeError, "weight must be an int"
        if parent.weight() == 2 and chi.is_trivial() \
               and psi.is_trivial() and t==1:
            raise ArithmeticError, "If chi and psi are trivial and k=2, then t must be >1."
        ModularFormElement.__init__(self, parent, vector)
        self.__chi = chi
        self.__psi = psi
        self.__t   = t

    def compute(self, X):
        """
        Compute the coefficients of $q^n$ of the power series of self,
        for $n$ in the list $X$.  The results are not cached.  (Use
        coefficients for cached results).
        """
        if self.weight() == 2 and (self.__chi.is_trivial() and self.__psi.is_trivial()):
            return self.__compute_weight2_trivial_character(X)
        else: # general case
            return self.__compute_general_case(X)

    def __compute_weight2_trivial_character(self, X):
        """
        Compute E_2 - t*E_2(q^t)
        """
        F = self.base_field()
        v = []
        t = self.__t
        for n in X:
            if n <= 0:
                v.append(F(t-1)/F(24))
            else:
                an = arith.sigma(n,1)
                if n%t==0:
                    an -= t*arith.sigma(n/t,1)
                v.append(an)
        return v


    def __compute_general_case(self, X):
        """
        General case (except weight 2, trivial character, where this is wrong!)
        $\chi$ is a primitive character of conductor $L$
        $\psi$ is a primitive character of conductor $M$
        We have $MLt \mid N$, and
        $$
          E_k(chi,psi,t) =
           c_0 + sum_{m \geq 1}[sum_{n|m}psi(n)n^{k-1}chi(m/n)] q^{mt},
        $$
        with $c_0=0$ if $L>1$,
         and
        $c_0=L(1-k,psi)/2$ if $L=1$ (that second $L$ is an $L$-function $L$).
        """
        c0, chi, psi, K, n, t, L, M = self.__defining_parameters()
        zero = K(0)
        k = self.weight()
        v = [c0]
        for i in X:
            if i==0: continue
            if i%t != 0:
                v.append(zero)
            else:
                m = i/t
                v.append(sum([psi(n)*chi(m/n)*n**(k-1) for n in arith.divisors(m)]))
        return v

    def __defining_parameters(self):
        try:
            return self.__defining_params
        except AttributeError:
            k = self.weight()
            chi = self.__chi.minimize_base_ring()
            psi = self.__psi.minimize_base_ring()
            n = arith.LCM(chi.base_ring().zeta().multiplicative_order(),\
                          psi.base_ring().zeta().multiplicative_order())
            K = rings.CyclotomicField(n)
            chi = chi.change_ring(K)
            psi = psi.change_ring(K)
            t = self.__t
            L = chi.conductor()
            M = psi.conductor()
            if L == 1:
                c0 = K(-psi.bernoulli(k))/K(2*k)
            else:
                c0 = K(0)
            self.__defining_params = (c0, chi, psi, K, n, t, L, M)
        return self.__defining_params

    def chi(self):
        return self.__chi

    def psi(self):
        return self.__psi

    def t(self):
        return self.__t

    def L(self):
        return self.__chi.conductor()

    def M(self):
        return self.__psi.conductor()

    def character(self):
        try:
            return self.__character
        except AttributeError:
            self.__character = self.__chi * (~self.__psi)
        return self.__character

    def level_at_which_new(self):
        if self.__chi.is_trivial() and self.__psi.is_trivial() and self.weight() == 2:
            return arith.factor(self.__t)[0][0]
        return self.L()*self.M()


def __find_eisen_chars(character, k):
    N = character.modulus()
    if character.is_trivial():
        V = [(character, character, t) for t in arith.divisors(N) if t>1]
        if k != 2:
            V.insert(0,(character, character, 1))
        return V

    eps = character
    if eps(-1) != (-1)**k:
        return []
    eps = eps.maximize_base_ring()
    G = eps.parent()

    # Find all pairs chi, psi such that:
    #
    #  (1) cond(chi)*cond(psi) divides the level, and
    #
    #  (2) chi == eps*psi, where eps is the nebentypus character of self.
    #
    # See [Miyake, Modular Forms] Lemma 7.1.1.

    K = G.base_ring()
    C = {}

    t0 = misc.cputime()

    for e in G:
        m = rings.Integer(e.conductor())
        if C.has_key(m):
            C[m].append(e)
        else:
            C[m] = [e]

    misc.verbose("Enumeration with conductors.",t0)

    params = []
    for L in arith.divisors(N):
        misc.verbose("divisor %s"%L)
        if not C.has_key(L):
            continue
        GL = C[L]
        for R in arith.divisors(N/L):
            if not C.has_key(R):
                continue
            GR = C[R]
            for chi in GL:
                for psi in GR:
                    if chi == eps*psi:
                        for t in arith.divisors(N/(R*L)):
                            params.append( (chi,psi,t) )
    return params


def __find_eisen_chars_gamma1(N, k):
    pairs = []
    s = (-1)**k
    G = dirichlet.DirichletGroup(N)
    E = list(G)
    parity = [c(-1) for c in E]
    for i in range(len(E)):
        for j in range(i,len(E)):
            if parity[i]*parity[j] == s and N % (E[i].conductor()*E[j].conductor()) == 0:
                pairs.append((E[i],E[j]))
                if i!=j: pairs.append((E[j],E[i]))
        #endfors
    #end if

    triples = []
    D = arith.divisors(N)
    for chi, psi in pairs:
        c_chi = chi.conductor()
        c_psi = psi.conductor()
        D = arith.divisors(N/(c_chi * c_psi))
        if (k==2 and chi.is_trivial() and psi.is_trivial()):
            D.remove(1)
        for t in D:
            triples.append((chi, psi, t))
    return triples



def compute_eisenstein_params(character, k):
    """
    Compute and return a list of all parameters $(\chi,\psi,t)$ that
    define the Eisenstein series with given character and weight $k$.

    Only the parity of $k$ is relevant.

    If character is an integer $N$, then the parameters for
    $\Gamma_1(N)$ are computed instead.  Then the condition is that
    $\chi(-1)*\psi(-1) =(-1)^k$.
    """

    if isinstance(character, (int,long)):
        N = character
        character = None
    else:
        N = character.modulus()

    if character != None:
        return __find_eisen_chars(character, k)
    else:
        return __find_eisen_chars_gamma1(N, k)
