r"""
Permutation groups

A permutation group is a finite group `G` whose elements are
permutations of a given finite set `X` (i.e., bijections
`X \longrightarrow X`) and whose group operation is the composition of
permutations. The number of elements of `X` is called the degree of `G`.

In Sage, a permutation is represented as either a string that
defines a permutation using disjoint cycle notation, or a list of
tuples, which represent disjoint cycles. That is::

    (a,...,b)(c,...,d)...(e,...,f)  <--> [(a,...,b), (c,...,d),..., (e,...,f)]
                      () = identity <--> []

You can make the "named" permutation groups (see
``permgp_named.py``) and use the following
constructions:

- permutation group generated by elements,
- ``direct_product_permgroups``, which takes a list of permutation
  groups and returns their direct product.

JOKE: Q: What's hot, chunky, and acts on a polygon? A: Dihedral
soup. Renteln, P. and Dundes, A. "Foolproof: A Sampling of
Mathematical Folk Humor." Notices Amer. Math. Soc. 52, 24-34,
2005.

AUTHORS:

- David Joyner (2005-10-14): first version

- David Joyner (2005-11-17)

- William Stein (2005-11-26): rewrite to better wrap Gap

- David Joyner (2005-12-21)

- William Stein and David Joyner (2006-01-04): added conjugacy_class_representatives

- David Joyner (2006-03): reorganization into subdirectory perm_gps;
  added __contains__, has_element; fixed _cmp_; added subgroup
  class+methods, PGL,PSL,PSp, PSU classes,

- David Joyner (2006-06): added PGU, functionality to SymmetricGroup,
  AlternatingGroup, direct_product_permgroups

- David Joyner (2006-08): added degree,
  ramification_module_decomposition_modular_curve and
  ramification_module_decomposition_hurwitz_curve methods to PSL(2,q),
  MathieuGroup, is_isomorphic

- Bobby Moretti (2006)-10): Added KleinFourGroup, fixed bug in DihedralGroup

- David Joyner (2006-10): added is_subgroup (fixing a bug found by
  Kiran Kedlaya), is_solvable, normalizer, is_normal_subgroup, Suzuki

- David Kohel (2007-02): fixed __contains__ to not enumerate group
  elements, following the convention for __call__

- David Harvey, Mike Hansen, Nick Alexander, William Stein
  (2007-02,03,04,05): Various patches

- Nathan Dunfield (2007-05): added orbits

- David Joyner (2007-06): added subgroup method (suggested by David
  Kohel), composition_series, lower_central_series,
  upper_central_series, cayley_table, quotient_group, sylow_subgroup,
  is_cyclic, homology, homology_part, cohomology, cohomology_part,
  poincare_series, molien_series, is_simple, is_monomial,
  is_supersolvable, is_nilpotent, is_perfect, is_polycyclic,
  is_elementary_abelian, is_pgroup, gens_small,
  isomorphism_type_info_simple_group. moved all the"named"
  groups to a new file.

- Nick Alexander (2007-07): move is_isomorphic to isomorphism_to, add
  from_gap_list

- William Stein (2007-07): put is_isomorphic back (and make it better)

- David Joyner (2007-08): fixed bugs in composition_series,
  upper/lower_central_series, derived_series,

- David Joyner (2008-06): modified is_normal (reported by
  W. J. Palenstijn), and added normalizes

- David Joyner (2008-08): Added example to docstring of cohomology.

- Simon King (2009-04): __cmp__ methods for PermutationGroup_generic and PermutationGroup_subgroup

- Nicolas Borie (2009): Added orbit, transversals, stabiliser and strong_generating_system methods

REFERENCES:

- Cameron, P., Permutation Groups. New York: Cambridge University
  Press, 1999.

- Wielandt, H., Finite Permutation Groups.  New York: Academic Press,
  1964.

- Dixon, J. and Mortimer, B., Permutation Groups, Springer-Verlag,
  Berlin/New York, 1996.

.. note::

   Though Suzuki groups are okay, Ree groups should *not* be wrapped
   as permutation groups - the construction is too slow - unless (for
   small values or the parameter) they are made using explicit
   generators.

"""

#*****************************************************************************
#       Copyright (C) 2006 William Stein <wstein@gmail.com>
#                          David Joyner <wdjoyner@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.misc.randstate import current_randstate
import sage.groups.group as group

from sage.rings.all      import RationalField, Integer
from sage.interfaces.all import is_ExpectElement
from sage.interfaces.gap import gap, is_GapElement, GapElement
from sage.groups.perm_gps.permgroup_element import PermutationGroupElement
import sage.structure.coerce as coerce
from sage.rings.finite_field import FiniteField as GF
from sage.groups.abelian_gps.abelian_group import AbelianGroup
from sage.misc.functional import is_even, log
from sage.rings.rational_field import RationalField
from sage.matrix.matrix_space import MatrixSpace
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.fraction_field import FractionField
from sage.misc.cachefunc import cached_method
from sage.groups.class_function import ClassFunction
from sage.misc.package import is_package_installed

def load_hap():
     """
     Load the GAP hap package into the default GAP interpreter
     interface. If this fails, try one more time to load it.

     EXAMPLES::

         sage: sage.groups.perm_gps.permgroup.load_hap()
     """
     try:
         gap.eval('LoadPackage("hap")')
     except:
         gap.eval('LoadPackage("hap")')

def direct_product_permgroups(P):
    """
    Takes the direct product of the permutation groups listed in ``P``.

    EXAMPLES::

        sage: G1 = AlternatingGroup([1,2,4,5])
        sage: G2 = AlternatingGroup([3,4,6,7])
        sage: D = direct_product_permgroups([G1,G2,G1])
        sage: D.order()
        1728
        sage: D = direct_product_permgroups([G1])
        sage: D==G1
        True
        sage: direct_product_permgroups([])
        Symmetric group of order 1! as a permutation group
    """
    from permgroup_named import SymmetricGroup
    n = len(P)
    if n == 0:
        return SymmetricGroup(1)
    if n == 1:
        return P[0]
    G = [H._gap_init_() for H in P]
    Glist = ""
    for H in G:
        Glist = Glist + H + ","
    cmd = "G:=DirectProduct([" + Glist[:-1] + "])"
    gap.eval(cmd)
    return PermutationGroup(gap_group=gap.eval("G"))

def from_gap_list(G, src):
    r"""
    Convert a string giving a list of GAP permutations into a list of
    elements of ``G``.

    EXAMPLES::

        sage: from sage.groups.perm_gps.permgroup import from_gap_list
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: L = from_gap_list(G, "[(1,2,3)(4,5), (3,4)]"); L
        [(1,2,3)(4,5), (3,4)]
        sage: L[0].parent() is G
        True
        sage: L[1].parent() is G
        True
    """
    # trim away the list constructs
    src = src.replace("[", "").replace("]", "")
    # cut out the individual elements
    srcs = src.split("),")
    for i in range(len(srcs[:-1])):
        srcs[i] = srcs[i] + ")"
    srcs = map(G, srcs)
    return srcs

def PermutationGroup(gens=None, gap_group=None, canonicalize=True):
    """
    Return the permutation group associated to `x` (typically a
    list of generators).

    INPUT:


    -  ``gens`` - list of generators (default: ``None``)

    -  ``gap_group`` - a gap permutation group (default: ``None``)

    -  ``canonicalize`` - bool (default: ``True``); if ``True``,
       sort generators and remove duplicates


    OUTPUT:

    - A permutation group.

    EXAMPLES::

        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: G
        Permutation Group with generators [(3,4), (1,2,3)(4,5)]

    We can also make permutation groups from PARI groups::

        sage: H = pari('x^4 - 2*x^3 - 2*x + 1').polgalois()
        sage: G = PariGroup(H, 4); G
        PARI group [8, -1, 3, "D(4)"] of degree 4
        sage: H = PermutationGroup(G); H          # optional - database_gap
        Transitive group number 3 of degree 4
        sage: H.gens()                            # optional - database_gap
        [(1,2,3,4), (1,3)]

    We can also create permutation groups whose generators are Gap
    permutation objects::

        sage: p = gap('(1,2)(3,7)(4,6)(5,8)'); p
        (1,2)(3,7)(4,6)(5,8)
        sage: PermutationGroup([p])
        Permutation Group with generators [(1,2)(3,7)(4,6)(5,8)]

    There is an underlying gap object that implements each
    permutation group::

        sage: G = PermutationGroup([[(1,2,3,4)]])
        sage: G._gap_()
        Group( [ (1,2,3,4) ] )
        sage: gap(G)
        Group( [ (1,2,3,4) ] )
        sage: gap(G) is G._gap_()
        True
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: current_randstate().set_seed_gap()
        sage: G._gap_().DerivedSeries()
        [ Group( [ (3,4), (1,2,3)(4,5) ] ), Group( [ (1,5)(3,4), (1,5)(2,4), (1,5,3) ] ) ]

    TESTS::

        sage: PermutationGroup(SymmetricGroup(5))
        Traceback (most recent call last):
        ...
        TypeError: gens must be a tuple, list, or GapElement
    """
    if not is_ExpectElement(gens) and hasattr(gens, '_permgroup_'):
        return gens._permgroup_()
    if gens is not None and not isinstance(gens, (tuple,list, GapElement)):
        raise TypeError, "gens must be a tuple, list, or GapElement"
    return PermutationGroup_generic(gens=gens, gap_group=gap_group, canonicalize=canonicalize)


class PermutationGroup_generic(group.FiniteGroup):
    """
    EXAMPLES::

        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: G
        Permutation Group with generators [(3,4), (1,2,3)(4,5)]
        sage: G.center()
        Permutation Group with generators [()]
        sage: G.group_id()          # optional - database_gap
        [120, 34]
        sage: n = G.order(); n
        120
        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
        sage: loads(G.dumps()) == G
        True
    """
    def __init__(self, gens=None, gap_group=None, canonicalize=True):
        r"""
        INPUT:


        -  ``gens`` - list of generators (default: ``None``)

        -  ``gap_group`` - a gap permutation group (default: ``None``)

        -  ``canonicalize`` - bool (default: ``True``); if ``True``,
           sort generators and remove duplicates


        OUTPUT:

        - A permutation group.

        EXAMPLES:

        We explicitly construct the alternating group on four
        elements::

            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: A4.__init__([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: A4.center()
            Permutation Group with generators [()]
            sage: loads(A4.dumps()) == A4
            True
        """
        if (gens is None and gap_group is None):
            raise ValueError, "you must specify gens or gap_group"

        #Handle the case where only the GAP group is specified.
        if gens is None:
            self._gap_string = gap_group if isinstance(gap_group, str) else str(gap_group)
            self._gens = self._gens_from_gap()
            return

        gens = [self._element_class()(x, check=False).list() for x in gens]
        self._deg = max([1]+[max(g) for g in gens])
        gens = [self._element_class()(x, self, check=False) for x in gens]
        if not gens:  # length 0
             gens = [()]
        if canonicalize:
             gens = list(set(gens))
             gens.sort()
        self._gens = gens
        self._gap_string = 'Group(%s)'%gens

    def _gens_from_gap(self):
        """
        Returns the generators of the group by asking GAP for them.

        EXAMPLES::

            sage: S = SymmetricGroup(3)
            sage: S._gap_string
            'SymmetricGroup(3)'
            sage: S._gens_from_gap()
            [(1,2,3), (1,2)]
        """
        try:
            gens = self._gap_().GeneratorsOfGroup()
        except TypeError, s:
            raise RuntimeError, "(It might be necessary to install the database_gap optional Sage package, if you haven't already.)\n%s"%s
        gens = [self._element_class()(gens[n],self, check=False)
                       for n in range(1, int(gens.Length())+1)]
        if gens == []:
            gens = [()]
        return gens


    def _gap_init_(self):
        r"""
        Returns a string showing how to declare / initialize ``self`` in Gap.
        Stored in the ``self._gap_string`` attribute.

        EXAMPLES:

        The ``_gap_init_`` method shows how you
        would define the Sage ``PermutationGroup_generic``
        object in Gap::

            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: A4._gap_init_()
            'Group([(2,3,4), (1,2,3)])'
        """
        return self._gap_string

    def _magma_init_(self, magma):
        r"""
        Returns a string showing how to declare / initialize self in Magma.

        EXAMPLES:

        We explicitly construct the alternating group on four
        elements. In Magma, one would type the string below to construct
        the group::

            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: A4._magma_init_(magma)
            'PermutationGroup<4 | (2,3,4), (1,2,3)>'
        """
        g = str(self.gens())[1:-1]
        return 'PermutationGroup<%s | %s>'%(self.degree(), g)

    def __cmp__(self, right):
        """
        Compare ``self`` and ``right``.

        The comparison extends the subgroup relation. Hence, it is first checked
        whether one of the groups is subgroup of the other. If this is not the
        case then the ordering is whatever it is in Gap.

        NOTE:
            The comparison does not provide a total ordering, as can be seen
            in the examples below.

        EXAMPLES::

            sage: G1 = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G2 = PermutationGroup([[(1,2,3),(4,5)]])
            sage: G1 > G2 # since G2 is a subgroup of G1
            True
            sage: G1 < G2
            False

        The following example shows that the comparison does not yield a total
        ordering::

            sage: H1 = PermutationGroup([[(1,2)],[(5,6)]])
            sage: H2 = PermutationGroup([[(3,4)]])
            sage: H3 = PermutationGroup([[(1,2)]])
            sage: H1 < H2 # according to Gap's ordering
            True
            sage: H2 < H3 # according to Gap's ordering
            True
            sage: H3 < H1 # since H3 is a subgroup of H1
            True

        """
        if not isinstance(right, PermutationGroup_generic):
            return -1
        if self is right:
            return 0
        gSelf = self._gap_()
        gRight = right._gap_()
        gapcmp = gSelf.__cmp__(gRight)
        if not gapcmp:
            return 0
        if gSelf.IsSubgroup(gRight):
            return 1
        if gRight.IsSubgroup(gSelf):
            return -1
        return gapcmp

    def _element_class(self):
        r"""
        Return the class to be used for creating elements of this group. By
        default this is
        ``sage.groups.perm_gps.permgroup_element.PermutationGroupElement``, but
        it may be overridden in derived subclasses (most importantly
        ``sage.rings.number_field.galois_group.GaloisGroup_v2``).

        EXAMPLE::

            sage: SymmetricGroup(17)._element_class()
            <type 'sage.groups.perm_gps.permgroup_element.PermutationGroupElement'>
        """
        return PermutationGroupElement

    def __call__(self, x, check=True):
        """
        Coerce ``x`` into this permutation group.

        The input can be either a string that defines a permutation in
        cycle notation, a permutation group element, a list of integers
        that gives the permutation as a mapping, a list of tuples, or the
        integer 1.

        EXAMPLES:

        We illustrate each way to make a permutation in `S_4`::

            sage: G = SymmetricGroup(4)
            sage: G((1,2,3,4))
            (1,2,3,4)
            sage: G([(1,2),(3,4)])
            (1,2)(3,4)
            sage: G('(1,2)(3,4)')
            (1,2)(3,4)
            sage: G('(1,2)(3)(4)')
            (1,2)
            sage: G(((1,2,3),(4,)))
            (1,2,3)
            sage: G(((1,2,3,4),))
            (1,2,3,4)
            sage: G([1,2,4,3])
            (3,4)
            sage: G([2,3,4,1])
            (1,2,3,4)
            sage: G(G((1,2,3,4)))
            (1,2,3,4)
            sage: G(1)
            ()

        Some more examples::

            sage: G = PermutationGroup([(1,2,3,4)])
            sage: G([(1,3), (2,4)])
            (1,3)(2,4)
            sage: G(G.0^3)
            (1,4,3,2)
            sage: G(1)
            ()
            sage: G((1,4,3,2))
            (1,4,3,2)
            sage: G([(1,2)])
            Traceback (most recent call last):
            ...
            TypeError: permutation (1, 2) not in Permutation Group with generators [(1,2,3,4)]
        """
        try:
            if x.parent() is self:
                return x
        except AttributeError:
            pass

        if isinstance(x, (int, long, Integer)) and x == 1:
            return self.identity()

        return self._element_class()(x, self, check=check)

    def _coerce_impl(self, x):
        r"""
        Implicit coercion of ``x`` into ``self``.

        EXAMPLES:

        We illustrate some arithmetic that involves implicit
        coercion of elements in different permutation groups::

            sage: g1 = PermutationGroupElement([(1,2),(3,4,5)])
            sage: g1.parent()
            Symmetric group of order 5! as a permutation group
            sage: g2 = PermutationGroupElement([(1,2)])
            sage: g2.parent()
            Symmetric group of order 2! as a permutation group
            sage: g1*g2
            (3,4,5)
            sage: g2*g2
            ()
            sage: g2*g1
            (3,4,5)

        We try to implicitly coerce in a non-permutation, which raises a
        TypeError::

            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])
            sage: G._coerce_impl(1)
            Traceback (most recent call last):
            ...
            TypeError: no implicit coercion of element into permutation group
        """
        from permgroup_named import SymmetricGroup
        if isinstance(x, PermutationGroupElement):
            x_parent = x.parent()
            if x_parent is self:
                return x
            elif (x_parent.degree() <= self.degree() and
                  (self.__class__ == SymmetricGroup or x._gap_() in self._gap_())):
                return self._element_class()(x.list(), self, check = False)
        raise TypeError, "no implicit coercion of element into permutation group"

    @cached_method
    def list(self):
        """
        Return list of all elements of this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])
            sage: G.list()
            [(), (3,4), (2,3), (2,3,4), (2,4,3), (2,4), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4), (1,2,4,3), (1,2,4), (1,3,2), (1,3,4,2), (1,3), (1,3,4), (1,3)(2,4), (1,3,2,4), (1,4,3,2), (1,4,2), (1,4,3), (1,4), (1,4,2,3), (1,4)(2,3)]
        """
        X = self._gap_().Elements()
        n = X.Length()
        L = [self._element_class()(X[i], self, check = False)
                            for i in range(1,n+1)]
        return L

    def __contains__(self, item):
        """
        Returns boolean value of ``item in self``.

        EXAMPLES::

            sage: G = SymmetricGroup(16)
            sage: g = G.gen(0)
            sage: h = G.gen(1)
            sage: g^7*h*g*h in G
            True
            sage: G = SymmetricGroup(4)
            sage: g = G((1,2,3,4))
            sage: h = G((1,2))
            sage: H = PermutationGroup([[(1,2,3,4)], [(1,2),(3,4)]])
            sage: g in H
            True
            sage: h in H
            False
        """
        try:
            item = self(item, check=True)
        except:
            return False
        return True


    def has_element(self, item):
        """
        Returns boolean value of ``item in self`` - however *ignores*
        parentage.

        EXAMPLES::

            sage: G = CyclicPermutationGroup(4)
            sage: gens = G.gens()
            sage: H = DihedralGroup(4)
            sage: g = G([(1,2,3,4)]); g
            (1,2,3,4)
            sage: G.has_element(g)
            True
            sage: h = H([(1,2),(3,4)]); h
            (1,2)(3,4)
            sage: G.has_element(h)
            False
        """
        return item in self

    def __iter__(self):
        """
        Return an iterator over the elements of this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3)], [(1,2)]])
            sage: [a for a in G]
            [(), (2,3), (1,2), (1,2,3), (1,3,2), (1,3)]
        """
        return iter(self.list())

    def gens(self):
        """
        Return tuple of generators of this group. These need not be
        minimal, as they are the generators used in defining this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3)], [(1,2)]])
            sage: G.gens()
            [(1,2), (1,2,3)]

        Note that the generators need not be minimal, though duplicates are
        removed::

            sage: G = PermutationGroup([[(1,2)], [(1,3)], [(2,3)], [(1,2)]])
            sage: G.gens()
            [(2,3), (1,2), (1,3)]

        We can use index notation to access the generators returned by
        ``self.gens``::

            sage: G = PermutationGroup([[(1,2,3,4), (5,6)], [(1,2)]])
            sage: g = G.gens()
            sage: g[0]
            (1,2)
            sage: g[1]
            (1,2,3,4)(5,6)

        TESTS:

        We make sure that the trivial group gets handled correctly::

            sage: SymmetricGroup(1).gens()
            [()]
        """
        return self._gens


    def gens_small(self):
        """
        For this group, returns a generating set which has few elements.
        As neither irredundancy nor minimal length is proven, it is fast.

        EXAMPLES::

            sage: R = "(25,27,32,30)(26,29,31,28)( 3,38,43,19)( 5,36,45,21)( 8,33,48,24)" ## R = right
            sage: U = "( 1, 3, 8, 6)( 2, 5, 7, 4)( 9,33,25,17)(10,34,26,18)(11,35,27,19)" ## U = top
            sage: L = "( 9,11,16,14)(10,13,15,12)( 1,17,41,40)( 4,20,44,37)( 6,22,46,35)" ## L = left
            sage: F = "(17,19,24,22)(18,21,23,20)( 6,25,43,16)( 7,28,42,13)( 8,30,41,11)" ## F = front
            sage: B = "(33,35,40,38)(34,37,39,36)( 3, 9,46,32)( 2,12,47,29)( 1,14,48,27)" ## B = back or rear
            sage: D = "(41,43,48,46)(42,45,47,44)(14,22,30,38)(15,23,31,39)(16,24,32,40)" ## D = down or bottom
            sage: G = PermutationGroup([R,L,U,F,B,D])
            sage: len(G.gens_small())
            2
        """
        gens = self._gap_().SmallGeneratingSet()
        return [self._element_class()(x, self, check=False) for x in gens]

    def gen(self, i):
        r"""
        Returns the i-th generator of ``self``; that is, the i-th element
        of the list ``self.gens()``.

        EXAMPLES:

        We explicitly construct the alternating group on four
        elements::

            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: A4.gens()
            [(2,3,4), (1,2,3)]
            sage: A4.gen(0)
            (2,3,4)
            sage: A4.gen(1)
            (1,2,3)
            sage: A4.gens()[0]; A4.gens()[1]
            (2,3,4)
            (1,2,3)
        """
        return self.gens()[i]

    def cayley_table(self, names="x"):
        """
        Returns the multiplication table, or Cayley table, of the finite
        group `G` in the form of a matrix with symbolic coefficients. This
        function is useful for learning, teaching, and exploring elementary
        group theory. Of course, `G` must be a group of low order.

        EXAMPLES:

        As the last line below illustrates, the ordering used here in the
        first row is the same as in ``G.list()``::

            sage: G = PermutationGroup(['(1,2,3)', '(2,3)'])
            sage: G.cayley_table()
            [x0 x1 x2 x3 x4 x5]
            [x1 x0 x3 x2 x5 x4]
            [x2 x4 x0 x5 x1 x3]
            [x3 x5 x1 x4 x0 x2]
            [x4 x2 x5 x0 x3 x1]
            [x5 x3 x4 x1 x2 x0]
            sage: G.list()[3]*G.list()[3] == G.list()[4]
            True
            sage: G.cayley_table("y")
            [y0 y1 y2 y3 y4 y5]
            [y1 y0 y3 y2 y5 y4]
            [y2 y4 y0 y5 y1 y3]
            [y3 y5 y1 y4 y0 y2]
            [y4 y2 y5 y0 y3 y1]
            [y5 y3 y4 y1 y2 y0]
            sage: G.cayley_table(names="abcdef")
            [a b c d e f]
            [b a d c f e]
            [c e a f b d]
            [d f b e a c]
            [e c f a d b]
            [f d e b c a]
        """
        G = self
        n = G.order()
        phi = G._gap_().RegularActionHomomorphism()
        gens = phi.Image().GeneratorsOfGroup()
        N = Integer(gens.Length())
        nm = gens.name()
        gens = [self._element_class()(gap.eval("%s[%s];"%(nm, i))) for i in range(1,N+1)]
        H = PermutationGroup(gens)
        nH = H.order()
        R,vars = PolynomialRing(RationalField(),names,nH).objgens()
        multiplication_table_G = sum([(H.list()[i]).matrix()*vars[i] for i in range(nH)])
        MT = multiplication_table_G.rows()
        MT.sort()
        MT.reverse()
        MS = MatrixSpace(R,n,n)
        return MS(MT)

    multiplication_table = cayley_table

    def identity(self):
        """
        Return the identity element of this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3),(4,5)]])
            sage: e = G.identity()
            sage: e
            ()
            sage: g = G.gen(0)
            sage: g*e
            (1,2,3)(4,5)
            sage: e*g
            (1,2,3)(4,5)
        """
        return self._element_class()([], self, check=True)

    def exponent(self):
        """
        Computes the exponent of the group. The exponent `e` of a
        group `G` is the LCM of the orders of its elements, that
        is, `e` is the smallest integer such that `g^e=1`
        for all `g \in G`.

        EXAMPLES::

            sage: G = AlternatingGroup(4)
            sage: G.exponent()
            6
        """
        return Integer(self._gap_().Exponent())

    def largest_moved_point(self):
        """
        Return the largest point moved by a permutation in this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: G.largest_moved_point()
            4
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
            sage: G.largest_moved_point()
            10

        ::

            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.degree()
            5
        """
        try:
            return self._deg
        except AttributeError:
            n = Integer(self._gap_().LargestMovedPoint())
        self._deg = n
        return n

    degree = largest_moved_point

    @cached_method
    def smallest_moved_point(self):
        """
        Return the smallest point moved by a permutation in this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(3,4)], [(2,3,4)]])
            sage: G.smallest_moved_point()
            2
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
            sage: G.smallest_moved_point()
            1
        """
        return Integer(self._gap_().SmallestMovedPoint())

    @cached_method
    def orbits(self):
        """
        Returns the orbits of [1,2,...,degree] under the group action.

        EXAMPLES::

            sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])
            sage: G.orbits()
            [[1, 3, 4], [2]]
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
            sage: G.orbits()
            [[1, 2, 3, 4, 10], [5], [6], [7], [8], [9]]

        The answer is cached::

            sage: G.orbits() is G.orbits()
            True

        AUTHORS:

        - Nathan Dunfield
        """
        return self._gap_().Orbits("[1..%d]" % self.largest_moved_point()).sage()

    @cached_method
    def orbit(self, integer):
         """
         Return the orbit of the given integer under the group action.

         EXAMPLES::

             sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])
             sage: G.orbit(3)
             [3, 4, 1]
             sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
             sage: G.orbit(3)
             [3, 4, 10, 1, 2]
         """
         return self._gap_().Orbit(integer).sage()

    def transversals(self, integer):
         """
         If G is a permutation group acting on the set `X = \{1, 2, ...., n\}`
         and H is the stabilizer subgroup of <integer>, a right
         (respectively left) transversal is a set containing exactly
         one element from each right (respectively left) coset of H. This
         method returns a right transversal of ``self`` by the stabilizer
         of ``self`` on <integer> position.

         EXAMPLES::

             sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])
             sage: G.transversals(1)
             [(), (1,3,4), (1,4,3)]
             sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
             sage: G.transversals(1)
             [(), (1,2)(3,4), (1,3,2,10,4), (1,4,2,10,3), (1,10,4,3,2)]
         """
         trans = []
         for i in self.orbit(integer):
              trans.append(self(gap.RepresentativeAction(self._gap_(),integer,i)))
         return trans

    def stabilizer(self, position):
         """
         Return the subgroup of ``self`` which stabilize the given position.
         ``self`` and its stabilizers must have same degree.

         EXAMPLES::

             sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])
             sage: G.stabilizer(1)
             Permutation Group with generators [(), (3,4)]
             sage: G.stabilizer(3)
             Permutation Group with generators [(), (1,4)]
             sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])
             sage: G.stabilizer(10)
             Permutation Group with generators [(), (1,2)(3,4), (1,4,2)]
             sage: G.stabilizer(1)
             Permutation Group with generators [(), (3,10,4), (2,4)(3,10)]
         """
         if self.is_isomorphic(PermutationGroup([])):
             return self
         else:
             Q = PermutationGroup(gap.get_record_element(gap.get_record_element(self._gap_().StabChain([position]),'stabilizer'),'generators'))
             if Q.is_isomorphic(PermutationGroup([])):
                 return PermutationGroup([[(self.degree(),)]])
             else:
                 return PermutationGroup(Q.gens()+[(self.degree(),)])

    def strong_generating_system(self, base_of_group = None):
         """
         Return a Strong Generating System of ``self`` according the given
         base for the right action of ``self`` on itself.

         base_of_group must the list of position on which ``self`` act in
         any order. The algorithm return a list of transversals and each
         transversals is a list of permutation. By default, base_of_group
         is `[1, 2, 3, \dots , n]`.

         for any base_of_group = `[ pos_1, pos_2, \dots , pos_n]`
         let G_i be the subgroup of ``self`` which stabilize `pos_1, pos_2, \dots , pos_i`
         ``self`` = `G_0 \subset G_1 \subset G_2 \subset \dots \subset G_n = \{e\}`
         The algorithm return :
         ``[G_i.transversals(pos_{i+1}) for i in range(n)]``

         INPUT:

         - ``base_of_group`` (optional) A list which contains the integer
           `1, 2, \dots , d` in any order (d is the degree of ``self``)

         OUTPUT:

         - A list of list of permutation inside the group which form a strong
           generating system.

         EXAMPLES::

             sage: G = PermutationGroup([[(1,2,3,4)],[(1,2)]])
             sage: G.strong_generating_system()
             [[(), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)],
             [(), (2,3,4), (2,4,3)],
             [(), (3,4)],
             [()]]
             sage: G = PermutationGroup([[(1,2,3)],[(4,5,7)],[(1,4,6)]])
             sage: G.strong_generating_system()
             [[(), (1,2,3), (1,4,6), (1,3,2), (1,5,7,4,6), (1,6,4), (1,7,5,4,6)],
              [(), (2,6,3), (2,5,7,6,3), (2,3,6), (2,7,5,6,3), (2,4,7,6,3)],
              [(), (3,6,7), (3,5,6), (3,7,6), (3,4,7,5,6)],
              [(), (4,5)(6,7), (4,7)(5,6), (4,6)(5,7)],
              [(), (5,7,6), (5,6,7)],
              [()],
              [()]]
             sage: G = PermutationGroup([[(1,2,3)],[(2,3,4)],[(3,4,5)]])
             sage: G.strong_generating_system([5,4,3,2,1])
             [[(), (1,5,3,4,2), (1,5,4,3,2), (1,5)(2,3), (1,5,2)],
              [(), (1,3)(2,4), (1,2)(3,4), (1,4)(2,3)],
              [(), (1,3,2), (1,2,3)],
              [()],
              [()]]
             sage: G = TransitiveGroup(12,17)                # optional
             sage: G.strong_generating_system()              # optional
             [[(),
               (1,4,11,2)(3,6,5,8)(7,10,9,12),
               (1,8,3,2)(4,11,10,9)(5,12,7,6),
               (1,7)(2,8)(3,9)(4,10)(5,11)(6,12),
               (1,12,7,2)(3,10,9,8)(4,11,6,5),
               (1,11)(2,8)(3,5)(4,10)(6,12)(7,9),
               (1,10,11,8)(2,3,12,5)(4,9,6,7),
               (1,3)(2,8)(4,10)(5,7)(6,12)(9,11),
               (1,2,3,8)(4,9,10,11)(5,6,7,12),
               (1,6,7,8)(2,3,4,9)(5,10,11,12),
               (1,5,9)(3,11,7),
               (1,9,5)(3,7,11)],
              [(), (2,6,10)(4,12,8), (2,10,6)(4,8,12)],
              [()],
              [()],
              [()],
              [()],
              [()],
              [()],
              [()],
              [()],
              [()],
              [()]]
         """
         sgs = []
         stab = self
         if base_of_group == None:
              base_of_group = range(1,self.degree()+1)
         for j in base_of_group:
              sgs.append(stab.transversals(j))
              stab = stab.stabilizer(j)
         return sgs

    def _repr_(self):
        r"""
        Returns a string describing ``self``.

        EXAMPLES:

        We explicitly construct the alternating group on four
        elements. Note that the ``AlternatingGroup`` class has
        its own representation string::

            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: A4._repr_()
            'Permutation Group with generators [(2,3,4), (1,2,3)]'
            sage: AlternatingGroup(4)._repr_()
            'Alternating group of order 4!/2 as a permutation group'
        """
        return "Permutation Group with generators %s"%self.gens()

    def _latex_(self):
        r"""
        Method for describing ``self`` in LaTeX. Encapsulates
        ``self.gens()`` in angle brackets to denote that ``self``
        is generated by these elements. Called by the
        ``latex()`` function.

        EXAMPLES:

        We explicitly construct the alternating group on four
        elements::

            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4
            Permutation Group with generators [(2,3,4), (1,2,3)]
            sage: latex(A4)
            \langle (2,3,4), (1,2,3) \rangle
            sage: A4._latex_()
            '\\langle (2,3,4), (1,2,3) \\rangle'
        """
        return '\\langle ' + \
               ', '.join([x._latex_() for x in self.gens()]) + ' \\rangle'

    def order(self):
        """
        Return the number of elements of this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.order()
            12
            sage: G = PermutationGroup([()])
            sage: G.order()
            1
            sage: G = PermutationGroup([])
            sage: G.order()
            1
        """
        G = self
        if G.gens()==[] or G.gens()==[G(1)]:
            return Integer(1)
        return Integer(self._gap_().Size())

    def random_element(self):
        """
        Return a random element of this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.random_element()
            (1,2)(4,5)
        """
        current_randstate().set_seed_gap()

        return self._element_class()(self._gap_().Random(),
                                       self, check=False)

    def group_id(self):
        """
        Return the ID code of this group, which is a list of two integers.
        Requires "optional" database_gap-4.4.x package.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.group_id()    # optional - database_gap
            [12, 4]
        """
        return [Integer(n) for n in eval(str(self._gap_().IdGroup()))]

    def id(self):
        """
        (Same as ``self.group_id()``.) Return the ID code of this group, which
        is a list of two integers. Requires "optional" database_gap-4.4.x
        package.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: G.group_id()    # optional - database_gap
            [12, 4]
        """
        return self.group_id()

    def center(self):
        """
        Return the subgroup of elements that commute with every element
        of this group.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2,3,4)]])
            sage: G.center()
            Permutation Group with generators [(1,2,3,4)]
            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])
            sage: G.center()
            Permutation Group with generators [()]
        """
        C = self._gap_().Center()
        return PermutationGroup(gap_group=C)

    def direct_product(self,other,maps=True):
        """
        Wraps GAP's ``DirectProduct``, ``Embedding``, and ``Projection``.

        Sage calls GAP's ``DirectProduct``, which chooses an efficient
        representation for the direct product. The direct product of
        permutation groups will be a permutation group again. For a direct
        product ``D``, the GAP operation ``Embedding(D,i)`` returns the
        homomorphism embedding the i-th factor into ``D``. The GAP operation
        ``Projection(D,i)`` gives the projection of ``D`` onto the i-th factor.
        This method returns a 5-tuple: a permutation group and 4 morphisms.

        INPUT:


        -  ``self, other`` - permutation groups



        OUTPUT:


        -  ``D`` - a direct product of the inputs, returned as
           a permutation group as well

        -  ``iota1`` - an embedding of ``self`` into ``D``

        -  ``iota2`` - an embedding of ``other`` into ``D``

        -  ``pr1`` - the projection of ``D`` onto ``self`` (giving a
           splitting 1 - other - D - self - 1)

        -  ``pr2`` - the projection of ``D`` onto ``other`` (giving a
           splitting 1 - self - D - other - 1)


        EXAMPLES::

            sage: G = CyclicPermutationGroup(4)
            sage: D = G.direct_product(G,False)
            sage: D
            Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            sage: D,iota1,iota2,pr1,pr2 = G.direct_product(G)
            sage: D; iota1; iota2; pr1; pr2
            Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            Homomorphism : Cyclic group of order 4 as a permutation group --> Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            Homomorphism : Cyclic group of order 4 as a permutation group --> Permutation Group with generators [(1,2,3,4), (5,6,7,8)]
            Homomorphism : Permutation Group with generators [(1,2,3,4), (5,6,7,8)] --> Cyclic group of order 4 as a permutation group
            Homomorphism : Permutation Group with generators [(1,2,3,4), (5,6,7,8)] --> Cyclic group of order 4 as a permutation group

        ::

            sage: g=D([(1,3),(2,4)]); g
            (1,3)(2,4)
            sage: d=D([(1,4,3,2),(5,7),(6,8)]); d
            (1,4,3,2)(5,7)(6,8)
            sage: iota1(g); iota2(g); pr1(d); pr2(d)
            (1,3)(2,4)
            (5,7)(6,8)
            (1,4,3,2)
            (1,3)(2,4)
        """
        from sage.groups.perm_gps.permgroup_morphism import PermutationGroupMorphism_from_gap
        G1 = self._gap_init_()
        G2 = other._gap_init_()
        cmd1 = "G:=DirectProduct("+G1+","+G2+")"
        cmd2 = "iota1:=Embedding(G,1)"
        cmd3 = "iota2:=Embedding(G,2)"
        cmd4 = "pr1:=Projection(G,1)"
        cmd5 = "pr2:=Projection(G,2)"
        if not(maps):
            return PermutationGroup(gap_group=gap.eval(cmd1))
        else:
            D = PermutationGroup_generic(gap_group=gap.eval(cmd1))
            iota1 = PermutationGroupMorphism_from_gap(self,D, cmd2, "iota1")
            iota2 = PermutationGroupMorphism_from_gap(other,D, cmd3, "iota2")
            pr1 = PermutationGroupMorphism_from_gap(D,self, cmd4, "pr1")
            pr2 = PermutationGroupMorphism_from_gap(D,other, cmd5, "pr2")
            return D,iota1,iota2,pr1,pr2

    def subgroup(self, gens):
        """
        Wraps the ``PermutationGroup_subgroup`` constructor. The argument
        ``gens`` is a list of elements of ``self``.

        EXAMPLES::

            sage: G = PermutationGroup([(1,2,3),(3,4,5)])
            sage: g = G((1,2,3))
            sage: G.subgroup([g])
            Subgroup of Permutation Group with generators [(3,4,5), (1,2,3)] generated by [(1,2,3)]
        """
        return PermutationGroup_subgroup(self, gens)


    def quotient(self, N):
        """
        Returns the quotient of this permutation group by the normal
        subgroup `N`.

        Wraps the GAP operator "/".

        EXAMPLES::

            sage: G = PermutationGroup([(1,2,3), (2,3)])
            sage: N = PermutationGroup([(1,2,3)])
            sage: G.quotient(N)
            Permutation Group with generators [(1,2)]
        """
        G = self
        gap.eval("G := %s"%G._gap_().name())
        gap.eval("N := %s"%N._gap_().name())
        gap.eval("Q := G/N;")
        gap.eval("phi := RegularActionHomomorphism( Q );")
        gap.eval("gens := GeneratorsOfGroup( Image( phi ));")
        n = Integer(gap.eval("n := Length(gens);"))
        if n>0:
            gens = [self._element_class()(gap.eval("gens[%s];"%i)) for i in range(1,n+1)]
            Q = PermutationGroup(gens)
            return Q
        else:
            return PermutationGroup([()])

    def quotient_group(self, N):
        """
        This function has been deprecated and will be removed in a
        future version of Sage; use ``quotient`` instead.

        Original docstring follows.

        Returns the quotient of this permutation group by the normal
        subgroup `N`.

        Wraps the GAP operator "/".

        TESTS::

            sage: G = PermutationGroup([(1,2,3), (2,3)])
            sage: N = PermutationGroup([(1,2,3)])
            sage: G.quotient_group(N)
            doctest:...: DeprecationWarning: quotient_group() is deprecated; use quotient() instead.
            Permutation Group with generators [(1,2)]
        """
        import warnings
        warnings.warn('quotient_group() is deprecated; use quotient() instead.', DeprecationWarning, stacklevel=2)
        from sage.misc.misc import deprecation
        deprecation('quotient_group() is deprecated; use quotient() instead.')

        return self.quotient(N)


    def cohomology(self, n, p = 0):
        r"""
        Computes the group cohomology `H^n(G, F)`, where `F = \ZZ`
        if `p=0` and `F = \ZZ / p \ZZ` if `p > 0` is a prime.
        Wraps HAP's ``GroupHomology`` function, written by Graham Ellis.

        REQUIRES: GAP package HAP (in gap_packages-\*.spkg).

        EXAMPLES::

            sage: G = SymmetricGroup(4)
            sage: G.cohomology(1,2)                            # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C2
            sage: G = SymmetricGroup(3)
            sage: G.cohomology(5)                              # optional - gap_packages
            Trivial Abelian Group
            sage: G.cohomology(5,2)                            # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C2
            sage: G.homology(5,3)                              # optional - gap_packages
            Trivial Abelian Group
            sage: G.homology(5,4)                              # optional - gap_packages
            Traceback (most recent call last):
            ...
            ValueError: p must be 0 or prime

        This computes `H^4(S_3, \ZZ)` and
        `H^4(S_3, \ZZ / 2 \ZZ)`, respectively.

        AUTHORS:

        - David Joyner and Graham Ellis

        REFERENCES:

        - G. Ellis, 'Computing group resolutions', J. Symbolic
          Computation. Vol.38, (2004)1077-1118 (Available at
          http://hamilton.nuigalway.ie/).

        - D. Joyner, 'A primer on computational group homology and
          cohomology', http://front.math.ucdavis.edu/0706.0549.
        """
        if not is_package_installed('gap_packages'):
             raise RuntimeError, "You must install the optional gap_packages package."
        load_hap()
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            L = eval(gap.eval("GroupCohomology(%s,%s)"%(GG,n)))
        else:
            L = eval(gap.eval("GroupCohomology(%s,%s,%s)"%(GG,n,p)))
        return AbelianGroup(len(L),L)

    def cohomology_part(self, n, p = 0):
        """
        Computes the p-part of the group cohomology `H^n(G, F)`,
        where `F = \ZZ` if `p=0` and `F = \ZZ / p \ZZ` if
        `p > 0` is a prime. Wraps HAP's Homology function, written
        by Graham Ellis, applied to the `p`-Sylow subgroup of
        `G`.

        REQUIRES: GAP package HAP (in gap_packages-\*.spkg).

        EXAMPLES::

            sage: G = SymmetricGroup(5)
            sage: G.cohomology_part(7,2)                   # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C2
            sage: G = SymmetricGroup(3)
            sage: G.cohomology_part(2,3)                   # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C3

        AUTHORS:

        - David Joyner and Graham Ellis
        """
        if not is_package_installed('gap_packages'):
             raise RuntimeError, "You must install the optional gap_packages package."
        load_hap()
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            H = AbelianGroup(1,[1])
        else:
            gap.eval("S := SylowSubgroup(%s,%s)"%(GG,p))
            gap.eval("R:=ResolutionFiniteGroup(S,%s)"%(n+1))
            gap.eval("HR:=HomToIntegers(R)")
            L = eval(gap.eval("Cohomology(HR,%s)"%n))
        return AbelianGroup(len(L),L)

    def homology(self, n, p = 0):
        r"""
        Computes the group homology `H_n(G, F)`, where
        `F = \ZZ` if `p=0` and `F = \ZZ / p \ZZ` if
        `p > 0` is a prime. Wraps HAP's ``GroupHomology`` function,
        written by Graham Ellis.

        REQUIRES: GAP package HAP (in gap_packages-\*.spkg).

        AUTHORS:

        - David Joyner and Graham Ellis

        The example below computes `H_7(S_5, \ZZ)`,
        `H_7(S_5, \ZZ / 2 \ZZ)`,
        `H_7(S_5, \ZZ / 3 \ZZ)`, and
        `H_7(S_5, \ZZ / 5 \ZZ)`, respectively. To compute the
        `2`-part of `H_7(S_5, \ZZ)`, use the ``homology_part``
        function.

        EXAMPLES::

            sage: G = SymmetricGroup(5)
            sage: G.homology(7)                              # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C4 x C3 x C5
            sage: G.homology(7,2)                              # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C2 x C2 x C2
            sage: G.homology(7,3)                              # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C3
            sage: G.homology(7,5)                              # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C5

        REFERENCES:

        - G. Ellis, "Computing group resolutions", J. Symbolic
          Computation. Vol.38, (2004)1077-1118 (Available at
          http://hamilton.nuigalway.ie/.

        - D. Joyner, "A primer on computational group homology and cohomology",
          http://front.math.ucdavis.edu/0706.0549
        """
        if not is_package_installed('gap_packages'):
             raise RuntimeError, "You must install the optional gap_packages package."
        load_hap()
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            L = eval(gap.eval("GroupHomology(%s,%s)"%(GG,n)))
        else:
            L = eval(gap.eval("GroupHomology(%s,%s,%s)"%(GG,n,p)))
        return AbelianGroup(len(L),L)

    def homology_part(self, n, p = 0):
        r"""
        Computes the `p`-part of the group homology
        `H_n(G, F)`, where `F = \ZZ` if `p=0` and
        `F = \ZZ / p \ZZ` if `p > 0` is a prime. Wraps HAP's
        ``Homology`` function, written by Graham Ellis, applied to the
        `p`-Sylow subgroup of `G`.

        REQUIRES: GAP package HAP (in gap_packages-\*.spkg).

        EXAMPLES::

            sage: G = SymmetricGroup(5)
            sage: G.homology_part(7,2)                              # optional - gap_packages
            Multiplicative Abelian Group isomorphic to C2 x C2 x C2 x C2 x C4

        AUTHORS:

        - David Joyner and Graham Ellis
        """
        if not is_package_installed('gap_packages'):
             raise RuntimeError, "You must install the optional gap_packages package."
        gap.eval('LoadPackage("hap")')
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        if p == 0:
            H = AbelianGroup(1,[1])
        else:
            gap.eval("S := SylowSubgroup(%s,%s)"%(GG,p))
            gap.eval("R:=ResolutionFiniteGroup(S,%s)"%(n+1))
            gap.eval("TR:=TensorWithIntegers(R);")
            L = eval(gap.eval("Homology(TR,%s)"%n))
        return AbelianGroup(len(L),L)

    def character_table(self):
        r"""
        Returns the matrix of values of the irreducible characters of a
        permutation group `G` at the conjugacy classes of
        `G`. The columns represent the conjugacy classes of
        `G` and the rows represent the different irreducible
        characters in the ordering given by GAP.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3)]])
            sage: G.order()
            12
            sage: G.character_table()
            [         1          1          1          1]
            [         1          1 -zeta3 - 1      zeta3]
            [         1          1      zeta3 -zeta3 - 1]
            [         3         -1          0          0]
            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3)]])
            sage: CT = gap(G).CharacterTable()

        Type ``print gap.eval("Display(%s)"%CT.name())`` to display this
        nicely.

        ::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: G.order()
            8
            sage: G.character_table()
            [ 1  1  1  1  1]
            [ 1 -1 -1  1  1]
            [ 1 -1  1 -1  1]
            [ 1  1 -1 -1  1]
            [ 2  0  0  0 -2]
            sage: CT = gap(G).CharacterTable()

        Again, type ``print gap.eval("Display(%s)"%CT.name())`` to display this
        nicely.

        ::

            sage: SymmetricGroup(2).character_table()
            [ 1 -1]
            [ 1  1]
            sage: SymmetricGroup(3).character_table()
            [ 1 -1  1]
            [ 2  0 -1]
            [ 1  1  1]
            sage: SymmetricGroup(5).character_table()
            [ 1 -1  1  1 -1 -1  1]
            [ 4 -2  0  1  1  0 -1]
            [ 5 -1  1 -1 -1  1  0]
            [ 6  0 -2  0  0  0  1]
            [ 5  1  1 -1  1 -1  0]
            [ 4  2  0  1 -1  0 -1]
            [ 1  1  1  1  1  1  1]
            sage: list(AlternatingGroup(6).character_table())
            [(1, 1, 1, 1, 1, 1, 1), (5, 1, 2, -1, -1, 0, 0), (5, 1, -1, 2, -1, 0, 0), (8, 0, -1, -1, 0, zeta5^3 + zeta5^2 + 1, -zeta5^3 - zeta5^2), (8, 0, -1, -1, 0, -zeta5^3 - zeta5^2, zeta5^3 + zeta5^2 + 1), (9, 1, 0, 0, 1, -1, -1), (10, -2, 1, 1, 0, 0, 0)]

        Suppose that you have a class function `f(g)` on
        `G` and you know the values `v_1, \ldots, v_n` on
        the conjugacy class elements in
        ``conjugacy_classes_representatives(G)`` =
        `[g_1, \ldots, g_n]`. Since the irreducible characters
        `\rho_1, \ldots, \rho_n` of `G` form an
        `E`-basis of the space of all class functions (`E`
        a "sufficiently large" cyclotomic field), such a class function is
        a linear combination of these basis elements,
        `f = c_1 \rho_1 + \cdots + c_n \rho_n`. To find
        the coefficients `c_i`, you simply solve the linear system
        ``character_table_values(G)`` `[v_1, ..., v_n] = [c_1, ..., c_n]`,
        where `[v_1, \ldots, v_n]` = ``character_table_values(G)`` `^{(-1)}[c_1, ..., c_n]`.

        AUTHORS:

        - David Joyner and William Stein (2006-01-04)

        """
        G    = self._gap_()
        cl   = G.ConjugacyClasses()
        n    = Integer(cl.Length())
        irrG = G.Irr()
        ct   = [[irrG[i+1,j+1] for j in range(n)] for i in range(n)]

        from sage.rings.all import CyclotomicField
        e = irrG.Flat().Conductor()
        K = CyclotomicField(e)
        ct = [[K(x) for x in v] for v in ct]

        # Finally return the result as a matrix.
        from sage.matrix.all import MatrixSpace
        MS = MatrixSpace(K,n)
        return MS(ct)

    def irreducible_characters(self):
        r"""
        Returns a list of the irreducible characters of ``self``.

        EXAMPLES::

            sage: irr = SymmetricGroup(3).irreducible_characters()
            sage: [x.values() for x in irr]
            [[1, -1, 1], [2, 0, -1], [1, 1, 1]]
        """
        Irr = self._gap_().Irr()
        L = []
        for irr in Irr:
            L.append(ClassFunction(self, irr))
        return L

    def trivial_character(self):
        r"""
        Returns the trivial character of ``self``.

        EXAMPLES::

            sage: SymmetricGroup(3).trivial_character()
            Character of Symmetric group of order 3! as a permutation group
        """
        values = [1]*Integer(self._gap_().NrConjugacyClasses())
        return self.character(values)

    def character(self, values):
        r"""
        Returns a group character from ``values``, where ``values`` is
        a list of the values of the character evaluated on the conjugacy
        classes.

        EXAMPLES::

            sage: G = AlternatingGroup(4)
            sage: n = len(G.conjugacy_classes_representatives())
            sage: G.character([1]*n)
            Character of Alternating group of order 4!/2 as a permutation group
        """
        return ClassFunction(self,values)

    def conjugacy_classes_representatives(self):
        """
        Returns a complete list of representatives of conjugacy classes in
        a permutation group `G`. The ordering is that given by GAP.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: cl = G.conjugacy_classes_representatives(); cl
            [(), (2,4), (1,2)(3,4), (1,2,3,4), (1,3)(2,4)]
            sage: cl[3] in G
            True

        ::

            sage: G = SymmetricGroup(5)
            sage: G.conjugacy_classes_representatives ()
            [(), (1,2), (1,2)(3,4), (1,2,3), (1,2,3)(4,5), (1,2,3,4), (1,2,3,4,5)]

        AUTHORS:

        - David Joyner and William Stein (2006-01-04)
        """
        cl = self._gap_().ConjugacyClasses()
        n = Integer(cl.Length())
        L = gap("List([1..Length(%s)], i->Representative(%s[i]))"%(
            cl.name(),  cl.name()))
        return [self._element_class()(L[i], self, check=False) \
                for i in range(1,n+1)]

    def conjugacy_classes_subgroups(self):
        """
        Returns a complete list of representatives of conjugacy classes of
        subgroups in a permutation group `G`. The ordering is that given by
        GAP.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: cl = G.conjugacy_classes_subgroups()
            sage: cl
            [Permutation Group with generators [()],
             Permutation Group with generators [(1,2)(3,4)],
             Permutation Group with generators [(1,3)(2,4)],
             Permutation Group with generators [(2,4)],
             Permutation Group with generators [(1,4)(2,3), (1,2)(3,4)],
             Permutation Group with generators [(1,3)(2,4), (2,4)],
             Permutation Group with generators [(1,3)(2,4), (1,2,3,4)],
             Permutation Group with generators [(1,3)(2,4), (1,2)(3,4), (1,2,3,4)]]

        ::

            sage: G = SymmetricGroup(3)
            sage: G.conjugacy_classes_subgroups()
            [Permutation Group with generators [()],
             Permutation Group with generators [(2,3)],
             Permutation Group with generators [(1,2,3)],
             Permutation Group with generators [(1,3,2), (1,2)]]

        AUTHORS:

        - David Joyner (2006-10)
        """
        G = self._gap_()
        cl = G.ConjugacyClassesSubgroups()
        n = Integer(cl.Length())
        L = gap("List([1..Length(%s)], i->Representative(%s[i]))"%(
            cl.name(),  cl.name()))
        return [PermutationGroup(gap_group=L[i])for i in range(1,n+1)]

    def normalizer(self, g):
        """
        Returns the normalizer of ``g`` in ``self``.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: g = G([(1,3)])
            sage: G.normalizer(g)
            Permutation Group with generators [(2,4), (1,3)]
            sage: g = G([(1,2,3,4)])
            sage: G.normalizer(g)
            Permutation Group with generators [(2,4), (1,2,3,4), (1,3)(2,4)]
            sage: H = G.subgroup([G([(1,2,3,4)])])
            sage: G.normalizer(H)
            Permutation Group with generators [(2,4), (1,2,3,4), (1,3)(2,4)]
        """
        N = self._gap_().Normalizer(g)
        return PermutationGroup(N.GeneratorsOfGroup())

    def centralizer(self, g):
        """
        Returns the centralizer of ``g`` in ``self``.

        EXAMPLES::

            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])
            sage: g = G([(1,3)])
            sage: G.centralizer(g)
            Permutation Group with generators [(2,4), (1,3)]
            sage: g = G([(1,2,3,4)])
            sage: G.centralizer(g)
            Permutation Group with generators [(1,2,3,4)]
            sage: H = G.subgroup([G([(1,2,3,4)])])
            sage: G.centralizer(H)
            Permutation Group with generators [(1,2,3,4)]
        """
        N = self._gap_().Centralizer(g)
        return PermutationGroup(N.GeneratorsOfGroup())

    def isomorphism_type_info_simple_group(self):
        """
        If the group is simple, then this returns the name of the group.

        EXAMPLES::

            sage: G = CyclicPermutationGroup(5)
            sage: G.isomorphism_type_info_simple_group()
            rec( series := "Z", parameter := 5, name := "Z(5)" )

        TESTS: This shows that the issue at trac ticket 7360 is fixed::

            sage: G = KleinFourGroup()
            sage: G.is_simple()
            False
            sage: G.isomorphism_type_info_simple_group()
            Traceback (most recent call last):
            ...
            TypeError: Group must be simple.
        """
        if self.is_simple():
            info = self._gap_().IsomorphismTypeInfoFiniteSimpleGroup()
            return info
        else:
            raise TypeError, "Group must be simple."

    ######################  Boolean tests #####################

    def is_abelian(self):
        """
        Return ``True`` if this group is abelian.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_abelian()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_abelian()
            True
        """
        return self._gap_().IsAbelian().bool()

    def is_commutative(self):
        """
        Return ``True`` if this group is commutative.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_commutative()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_commutative()
            True
        """
        return self.is_abelian()

    def is_cyclic(self):
        """
        Return ``True`` if this group is cyclic.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_cyclic()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_cyclic()
            True
        """
        return self._gap_().IsCyclic().bool()

    def is_elementary_abelian(self):
        """
        Return ``True`` if this group is elementary abelian. An elementary
        abelian group is a finite abelian group, where every nontrivial
        element has order `p`, where `p` is a prime.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_elementary_abelian()
            False
            sage: G = PermutationGroup(['(1,2,3)','(4,5,6)'])
            sage: G.is_elementary_abelian()
            True
        """
        return self._gap_().IsElementaryAbelian().bool()

    def isomorphism_to(self,right):
        """
        Return an isomorphism from ``self`` to ``right`` if the groups
        are isomorphic, otherwise ``None``.

        INPUT:


        -  ``self`` - this group

        -  ``right`` - a permutation group


        OUTPUT:

        - ``None`` or a morphism of permutation groups.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: H = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.isomorphism_to(H) is None
            True
            sage: G = PermutationGroup([(1,2,3), (2,3)])
            sage: H = PermutationGroup([(1,2,4), (1,4)])
            sage: G.isomorphism_to(H)
            Homomorphism : Permutation Group with generators [(2,3), (1,2,3)] --> Permutation Group with generators [(1,2,4), (1,4)]
        """
        current_randstate().set_seed_gap()

        if not isinstance(right, PermutationGroup_generic):
            raise TypeError, "right must be a permutation group"
        G = self._gap_init_()
        H = right._gap_init_()
        gap.eval("x:=IsomorphismGroups( %s, %s )"%(G,H))
        s = gap.eval("x")
        if s == "fail":
            return None
        # slice and dice the GAP return to build a Sage group homomorphism
        src, dst = s.split("->")
        # we eval to get things as lists
        srcs = from_gap_list(self, src)
        dsts = from_gap_list(right, dst)
        from permgroup_morphism import PermutationGroupMorphism_im_gens
        return PermutationGroupMorphism_im_gens(self, right, srcs, dsts)

    def is_isomorphic(self, right):
        """
        Return ``True`` if the groups are isomorphic.

        INPUT:


        -  ``self`` - this group

        -  ``right`` - a permutation group


        OUTPUT:

        - boolean; ``True`` if ``self`` and ``right`` are isomorphic groups;
          ``False`` otherwise.

        EXAMPLES::

            sage: v = ['(1,2,3)(4,5)', '(1,2,3,4,5)']
            sage: G = PermutationGroup(v)
            sage: H = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_isomorphic(H)
            False
            sage: G.is_isomorphic(G)
            True
            sage: G.is_isomorphic(PermutationGroup(list(reversed(v))))
            True
        """
        if not isinstance(right, PermutationGroup_generic):
            raise TypeError, "right must be a permutation group"
        G = self._gap_()
        H = right._gap_()
        return gap.eval("IsomorphismGroups( %s, %s )"%(G.name(),H.name())) != "fail"

    def is_monomial(self):
        """
        Returns ``True`` if the group is monomial. A finite group is monomial
        if every irreducible complex character is induced from a linear
        character of a subgroup.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_monomial()
            True
        """
        return self._gap_().IsMonomialGroup().bool()

    def is_nilpotent(self):
        """
        Return ``True`` if this group is nilpotent.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_nilpotent()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_nilpotent()
            True
        """
        return self._gap_().IsNilpotent().bool()

    def is_normal(self, other):
        """
        Return ``True`` if this group is a normal subgroup of ``other``.

        EXAMPLES::

            sage: AlternatingGroup(4).is_normal(SymmetricGroup(4))
            True
            sage: H = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: H.is_normal(G)
            False
        """
        if not(self.is_subgroup(other)):
            raise TypeError("%s must be a subgroup of %s"%(self,other))
        return other._gap_().IsNormal(self._gap_()).bool()

    def is_perfect(self):
        """
        Return ``True`` if this group is perfect. A group is perfect if it
        equals its derived subgroup.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_perfect()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_perfect()
            False
        """
        return self._gap_().IsPerfectGroup().bool()

    def is_pgroup(self):
        """
        Returns ``True`` if this group is a `p`-group. A finite group is
        a `p`-group if its order is of the form `p^n` for a prime integer
        `p` and a nonnegative integer `n`.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3,4,5)'])
            sage: G.is_pgroup()
            True
        """
        return self._gap_().IsPGroup().bool()

    def is_polycyclic(self):
        r"""
        Return ``True`` if this group is polycyclic. A group is polycyclic if
        it has a subnormal series with cyclic factors. (For finite groups,
        this is the same as if the group is solvable - see
        ``is_solvable``.)

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: G.is_polycyclic()
            False
            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_polycyclic()
            True
        """
        return self._gap_().IsPolycyclicGroup().bool()

    def is_simple(self):
        """
        Returns ``True`` if the group is simple. A group is simple if it has no
        proper normal subgroups.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_simple()
            False
        """
        return self._gap_().IsSimpleGroup().bool()

    def is_solvable(self):
        """
        Returns ``True`` if the group is solvable.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_solvable()
            True
        """
        return self._gap_().IsSolvableGroup().bool()

    def is_subgroup(self,other):
        """
        Returns ``True`` if ``self`` is a subgroup of ``other``.

        EXAMPLES::

            sage: G = AlternatingGroup(5)
            sage: H = SymmetricGroup(5)
            sage: G.is_subgroup(H)
            True
        """
        G = other
        gens = self.gens()
        for i in range(len(gens)):
            x = gens[i]
            if not (x in G):
                return False
        return True

    def is_supersolvable(self):
        """
        Returns ``True`` if the group is supersolvable. A finite group is
        supersolvable if it has a normal series with cyclic factors.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: G.is_supersolvable()
            True
        """
        return self._gap_().IsSupersolvableGroup().bool()

    def is_transitive(self):
        """
        Return ``True`` if ``self`` is a transitive group, i.e., if the action
        of self on [1..n] is transitive.

        EXAMPLES::

            sage: G = SymmetricGroup(5)
            sage: G.is_transitive()
            True
            sage: G = PermutationGroup(['(1,2)(3,4)(5,6)'])
            sage: G.is_transitive()
            False

        Note that this differs from the definition in GAP, where
        ``IsTransitive`` returns whether the group is transitive on the
        set of points moved by the group.

        ::

            sage: G = PermutationGroup([(2,3)])
            sage: G.is_transitive()
            False
            sage: gap(G).IsTransitive()
            true
        """
        return self._gap_().IsTransitive('[1..%s]'%self.degree()).bool()

    def normalizes(self,other):
        r"""
        Returns ``True`` if the group ``other`` is normalized by ``self``.
        Wraps GAP's ``IsNormal`` function.

        A group `G` normalizes a group `U` if and only if for every
        `g \in G` and `u \in U` the element `u^g`
        is a member of `U`. Note that `U` need not be a subgroup of `G`.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)(4,5)'])
            sage: H = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])
            sage: H.normalizes(G)
            False
            sage: G = SymmetricGroup(3)
            sage: H = PermutationGroup( [ (4,5,6) ] )
            sage: G.normalizes(H)
            True
            sage: H.normalizes(G)
            True

        In the last example, `G` and `H` are disjoint, so each normalizes the
        other.
        """
        return self._gap_().IsNormal(other._gap_()).bool()

    ############## Series ######################

    def composition_series(self):
        """
        Return the composition series of this group as a list of
        permutation groups.

        EXAMPLES:

        These computations use pseudo-random numbers, so we set
        the seed for reproducible testing.

        ::

            sage: set_random_seed(0)
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.composition_series()  # random output
            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], Permutation Group with generators [(1,5)(3,4), (1,5)(2,3), (1,5,4)], Permutation Group with generators [()]]
            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])
            sage: CS = G.composition_series()
            sage: CS[3]
            Permutation Group with generators [()]
        """
        current_randstate().set_seed_gap()
        ans = []
        DS = self._gap_().CompositionSeries()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i].GeneratorsOfGroup()))
        return ans

    def derived_series(self):
        """
        Return the derived series of this group as a list of permutation
        groups.

        EXAMPLES:

        These computations use pseudo-random numbers, so we set
        the seed for reproducible testing.

        ::

            sage: set_random_seed(0)
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.derived_series()  # random output
            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], Permutation Group with generators [(1,5)(3,4), (1,5)(2,4), (2,4)(3,5)]]
        """
        current_randstate().set_seed_gap()
        ans = []
        DS = self._gap_().DerivedSeries()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i].GeneratorsOfGroup()))
        return ans

    def lower_central_series(self):
        """
        Return the lower central series of this group as a list of
        permutation groups.

        EXAMPLES:

        These computations use pseudo-random numbers, so we set
        the seed for reproducible testing.

        ::

            sage: set_random_seed(0)
            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.lower_central_series()  # random output
            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], Permutation Group with generators [(1,5)(3,4), (1,5)(2,3), (1,3)(2,4)]]
        """
        current_randstate().set_seed_gap()
        ans = []
        DS = self._gap_().LowerCentralSeriesOfGroup()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(DS[i].GeneratorsOfGroup()))
        return ans

    def molien_series(self):
        r"""
        Returns the Molien series of a transitive permutation group. The
        function

        .. math::

                     M(x) = (1/|G|)\sum_{g\in G} \det(1-x*g)^{-1}


        is sometimes called the "Molien series" of `G`. GAP's
        ``MolienSeries`` is associated to a character of a
        group `G`. How are these related? A group `G`, given as a permutation
        group on `n` points, has a "natural" representation of dimension `n`,
        given by permutation matrices. The Molien series of `G` is the one
        associated to that permutation representation of `G` using the above
        formula. Character values then count fixed points of the
        corresponding permutations.

        EXAMPLES::

            sage: G = SymmetricGroup(5)
            sage: G.molien_series()
            1/(-x^15 + x^14 + x^13 - x^10 - x^9 - x^8 + x^7 + x^6 + x^5 - x^2 - x + 1)
            sage: G = SymmetricGroup(3)
            sage: G.molien_series()
            1/(-x^6 + x^5 + x^4 - x^2 - x + 1)
        """
        G = self
        GG = G._gap_init_()
        gap.eval("pi := NaturalCharacter( %s )"%GG)
        gap.eval("cc := ConstituentsOfCharacter( pi )")
        M = gap.eval("M := MolienSeries(Sum(cc))")
        R = PolynomialRing(RationalField(),"x")
        x = R.gen()
        nn = gap.eval("NumeratorOfRationalFunction(M)")
        dd = gap.eval("DenominatorOfRationalFunction(M)")
        FF = FractionField(R)
        return FF(nn.replace("_1",""))/FF(dd.replace("_1",""))

    def normal_subgroups(self):
        """
        Return the normal subgroups of this group as a (sorted in
        increasing order) list of permutation groups.

        The normal subgroups of `H = PSL(2,7) \\times PSL(2,7)` are
        `1`, two copies of `PSL(2,7)` and `H`
        itself, as the following example shows.

        EXAMPLES::

            sage: G = PSL(2,7)
            sage: D = G.direct_product(G)
            sage: H = D[0]
            sage: NH = H.normal_subgroups()
            sage: len(NH)
            4
            sage: NH[1].is_isomorphic(G)
            True
            sage: NH[2].is_isomorphic(G)
            True
        """
        ans = []
        NS = self._gap_().NormalSubgroups()
        n = NS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(NS[i].GeneratorsOfGroup()))
        return ans

    def poincare_series(self, p=2, n=10):
        """
        Returns the Poincare series of `G \mod p` (`p \geq 2` must be a
        prime), for `n` large. In other words, if you input a finite
        group `G`, a prime `p`, and a positive integer `n`, it returns a
        quotient of polynomials `f(x) = P(x) / Q(x)` whose coefficient of
        `x^k` equals the rank of the vector space
        `H_k(G, \ZZ / p \ZZ)`, for all `k` in the
        range `1 \leq k \leq n`.

        REQUIRES: GAP package HAP (in gap_packages-\*.spkg).

        EXAMPLES::

            sage: G = SymmetricGroup(5)
            sage: G.poincare_series(2,10)                              # optional - gap_packages
            (x^2 + 1)/(x^4 - x^3 - x + 1)
            sage: G = SymmetricGroup(3)
            sage: G.poincare_series(2,10)                              # optional - gap_packages
            1/(-x + 1)

        AUTHORS:

        - David Joyner and Graham Ellis
        """
        if not is_package_installed('gap_packages'):
             raise RuntimeError, "You must install the optional gap_packages package."
        load_hap()
        from sage.rings.arith import is_prime
        if not (p == 0 or is_prime(p)):
            raise ValueError, "p must be 0 or prime"
        G = self
        GG = G._gap_init_()
        ff = gap.eval("ff := PoincareSeriesPrimePart(%s,%s,%s)"%(GG,p,n))
        R = PolynomialRing(RationalField(),"x")
        x = R.gen()
        nn = gap.eval("NumeratorOfRationalFunction(ff)").replace("x_1","x")
        dd = gap.eval("DenominatorOfRationalFunction(ff)").replace("x_1","x")
        FF = FractionField(R)
        return FF(nn)/FF(dd)


    def sylow_subgroup(self, p):
        """
        Returns a Sylow `p`-subgroup of the finite group `G`, where `p` is a
        prime. This is a `p`-subgroup of `G` whose index in `G` is coprime to
        `p`. Wraps the GAP function ``SylowSubgroup``.

        EXAMPLES::

            sage: G = PermutationGroup(['(1,2,3)', '(2,3)'])
            sage: G.sylow_subgroup(2)
            Permutation Group with generators [(2,3)]
            sage: G.sylow_subgroup(5)
            Permutation Group with generators [()]
        """
        G = self
        gap.eval("G := %s"%G._gap_init_())
        gap.eval("Ssgp := SylowSubgroup(G, %s);"%p)
        gap.eval("gens := GeneratorsOfGroup( Ssgp );")
        N = Integer(gap.eval("N := Length(gens);"))
        if N>0:
            gens = [self._element_class()(gap.eval("gens[%s];"%j)) for j in range(1,N+1)]
            H = PermutationGroup(gens)
        else:
            H = PermutationGroup([()])
        return H


    def upper_central_series(self):
        """
        Return the upper central series of this group as a list of
        permutation groups.

        EXAMPLES:

        These computations use pseudo-random numbers, so we set
        the seed for reproducible testing.

        ::

            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
            sage: G.upper_central_series()
            [Permutation Group with generators [()]]
        """
        current_randstate().set_seed_gap()
        ans = []
        DS = self._gap_().UpperCentralSeriesOfGroup()
        n = DS.Length()
        for i in range(1,n+1):
            ans.append(PermutationGroup(gap_group=DS[i]))
        return ans

class PermutationGroup_subgroup(PermutationGroup_generic):
    """
    Subgroup subclass of ``PermutationGroup_generic``, so instance methods
    are inherited.

    EXAMPLES::

        sage: G = CyclicPermutationGroup(4)
        sage: gens = G.gens()
        sage: H = DihedralGroup(4)
        sage: PermutationGroup_subgroup(H,list(gens))
        Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]
        sage: K=PermutationGroup_subgroup(H,list(gens))
        sage: K.list()
        [(), (1,2,3,4), (1,3)(2,4), (1,4,3,2)]
        sage: K.ambient_group()
        Dihedral group of order 8 as a permutation group
        sage: K.gens()
        [(1,2,3,4)]
    """
    def __init__(self, ambient, gens, from_group = False, check=True, canonicalize=True):
        r"""
        Initialization method for the
        ``PermutationGroup_subgroup`` class.

        INPUTS:

        - ``ambient`` - the ambient group from which to construct this
          subgroup

        - ``gens`` - the generators of the subgroup

        - ``from_group`` - ``True``: subgroup is generated from a Gap
          string representation of the generators (default: ``False``)

        - ``check`` - ``True``: checks if ``gens`` are indeed elements of the
          ambient group

        - ``canonicalize`` - boolean (default: ``True``); if ``True``, sort
          generators and remove duplicates

        EXAMPLES:

        An example involving the dihedral group on four elements.
        `D_8` contains a cyclic subgroup or order four::

            sage: G = DihedralGroup(4)
            sage: H = CyclicPermutationGroup(4)
            sage: gens = H.gens(); gens
            [(1,2,3,4)]
            sage: S = PermutationGroup_subgroup(G,gens)
            sage: S
            Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]
            sage: S.list()
            [(), (1,2,3,4), (1,3)(2,4), (1,4,3,2)]
            sage: S.ambient_group()
            Dihedral group of order 8 as a permutation group

        However, `D_8` does not contain a cyclic subgroup of order
        three::

            sage: G = DihedralGroup(4)
            sage: H = CyclicPermutationGroup(3)
            sage: gens = H.gens()
            sage: S = PermutationGroup_subgroup(G,list(gens))
            Traceback (most recent call last):
            ...
            TypeError: each generator must be in the ambient group
        """
        if not isinstance(ambient, PermutationGroup_generic):
            raise TypeError, "ambient (=%s) must be perm group."%ambient
        if not isinstance(gens, list):
            raise TypeError, "gens (=%s) must be a list"%gens

        self.__ambient_group = ambient
        self._gens = gens
        cmd = 'Group(%s)'%gens
        cmd = cmd.replace("'","")  # get rid of quotes
        self._gap_string = cmd

        G = ambient
        if check:
            for g in gens:
                if g not in G:
                    raise TypeError, "each generator must be in the ambient group"
        self.__ambient_group = G

        PermutationGroup_generic.__init__(self, gens, canonicalize=canonicalize)

    def __cmp__(self, other):
        r"""
        Compare ``self`` and ``other``.

        First, ``self`` and ``other`` are compared as permutation groups, see :method:`sage.groups.perm_gps.permgroup.PermutationGroup_generic.__cmp__`.
        Second, if both are equal, the ambient groups are compared, where (if necessary)
        ``other`` is considered a subgroup of itself.

        EXAMPLES::

            sage: G=SymmetricGroup(6)
            sage: G1=G.subgroup([G((1,2,3,4,5)),G((1,2))])
            sage: G2=G.subgroup([G((1,2,3,4)),G((1,2))])
            sage: K=G2.subgroup([G2((1,2,3))])
            sage: H=G1.subgroup([G1(())])

        ``H`` is subgroup of ``K``, and therefore we have::

            sage: H<K
            True
            sage: K<H
            False

        In the next example, both ``H`` and ``H2`` are trivial
        groups, but the ambient group of ``H2`` is strictly contained
        in the ambient group of ``H``, and thus we obtain::

            sage: H2=G2.subgroup([G2(())])
            sage: H2<H
            True

        Of course, ``G`` as a permutation group and ``G`` considered
        as sub-group of itself are different objects. But they
        compare equal, both when considered as permutation groups
        or permutation subgroups::

            sage: G3 = G.subgroup([G((1,2,3,4,5,6)),G((1,2))])
            sage: G
            Symmetric group of order 6! as a permutation group
            sage: G3
            Subgroup of SymmetricGroup(6) generated by [(1,2), (1,2,3,4,5,6)]
            sage: G is G3
            False
            sage: G == G3 # as permutation groups
            True
            sage: G3 == G # as permutation subgroups
            True

        TESTS::

            sage: G = SymmetricGroup(4)
            sage: G.subgroup([G((1,2,3))]) == G.subgroup([G((2,3,1))])
            True
            sage: G.subgroup([G((1,2,3))]) == G.subgroup([G((1,3,2))])
            True

        """
        if self is other:
            return 0
        if not isinstance(other, PermutationGroup_generic):
            return -1
        c = PermutationGroup_generic.__cmp__(self, other)
        if c: return c
        if hasattr(other, 'ambient_group'):
             o_ambient = other.ambient_group()
        else:
             o_ambient = other
        return cmp(self.ambient_group(),o_ambient)

    def _repr_(self):
        r"""
        Returns a string representation / description of the permutation
        subgroup.

        EXAMPLES:

        An example involving the dihedral group on four elements,
        `D_8`::

            sage: G = DihedralGroup(4)
            sage: H = CyclicPermutationGroup(4)
            sage: gens = H.gens()
            sage: S = PermutationGroup_subgroup(G, list(gens))
            sage: S
            Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]
            sage: S._repr_()
            'Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]'
        """
        s = "Subgroup of %s generated by %s"%(self.ambient_group(), self.gens())
        return s

    def _latex_(self):
        r"""
        Return LaTeX representation of this group.

        EXAMPLES:

        An example involving the dihedral group on four elements,
        `D_8`::

            sage: G = DihedralGroup(4)
            sage: H = CyclicPermutationGroup(4)
            sage: gens = H.gens()
            sage: S = PermutationGroup_subgroup(G, list(gens))
            sage: latex(S)
            Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]
            sage: S._latex_()
            'Subgroup of Dihedral group of order 8 as a permutation group generated by [(1,2,3,4)]'
        """
        return self._repr_()


    def ambient_group(self):
        """
        Return the ambient group related to ``self``.

        EXAMPLES:

        An example involving the dihedral group on four elements,
        `D_8`::

            sage: G = DihedralGroup(4)
            sage: H = CyclicPermutationGroup(4)
            sage: gens = H.gens()
            sage: S = PermutationGroup_subgroup(G, list(gens))
            sage: S.ambient_group()
            Dihedral group of order 8 as a permutation group
            sage: S.ambient_group() == G
            True
        """
        return self.__ambient_group

    def gens(self):
        """
        Return the generators for this subgroup.

        EXAMPLES:

        An example involving the dihedral group on four elements,
        `D_8`::

            sage: G = DihedralGroup(4)
            sage: H = CyclicPermutationGroup(4)
            sage: gens = H.gens()
            sage: S = PermutationGroup_subgroup(G, list(gens))
            sage: S.gens()
            [(1,2,3,4)]
            sage: S.gens() == list(H.gens())
            True
        """
        return self._gens

