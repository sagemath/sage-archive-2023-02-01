r"""
The Sage Notebook Twisted Web Server

    TESTS::

    It is important that this file never be imported by default on
    startup by Sage, since it is very expensive, since importing Twisted
    is expensive. This doctest verifies that twist.py isn't imported on
    startup.

    sage: os.system("sage -startuptime | grep twisted\.web2 1>/dev/null") != 0  # !=0 means not found
    True
"""

#############################################################################
#       Copyright (C) 2007 William Stein <wstein@gmail.com>
#  Distributed under the terms of the GNU General Public License (GPL)
#  The full text of the GPL is available at:
#                  http://www.gnu.org/licenses/
#############################################################################

############################################################
# WARNING: Potential source of confusion!!
#
# The following three global variables get set on
# startup by the script that is generated by run_notebook.py

notebook   = None
OPEN_MODE  = None
SID_COOKIE = None

############################################################

import os, shutil, time
from sage.version import version
import bz2
from cgi import escape

from twisted.web2 import server, http, resource, channel
from twisted.web2 import static, http_headers, responsecode
from twisted.web2.filter import gzip
import zipfile

import css, js, keyboards

import notebook as _notebook

from sage.server.notebook.template import template

HISTORY_MAX_OUTPUT = 92*5
HISTORY_NCOLS = 90

from sage.misc.misc import SAGE_EXTCODE, SAGE_LOCAL, SAGE_DOC, walltime, tmp_filename, tmp_dir

p = os.path.join
css_path        = p(SAGE_EXTCODE, "notebook/css")
image_path      = p(SAGE_EXTCODE, "notebook/images")
javascript_path = p(SAGE_EXTCODE, "notebook/javascript")
javascript_local_path = p(SAGE_LOCAL, "notebook/javascript")
java_path       = p(SAGE_LOCAL, "java")

# the list of users waiting to register
waiting = {}

# the user database
from user_db import UserDatabase
users = UserDatabase()

_cols = None
def word_wrap_cols():
    global _cols
    if _cols is None:
        _cols = notebook.conf()['word_wrap_cols']
    return _cols

############################
# Encoding data to go between the server and client
############################
SEP = '___S_A_G_E___'

def encode_list(v):
    return SEP.join([str(x) for x in v])



############################
# Notebook autosave.
############################
# save if make a change to notebook and at least some seconds have elapsed since last save.
def init_updates():
    global save_interval, idle_interval, last_save_time, last_idle_time

    save_interval = notebook.conf()['save_interval']
    idle_interval = notebook.conf()['idle_check_interval']
    last_save_time = walltime()
    last_idle_time = walltime()

def notebook_save_check():
    global last_save_time
    t = walltime()
    if t > last_save_time + save_interval:
        notebook.save()
        last_save_time = t

def notebook_idle_check():
    global last_idle_time
    t = walltime()
    if t > last_idle_time + idle_interval:
        notebook.quit_idle_worksheet_processes()
        last_idle_time = t

def notebook_updates():
    notebook_save_check()
    notebook_idle_check()

######################################################################################
# RESOURCES
######################################################################################
def gzip_handler(request):
    """
    Add gzip compression to the request if it makes sense.
    """
    if request.host not in ('localhost', '127.0.0.1'):
        request.addResponseFilter(gzip.gzipfilter, atEnd=True)

############################
# An error message
############################
def message(msg, cont=None):
    template_dict = {'msg': msg, 'cont': cont}
    return template('error_message.html', **template_dict)

def HTMLResponse(*args, **kwds):
    """
    Returns an HTMLResponse object whose 'Content-Type' header has been set
    to 'text/html; charset=utf-8

    EXAMPLES::

        sage: from sage.server.notebook.twist import HTMLResponse
        sage: response = HTMLResponse(stream='<html><head><title>Test</title></head><body>Test</body></html>')
        sage: response.headers
        <Headers: Raw: {'content-type': ['text/html; charset=utf-8']} Parsed: {'content-type': <RecalcNeeded>}>

    """
    response = http.Response(*args, **kwds)
    response.headers.addRawHeader('Content-Type', 'text/html; charset=utf-8')
    return response


############################
# Create a Sage worksheet from a latex2html'd file
############################
doc_worksheet_number = 0
def doc_worksheet():
    global doc_worksheet_number
    wnames = notebook.worksheet_names()
    name = 'doc_browser_%s'%doc_worksheet_number
    doc_worksheet_number = doc_worksheet_number % notebook.conf()['doc_pool_size']
    if name in wnames:
        W = notebook.get_worksheet_with_name(name)
        W.clear()
    else:
        W = notebook.create_new_worksheet(name, '_sage_', docbrowser=True)
    W.set_is_doc_worksheet(True)
    return W


class WorksheetFile(resource.Resource):
    addSlash = False

    def __init__(self, path, username):
        self.docpath = path
        self.username = username

    def render(self, ctx=None):
        # Create a live Sage worksheet out of self.path and render it.
        doc_page_html = open(self.docpath).read()
        from docHTMLProcessor import SphinxHTMLProcessor
        doc_page = SphinxHTMLProcessor().process_doc_html(doc_page_html)

        title = extract_title(doc_page_html).replace('&mdash;','--')
        doc_page = title + '\nsystem:sage\n\n' + doc_page

        W = doc_worksheet()
        W.edit_save(doc_page)

        #FIXME: For some reason, an extra cell gets added
        #so we remove it here.
        cells = W.cell_list()
        cells.pop()

        s = notebook.html(worksheet_filename = W.filename(),
                          username = self.username)

        return HTMLResponse(stream=s)

    def childFactory(self, request, name):
        path = self.docpath + '/' + name
        if name.endswith('.html'):
            return WorksheetFile(path, self.username)
        else:
            return static.File(path)

############################
# The documentation browsers
############################

DOC = os.path.abspath(SAGE_DOC + '/output/html/en/')
DOC_PDF = os.path.abspath(SAGE_DOC + '/output/pdf')
DOC_REF_MEDIA = os.path.abspath(SAGE_DOC + '/en/reference/media')

class DocPDF(resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File('%s' % DOC_PDF)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File('%s/%s' % (DOC_PDF, name))

class DocRefMedia(resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File('%s' % DOC_REF_MEDIA)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File('%s/%s' % (DOC_REF_MEDIA, name))

class DocReference(resource.Resource):
    addSlash = True
    child_media = DocRefMedia()

    def render(self, ctx):
        return static.File('%s/reference/index.html' % DOC)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File('%s/reference/%s' % (DOC, name))

class DocStatic(resource.Resource):
    addSlash = True
    child_reference = DocReference()

    def render(self, ctx):
        return static.File('%s/index.html'%DOC)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File('%s/%s'%(DOC,name))

class DocLive(resource.Resource):
    addSlash = True

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        return HTMLResponse(stream=message('nothing to see.'))

    def childFactory(self, request, name):
        gzip_handler(request)
        return WorksheetFile('%s/%s'%(DOC,name), username = self.username)

class Doc(resource.Resource):
    addSlash = True
    child_static = DocStatic()

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        s = notebook.html_doc(username = self.username)
        return HTMLResponse(stream=s)

    def childFactory(self, request, name):
        if name == "live":
            gzip_handler(request)
            return DocLive(username = self.username)


############################
# SageTex browser
############################
SAGETEX_PATH = ""


class SageTex(resource.Resource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        s = notebook.html_doc(username = self.username)
        return HTMLResponse(stream=s)

    def childFactory(self, request, name):
        return WorksheetFile('%s/%s'%(SAGETEX_PATH,name),
                             username = self.username)


############################
# The source code browser
############################

SRC = os.path.abspath(os.environ['SAGE_ROOT'] + '/devel/sage/sage/')

class SourceBrowser(resource.Resource):
    addSlash = True

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        return static.File(SRC)

    def childFactory(self, request, name):
        return Source('%s/%s'%(SRC,name), self.username)

class Source(resource.Resource):
    addSlash = True

    def __init__(self, path, username):
        self.path = path
        self.username = username

    def render(self, ctx):
        filename = self.path
        if os.path.isfile(filename):
            if not os.path.exists(filename):
                src = "No such file '%s'"%filename
            else:
                src = open(filename).read()
            src = escape(src)
            return HTMLResponse(stream = template('source_code.html', src_filename=self.path, src=src, username=self.username))
        else:
            return static.File(filename)

    def childFactory(self, request, name):
        return Source(self.path + '/' + name, self.username)


############################
# A New Worksheet
############################
class NewWorksheet(resource.Resource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        W = notebook.create_new_worksheet("Untitled", self.username)
        return http.RedirectResponse('/home/'+W.filename())


############################
# Uploading a saved worksheet file
############################

def redirect(url):
    return '<html><head><meta http-equiv="REFRESH" content="0; URL=%s"></head></html>'%url

class Upload(resource.Resource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        return HTMLResponse(stream = template('upload.html', username=self.username))

class UploadWorksheet(resource.PostableResource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        url = ctx.args['urlField'][0].strip()
        dir = ''  # we will delete the directory below if it is used
        if url != '':
            # downloading a file from the internet
            filename = tmp_filename()+".sws"
        else:
            # uploading a file from the user's computer
            dir = tmp_dir()
            filename = ctx.files['fileField'][0][0]
            # Make tmp file in Sage temp directory
            filename = '%s/%s'%(dir, filename)
            f = file(filename,'wb')
            # Then download to that file.
            f.write(ctx.files['fileField'][0][2].read())
            # TODO: Server blocking issues (?!)
            f.close()


        #We make a callback so that we can download a file remotely
        #while allowing the server to still serve requests.
        def callback(result):

            if ctx.args.has_key('nameField'):
                new_name = ctx.args['nameField'][0].strip()
            else:
                new_name = None

            try:
                try:

                    if filename.endswith('.zip'):
                        # Extract all the .sws files from a zip file.
                        zip_file = zipfile.ZipFile(filename)
                        sws_file = "%s/%s" % (dir, "tmp.sws")
                        for sws in zip_file.namelist():
                            if sws.endswith('.sws'):
                                open(sws_file, 'w').write(zip_file.read(sws)) # 2.6 zip_file.extract(sws, sws_file)
                                W = notebook.import_worksheet(sws_file, self.username)
                                if new_name:
                                    W.set_name("%s - %s" % (new_name, W.name()))
                        return http.RedirectResponse('/')

                    else:
                        W = notebook.import_worksheet(filename, self.username)

                except IOError, msg:
                    print msg
                    raise ValueError, "Unfortunately, there was an error uploading the worksheet.  It could be an old unsupported format or worse.  If you desperately need its contents contact the Google group sage-support and post a link to your worksheet.  Alternatively, an sws file is just a bzip2'd tarball; take a look inside!"
                finally:
                    # Clean up the temporarily uploaded filename.
                    os.unlink(filename)
                    # if a temp directory was created, we delete it now.
                    if dir:
                        shutil.rmtree(dir)

            except ValueError, msg:
                s = "Error uploading worksheet '%s'."%msg
                return HTMLResponse(stream = message(s, '/'))

            # If the user requested in the form a specific title for
            # the worksheet set it.
            if new_name:
                W.set_name(new_name)

            return http.RedirectResponse('/home/'+W.filename())

        if url != '':
            #We use the downloadPage function which returns a
            #deferred which we are allowed to return to the server.
            #The server waits until the download is finished and then runs
            #the callback function specified.
            from twisted.web.client import downloadPage
            d = downloadPage(url, filename)
            d.addCallback(callback)
            return d
        else:
            #If we already have the file, then we
            #can just return the result of callback which will
            #give us the HTMLResponse.
            return callback(None)


############################
# A resource attached to a given worksheet.
#
# This has the name of the worksheet and the
# worksheet object itself set as attributes.
# It's much better to do it once-for-all here
# instead of doing it in the derived classes
# over and over again.
############################
class WorksheetResource:
    def __init__(self, name, username):
        self.name = name
        self.username = username
        self.worksheet = notebook.get_worksheet_with_filename(name)
        if not self.worksheet.is_published():
            self.worksheet.set_active(username)
        owner = self.worksheet.owner()
        if owner != '_sage_' and username != owner:
            if not self.worksheet.is_published():
                if not username in self.worksheet.collaborators() and user_type(username) != 'admin':
                    raise RuntimeError, "illegal worksheet access"

    def id(self, ctx):
        return int(ctx.args['id'][0])


###############################################
# Worksheet data -- a file that
# is associated with a cell in some worksheet.
# The file is stored on the filesystem.
#      /home/worksheet_name/data/cell_number/filename
##############################################
class Worksheet_savedatafile(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        if ctx.args.has_key('button_save'):
            E = ctx.args['textfield'][0]
            filename = ctx.args['filename'][0]
            dest = '%s/%s'%(self.worksheet.data_directory(), filename)
            open(dest,'w').write(E)
        return http.RedirectResponse('/home/'+self.worksheet.filename())

class Worksheet_link_datafile(WorksheetResource, resource.Resource):
    def render(self, ctx):
        target_worksheet_filename = ctx.args['target'][0]
        data_filename = ctx.args['filename'][0]
        src = os.path.abspath(self.worksheet.data_directory() + '/' +data_filename)
        target_ws =  notebook.get_worksheet_with_filename(target_worksheet_filename)
        target = os.path.abspath(target_ws.data_directory() + '/' + data_filename)
        if target_ws.owner() != self.username and not target_ws.user_is_collaborator(self.username):
            return HTMLResponse(stream=message("illegal link attempt!"))
        os.system('ln "%s" "%s"'%(src, target))
        return http.RedirectResponse('/home/'+target_ws.filename() + '/datafile?name=%s'%data_filename)


class Worksheet_upload_data(WorksheetResource, resource.Resource):
    def render(self, ctx):
        return HTMLResponse(stream = notebook.html_upload_data_window(self.worksheet, self.username))

class Worksheet_do_upload_data(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        name = ''
        if ctx.args.has_key('newField'):
            newfield = ctx.args['newField'][0].strip()
        else:
            newfield = None

        if ctx.args.has_key('nameField'):
            name = ctx.args['nameField'][0].strip()

        url = ctx.args['urlField'][0].strip()

        if not name:
            name = ctx.files['fileField'][0][0]

        if not name:
            name = newfield

        if url and not name:
            name = os.path.split(url)[-1]

        dest = '%s/%s'%(self.worksheet.data_directory(), name)
        response = http.RedirectResponse('/home/'+self.worksheet.filename() + '/datafile?name=%s'%name)

        if url != '':
            #Here we use twisted's downloadPage function which
            #returns a deferred object.  We return the deferred to the server,
            #and it will wait until the download has finished while
            #still serving other requests.  At the end of the deferred
            #callback chain should be the response that we wanted to return.
            from twisted.web.client import downloadPage

            #The callback just returns the response
            def callback(result):
                return response

            d = downloadPage(url, dest)
            d.addCallback(callback)
            return d
        elif newfield:
            open(dest,'w').close()
            return response
        else:
            f = file(dest,'wb')
            f.write(ctx.files['fileField'][0][2].read())
            f.close()
            return response


##############################################
# Download or delete a data file
##############################################

class Worksheet_datafile(WorksheetResource, resource.Resource):
    def render(self, ctx):
        dir = os.path.abspath(self.worksheet.data_directory())
        filename = ctx.args['name'][0]
        if ctx.args.has_key('action'):
            if ctx.args['action'][0] == 'delete':
                path = '%s/%s'%(self.worksheet.data_directory(), filename)
                os.unlink(path)
                return HTMLResponse(stream = message("Successfully deleted '%s'"%filename,
                                                      '/home/' + self.worksheet.filename()))
        s = notebook.html_download_or_delete_datafile(self.worksheet, self.username, filename)
        return HTMLResponse(stream=s)

##############################################
# Returns an object in the datafile directory
##############################################
class Worksheet_data(WorksheetResource, resource.Resource):
    addSlash = True

    def render(self, ctx):
        dir = os.path.abspath(self.worksheet.data_directory())
        if os.path.exists(dir):
            return static.File(dir)
        else:
            return HTMLResponse(stream = message("No data files",'..'))

    def childFactory(self, request, name):
        dir = os.path.abspath(self.worksheet.data_directory())
        return static.File('%s/%s'%(dir, name))


class CellData(resource.Resource):
    def __init__(self, worksheet, number):
        self.worksheet = worksheet
        self.number = number

    def render(self, ctx):
        return HTMLResponse(stream = message("No data file (%s)"%self.number,'..'))

    def childFactory(self, request, name):
        dir = self.worksheet.directory()
        path = '%s/cells/%s/%s'%(dir, self.number, name)
        request.setLastModified(os.stat(filename).st_mtime)
        return static.File(path)


class Worksheet_cells(WorksheetResource, resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File(self.worksheet.cells_directory())

    def childFactory(self, request, segment):
        return static.File(self.worksheet.cells_directory() + segment)
    #return CellData(self.worksheet, segment)




########################################################
# Use this to wrap a worksheet operation in a confirmation
# request.  See WorksheetDelete and WorksheetAdd for
# examples.
########################################################
## class FastRedirect(resource.Resource):
##     def __init__(self, dest):
##         self.dest = dest
##     def render(self, ctx):
##         return http.RedirectResponse(self.dest)
## class YesNo(resource.Resource):
##     addSlash = True

##     def __init__(self, mesg, yes, no):
##         self.mesg = mesg
##         self.yes = yes
##         self.no  = no

##     def render(self, ctx):
##         from sage.server.notebook.template import yes_no_template
##         lt = yes_no_template(mesg=self.mesg)
##         return HTMLResponse(stream = lt)

##         s = '%s<br>'%self.mesg
##         s += '<a href="yes">Yes</a> or <a href="no">No</a>'
##         return HTMLResponse(stream = message(s))

##     def childFactory(self, request, op):
##         if op == 'yes':
##             return FastRedirect(self.yes())
##         elif op == 'no':
##             return FastRedirect(self.no())


########################################################
# keep alive
########################################################

class Worksheet_alive(WorksheetResource, resource.Resource):
    def render(self, ctx):
        #self.worksheet.ping(self.username)
        self.worksheet.ping(username=None)  # None so doesn't save a revision
        return HTMLResponse(stream = '')

########################################################
# Worksheet configuration.
########################################################
class Worksheet_conf(WorksheetResource, resource.Resource):
    def render(self, ctx):
        conf = self.worksheet.conf()
        s = str(conf)
        # TODO: This should be a form that allows for configuring all options
        # of a given worksheet, saves the result,
        return HTMLResponse(stream = s)

class TrivialResource(resource.Resource):
    def render(self, ctx):
        return HTMLResponse(stream="success")

class Worksheet_system(WorksheetResource, resource.Resource):
    def childFactory(self, request, system):
        self.worksheet.set_system(system)
        return TrivialResource()

class Worksheet_pretty_print(WorksheetResource, resource.Resource):
    def childFactory(self, request, enable):
        self.worksheet.set_pretty_print(enable)
        return TrivialResource()



########################################################
# Cell introspection
########################################################
class Worksheet_introspect(WorksheetResource, resource.PostableResource):
    """
    Cell introspection. This is called when the user presses the tab
    key in the browser in order to introspect.
    """
    def render(self, ctx):
        try:
            id = int(ctx.args['id'][0])
        except (KeyError,TypeError):
            return HTMLResponse(stream = 'Error in introspection -- invalid cell id.')
        try:
            before_cursor = ctx.args['before_cursor'][0]
        except KeyError:
            before_cursor = ''
        try:
            after_cursor = ctx.args['after_cursor'][0]
        except KeyError:
            after_cursor = ''
        C = self.worksheet.get_cell_with_id(id)
        C.evaluate(introspect=[before_cursor, after_cursor])
        return HTMLResponse(stream = encode_list([C.next_id(),'introspect',id]))

########################################################
# Edit the entire worksheet
########################################################
class Worksheet_edit(WorksheetResource, resource.Resource):
    """
    Return a window that allows the user to edit the text of the
    worksheet with the given filename.
    """
    def render(self, ctx):
        s = notebook.html_edit_window(self.worksheet, self.username)
        return HTMLResponse(stream = s)

########################################################
# Plain text log view of worksheet
########################################################
class Worksheet_text(WorksheetResource, resource.Resource):
    """
    Return a window that allows the user to edit the text of the
    worksheet with the given filename.
    """
    def render(self, ctx):
        s = notebook.html_plain_text_window(self.worksheet, self.username)
        return HTMLResponse(stream = s)

########################################################
# Copy a worksheet
########################################################
class Worksheet_copy(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        W = notebook.copy_worksheet(self.worksheet, self.username)
        if 'no_load' in ctx.args:
            return http.StatusResponse(200, '')
        else:
            return http.RedirectResponse('/home/' + W.filename())

########################################################
# Get a copy of a published worksheet and start editing it
########################################################
class Worksheet_edit_published_page(WorksheetResource, resource.Resource):
    def render(self, ctx):
        if user_type(self.username) == 'guest':
            return HTMLResponse(stream = message(
                'You must <a href="/">login first</a> in order to edit this worksheet.'))
        ws = self.worksheet.worksheet_that_was_published()
        if ws.owner() == self.username:
            W = ws
        else:
            W = notebook.copy_worksheet(self.worksheet, self.username)
            W.set_name(self.worksheet.name())
        return http.RedirectResponse('/home/' + W.filename())

########################################################
# Save a worksheet
########################################################
class Worksheet_save(WorksheetResource, resource.PostableResource):
    """
    Save the contents of a worksheet after editing it in plain-text
    edit mode.
    """
    def render(self, ctx):
        if ctx.args.has_key('button_save'):
            E = ctx.args['textfield'][0]
            self.worksheet.edit_save(E)
            self.worksheet.record_edit(self.username)
        return http.RedirectResponse('/home/'+self.worksheet.filename())


class Worksheet_save_snapshot(WorksheetResource, resource.PostableResource):
    """
    Save a snapshot of a worksheet.
    """
    def render(self, ctx):
        self.worksheet.save_snapshot(self.username)
        return HTMLResponse(stream="saved")

class Worksheet_save_and_quit(WorksheetResource, resource.PostableResource):
    """
    Save a snapshot of a worksheet and quit.
    """
    def render(self, ctx):
        self.worksheet.save_snapshot(self.username)
        self.worksheet.quit()
        return HTMLResponse(stream="saved")

class Worksheet_discard_and_quit(WorksheetResource, resource.PostableResource):
    """
    Save a snapshot of a worksheet and quit.
    """
    def render(self, ctx):
        self.worksheet.revert_to_last_saved_state()
        self.worksheet.quit()
        return HTMLResponse(stream="saved")

class Worksheet_revert_to_last_saved_state(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        self.worksheet.revert_to_last_saved_state()
        return HTMLResponse(stream="reverted")

class Worksheet_save_and_close(WorksheetResource, resource.PostableResource):
    """
    Save a snapshot of a worksheet then quit it.
    """
    def render(self, ctx):
        self.worksheet.save_snapshot(self.username)
        self.worksheet.quit()
        return HTMLResponse(stream="saved")

########################################################
# Collaborate with others
########################################################
class Worksheet_share(WorksheetResource, resource.Resource):
    def render(self, ctx):
        s = notebook.html_share(self.worksheet, self.username)
        return HTMLResponse(stream = s)

class Worksheet_invite_collab(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        if not ctx.args.has_key('collaborators'):
            v = []
        else:
            collab = ctx.args['collaborators'][0]
            v = [x.strip() for x in collab.split(',')]
        self.worksheet.set_collaborators(v)
        return http.RedirectResponse('.')


#################################
# Revisions
#################################

class PublishWorksheetRevision(resource.Resource):
    def __init__(self, worksheet, rev):
        self.worksheet = worksheet
        self.rev = rev

    def render(self, ctx):
        W = notebook.publish_worksheet(self.worksheet, self.username)
        txt = open(self.worksheet.get_snapshot_text_filename(self.rev)).read()
        W.delete_cells_directory()
        W.edit_save(txt)
        return http.RedirectResponse('/home/'+W.filename())

class RevertToWorksheetRevision(resource.Resource):
    def __init__(self, worksheet, rev):
        self.worksheet = worksheet
        self.rev = rev

    def render(self, ctx):
        self.worksheet.save_snapshot(self.username)
        txt = open(self.worksheet.get_snapshot_text_filename(self.rev)).read()
        self.worksheet.delete_cells_directory()
        self.worksheet.edit_save(txt)
        return http.RedirectResponse('/home/'+self.worksheet.filename())

def worksheet_revision_publish(worksheet, rev, username):
    W = notebook.publish_worksheet(worksheet, username)
    txt = bz2.decompress(open(worksheet.get_snapshot_text_filename(rev)).read())
    W.delete_cells_directory()
    W.edit_save(txt)
    return http.RedirectResponse('/home/'+W.filename())

def worksheet_revision_revert(worksheet, rev, username):
    worksheet.save_snapshot(username)
    txt = bz2.decompress(open(worksheet.get_snapshot_text_filename(rev)).read())
    worksheet.delete_cells_directory()
    worksheet.edit_save(txt)
    return http.RedirectResponse('/home/'+worksheet.filename())


class Worksheet_revisions(WorksheetResource, resource.PostableResource):
    """
    Show a list of revisions of this worksheet.
    """
    def render(self, ctx):
        if not ctx.args.has_key('action'):
            if ctx.args.has_key('rev'):
                rev = ctx.args['rev'][0]
                s = notebook.html_specific_revision(self.username, self.worksheet, rev)
            else:
                s = notebook.html_worksheet_revision_list(self.username, self.worksheet)
        else:
            rev = ctx.args['rev'][0]
            action = ctx.args['action'][0]
            if action == 'revert':
                return worksheet_revision_revert(self.worksheet, rev, self.username)
            elif action == 'publish':
                return worksheet_revision_publish(self.worksheet, rev, self.username)
            else:
                s = message('Error')
        return HTMLResponse(stream = s)


########################################################
# Worksheet/User/Notebooks settings and configuration
########################################################

class Worksheet_input_settings(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        if ctx.args.has_key('button_cancel'):
            return http.RedirectResponse('/home/'+self.worksheet.filename())
        if user_type(self.username) == 'admin' or \
               self.worksheet.owner() == self.username \
               or self.worksheet.user_is_collaborator(self.username):
            system = ctx.args['system'][0].strip().lower()
            self.worksheet.set_system(system)
            if system != 'sage':
                post = ' (%s)'%system
                n = self.worksheet.name()
                i = n.rfind('(')
                if i != -1:
                    j = n.rfind(')')
                    if j != -1:
                        n = n[:i]
                n = n.strip() + post
                self.worksheet.set_name(n)
            return http.RedirectResponse('/home/'+ self.worksheet.filename())
        else:
            s = 'You must be the owner of this worksheet to configure it.'
            return HTMLResponse(stream = message(s))

class Worksheet_settings(WorksheetResource, resource.Resource):
    def render(self, ctx):
        if self.worksheet.owner() != self.username:
            s = message('You must be the owner of this worksheet to configure it.')
        else:
            s = notebook.html_worksheet_settings(self.worksheet, self.username)
        return HTMLResponse(stream = s)

class ProcessUserSettings(resource.PostableResource):
    def render(self, ctx):
        pass

#class UserSettings(resource.Resource):
#    child_process = ProcessUserSettings()
#
#    def __init__(self, username):
#        self.username = username
#
#    def render(self, ctx):
#        s = notebook.html_user_settings(self.username)
#        return HTMLResponse(stream = s)

class ProcessNotebookSettings(resource.PostableResource):
    def render(self, ctx):
        pass

class NotebookSettings(resource.Resource):
    child_process = ProcessNotebookSettings()

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        if user_type(self.username) != 'admin':
            s = message('You must an admin to configure the notebook.')
        else:
            s = notebook.html_notebook_settings()
        return HTMLResponse(stream = s)

class SettingsPage(resource.PostableResource):
    def __init__(self, username):
        self.username = username

    def render(self, request):
        error = None
        redirect_to_home = None
        redirect_to_logout  = None
        if 'autosave' in request.args:
            notebook.user(self.username)['autosave_interval'] = int(request.args['autosave'][0]) * 60
            redirect_to_home = True

        if 'Newpass' in request.args or 'RetypePass' in request.args:
            if not 'Oldpass' in request.args:
                error = 'Old password not given'
            elif not notebook.user(self.username).password_is(request.args['Oldpass'][0]):
                error = 'Incorrect password given'
            elif not 'Newpass' in request.args:
                error = 'New password not given'
            elif not 'RetypePass' in request.args:
                error = 'Please type in new password again.'
            elif request.args['Newpass'][0] != request.args['RetypePass'][0]:
                error = 'The passwords you entered do not match.'

            if not error: #webbrowser may auto fill in "old password" even though the user may not want to change her password
                notebook.change_password(self.username, request.args['Newpass'][0])
                redirect_to_logout = True
        if notebook.conf()['email']:
            if 'Newemail' in request.args:
                notebook.user(self.username).set_email(request.args['Newemail'][0])
                redirect_to_home = True

        if error:
            return HTMLResponse(stream=message(error, '/settings'))

        if redirect_to_logout:
            return http.RedirectResponse('/logout')

        if redirect_to_home:
            return http.RedirectResponse('/home/%s' % self.username)

        template_dict = {}
        template_dict['username'] = self.username
        template_dict['autosave_intervals'] = ((i, ' selected') if notebook.user(self.username)['autosave_interval']/60 == i else (i, '') for i in range(1, 10, 2))
        template_dict['email'] = notebook.conf()['email']
        if template_dict['email']:
            template_dict['email_address'] = 'None' if not notebook.user(self.username)._User__email else notebook.user(self.username)._User__email
            template_dict['email_confirmed'] = 'Not confirmed' if not notebook.user(self.username).is_email_confirmed() else 'Confirmed'
        template_dict['admin'] = user_type(self.username) == 'admin'
        return HTMLResponse(stream=template('account_settings.html', **template_dict))

########################################################
# Set output type of a cell
########################################################
class Worksheet_set_cell_output_type(WorksheetResource, resource.PostableResource):
    """
    Set the output type of the cell.

    This enables the type of output cell, such as to allowing wrapping
    for output that is very long.
    """
    def render(self, ctx):
        id = self.id(ctx)
        typ = ctx.args['type'][0]
        W = self.worksheet
        W.get_cell_with_id(id).set_cell_output_type(typ)
        return HTMLResponse(stream = '')

########################################################
# The new cell command: /home/worksheet/new_cell?id=number
########################################################
class Worksheet_new_cell_before(WorksheetResource, resource.PostableResource):
    """
    Adds a new cell before a given cell.
    """
    def render(self, ctx):
        id = self.id(ctx)
        if not ctx.args.has_key('input'):
            input = ''
        else:
            input = ctx.args['input'][0]

        cell = self.worksheet.new_cell_before(id, input=input)
        s = encode_list([cell.id(), cell.html(div_wrap=False), id])
        return HTMLResponse(stream = s)

class Worksheet_new_text_cell_before(WorksheetResource, resource.PostableResource):
    """
    Adds a new cell before a given cell.
    """
    def render(self, ctx):
        id = self.id(ctx)
        if not ctx.args.has_key('input'):
            input = ''
        else:
            input = ctx.args['input'][0]

        cell = self.worksheet.new_text_cell_before(id, input=input)
        s = encode_list([cell.id(), cell.html(editing=True), id])
        return HTMLResponse(stream = s)


class Worksheet_new_cell_after(WorksheetResource, resource.PostableResource):
    """
    Adds a new cell after a given cell.
    """
    def render(self, ctx):
        id = self.id(ctx)
        if not ctx.args.has_key('input'):
            input = ''
        else:
            input = ctx.args['input'][0]
        cell = self.worksheet.new_cell_after(id, input=input)
        s = encode_list([cell.id(), cell.html(div_wrap=False), id])
        return HTMLResponse(stream = s)

class Worksheet_new_text_cell_after(WorksheetResource, resource.PostableResource):
    """
    Adds a new text cell after a given cell.
    """
    def render(self, ctx):
        id = self.id(ctx)
        if not ctx.args.has_key('input'):
            input = ''
        else:
            input = ctx.args['input'][0]

        cell = self.worksheet.new_text_cell_after(id, input=input)
        s = encode_list([cell.id(), cell.html(editing=True), id])
        return HTMLResponse(stream = s)


########################################################
# The delete cell command: /home/worksheet/delete_cell?id=number
########################################################
class Worksheet_delete_cell(WorksheetResource, resource.PostableResource):
    """
    Deletes a notebook cell.

    If there is only one cell left in a given worksheet, the request to
    delete that cell is ignored because there must be a least one cell
    at all times in a worksheet. (This requirement exists so other
    functions that evaluate relative to existing cells will still work,
    and so one can add new cells.)
    """
    def render(self, ctx):
        id = self.id(ctx)
        W = self.worksheet
        if len(W.compute_cell_id_list()) <= 1:
            s = 'ignore'
        else:
            prev_id = W.delete_cell_with_id(id)
            s = encode_list(['delete', id, prev_id, W.cell_id_list()])
        return HTMLResponse(stream = s)


############################
# Get the latest update on output appearing
# in a given output cell.
############################
class Worksheet_cell_update(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        id = self.id(ctx)

        worksheet = self.worksheet

        # update the computation one "step".
        worksheet.check_comp()

        # now get latest status on our cell
        status, cell = worksheet.check_cell(id)

        if status == 'd':
            new_input = cell.changed_input_text()
            out_html = cell.output_html()
            H = "Worksheet '%s' (%s)\n"%(worksheet.name(), time.strftime("%Y-%m-%d at %H:%M",time.localtime(time.time())))
            H += cell.edit_text(ncols=HISTORY_NCOLS, prompts=False,
                                max_out=HISTORY_MAX_OUTPUT)
            notebook.add_to_user_history(H, self.username)
        else:
            new_input = ''
            out_html = ''

        if cell.interrupted():
            inter = 'true'
        else:
            inter = 'false'

        raw = cell.output_text(raw=True).split("\n")
        if "Unhandled SIGSEGV" in raw:
            inter = 'restart'
            print "Segmentation fault detected in output!"

        msg = '%s%s %s'%(status, cell.id(),
                       encode_list([cell.output_text(html=True),
                                    cell.output_text(word_wrap_cols(), html=True),
                                    out_html,
                                    new_input,
                                    inter,
                                    cell.introspect_html()]))

        # There may be more computations left to do, so start one if there is one.
        worksheet.start_next_comp()

        return HTMLResponse(stream=msg)


class Worksheet_eval(WorksheetResource, resource.PostableResource):
    """
    Evaluate a worksheet cell.

    If the request is not authorized (the requester did not enter the
    correct password for the given worksheet), then the request to
    evaluate or introspect the cell is ignored.

    If the cell contains either 1 or 2 question marks at the end (not
    on a comment line), then this is interpreted as a request for
    either introspection to the documentation of the function, or the
    documentation of the function and the source code of the function
    respectively.
    """
    def render(self, ctx):
        id = self.id(ctx)
        if not ctx.args.has_key('input'):
            input_text = ''
        else:
            input_text = ctx.args['input'][0]
            input_text = input_text.replace('\r\n', '\n')   # DOS

        W = self.worksheet
        owner = W.owner()
        if owner != '_sage_':
            if W.owner() != self.username and not (self.username in W.collaborators()):
               return InvalidPage(msg = "can't evaluate worksheet cells", username = self.username)
        cell = W.get_cell_with_id(id)

        cell.set_input_text(input_text)

        if ctx.args.has_key('save_only') and ctx.args['save_only'][0] == '1':
            notebook_updates()
            return HTMLResponse(stream='')
        elif ctx.args.has_key('text_only') and ctx.args['text_only'][0] == '1':
            notebook_updates()
            return HTMLResponse(stream=encode_list([str(id), cell.html()]))
        else:
            newcell = int(ctx.args['newcell'][0])  # whether to insert a new cell or not

        cell.evaluate(username = self.username)

        if cell.is_last():
            new_cell = W.append_new_cell()
            s = encode_list([new_cell.id(), 'append_new_cell', new_cell.html(div_wrap=False)])
        elif newcell:
            new_cell = W.new_cell_after(id)
            s = encode_list([new_cell.id(), 'insert_cell', new_cell.html(div_wrap=False), str(id)])
        else:
            s = encode_list([cell.next_id(), 'no_new_cell', str(id)])

        notebook_updates()
        return HTMLResponse(stream=s)


########################################################
# Publication and rating of a worksheet
########################################################

class Worksheet_publish(WorksheetResource, resource.Resource):
    """
    This is a child resource of the Worksheet resource. It provides a
    frontend to the management of worksheet publication. This management
    functionality includes initializational of publication,
    re-publication, automated publication when a worksheet saved, and
    ending of publication.
    """
    addSlash = True

    def render(self, ctx):
        # Publishes worksheet and also sets worksheet to be published automatically when saved
        if 'yes' in ctx.args and 'auto' in ctx.args:
            notebook.publish_worksheet(self.worksheet, self.username)
            self.worksheet.set_auto_publish()
            return http.RedirectResponse("/home/%s/publish" % (self.worksheet.filename()))
        # Just publishes worksheet
        elif 'yes' in ctx.args:
            notebook.publish_worksheet(self.worksheet, self.username)
            return http.RedirectResponse("/home/%s/publish" % (self.worksheet.filename()))
        # Stops publication of worksheet
        elif 'stop' in ctx.args:
            notebook.delete_worksheet(self.worksheet.published_version().filename())
            return http.RedirectResponse("/home/%s/publish" % (self.worksheet.filename()))
        # Re-publishes worksheet
        elif 're' in ctx.args:
            W = notebook.publish_worksheet(self.worksheet, self.username)
            return http.RedirectResponse("/home/%s/publish" % (self.worksheet.filename()))
        # Sets worksheet to be published automatically when saved
        elif 'auto' in ctx.args:
            self.worksheet.set_auto_publish()
            return http.RedirectResponse("/home/%s/publish" % (self.worksheet.filename()))
        # Returns boolean of "Is this worksheet set to be published automatically when saved?"
        elif 'is_auto' in ctx.args:
            return HTMLResponse(stream=str(self.worksheet.is_auto_publish()))
        # Returns the publication page
        else:
            # Page for when worksheet already published
            if self.worksheet.has_published_version():
                addr = 'http%s://' % ('' if not notebook.secure else 's')
                addr += notebook.address
                addr += ':%s' % notebook.port
                addr += '/home/' + self.worksheet.published_version().filename()
                dtime = self.worksheet.published_version().date_edited()
                return HTMLResponse(stream=notebook.html_afterpublish_window(self.worksheet, self.username, addr, dtime))
            # Page for when worksheet is not already published
            else:
                return HTMLResponse(stream=notebook.html_beforepublish_window(self.worksheet, self.username))


class Worksheet_rating_info(WorksheetResource, resource.Resource):
    def render(self, ctx):
        s = self.worksheet.html_ratings_info()
        return HTMLResponse(stream=message('''
        <h2 align=center>Ratings for %s</h2>
        <h3 align=center><a href='/home/%s'>Go to the worksheet.</a>
        <br><br>
        <table width=70%%align=center border=1 cellpadding=10 cellspacing=0>
        <tr bgcolor="#7799bb"><td width=30em>User</td><td width=10em align=center>Rating</td><td width=10em align=center width=60em>Comment</td></tr>
        %s
        </table>
        <br><br>
        '''%(self.worksheet.name(), self.worksheet.filename(), s)))


class Worksheet_rate(WorksheetResource, resource.Resource):
    def render(self, ctx):
        ret = '/home/' + self.worksheet.filename()
        #if self.worksheet.is_rater(self.username):
        #    return HTMLResponse(stream=message("You have already rated the worksheet <i><b>%s</b></i>."%self.worksheet.name(), ret))
        if user_type(self.username) == "guest":
            return HTMLResponse(stream = message(
                'You must <a href="/">login first</a> in order to rate this worksheet.', ret))

        rating = int(ctx.args['rating'][0])
        if rating < 0 or rating >= 5:
            return HTMLResponse(stream = message(
                "Gees -- You can't fool the rating system that easily!", ret))
        comment = ctx.args['comment'][0]
        self.worksheet.rate(rating, comment, self.username)
        return HTMLResponse(stream=message("""
        Thank you for rating the worksheet <b><i>%s</i></b>!
        You can <a href="rating_info">see all ratings of this worksheet.</a>
        """%self.worksheet.name(), '/pub/'))


########################################################
# Downloading, moving around, renaming, etc.
########################################################


class Worksheet_download(WorksheetResource, resource.Resource):
    def childFactory(self, request, name):
        worksheet_name = self.name
        filename = tmp_filename() + '.sws'
        try:
            notebook.export_worksheet(worksheet_name, filename)
        except KeyError:
            return HTMLResponse(stream=message('No such worksheet.'))
        r = open(filename, 'rb').read()
        os.unlink(filename)
        return static.Data(r, 'application/sage')
        #return static.File(filename)

class DownloadWorksheets(resource.Resource):

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        print type(ctx)
        worksheet_names = set()
        if ctx.args.has_key('filenames'):
            sep = ctx.args['sep'][0]
            worksheets = [notebook.get_worksheet_with_filename(x.strip()) for x in ctx.args['filenames'][0].split(sep) if len(x.strip()) > 0]
        else:
            worksheets = notebook.worksheet_list_for_user(self.username)
        zip_filename = tmp_filename() + ".zip"
        zip = zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_STORED)
        for worksheet in worksheets:
            sws_filename = tmp_filename() + '.sws'
            notebook.export_worksheet(worksheet.filename(), sws_filename)
            entry_name = worksheet.name()
            if entry_name in worksheet_names:
                i = 2
                while ("%s_%s" % (entry_name, i)) in worksheet_names:
                    i += 1
                entry_name = "%s_%s" % (entry_name, i)
            zip.write(sws_filename, entry_name + ".sws")
            os.unlink(sws_filename)
        zip.close()
        r = open(zip_filename, 'rb').read()
        os.unlink(zip_filename)
        return static.Data(r, 'application/zip')

class Worksheet_rename(WorksheetResource, resource.PostableResource):
    def render(self, ctx):
        self.worksheet.set_name(ctx.args['name'][0])
        return HTMLResponse(stream='done')

class Worksheet_restart_sage(WorksheetResource, resource.Resource):
    def render(self, ctx):
        # TODO -- this must not block long (!)
        self.worksheet.restart_sage()
        return HTMLResponse(stream='done')

class Worksheet_quit_sage(WorksheetResource, resource.Resource):
    def render(self, ctx):
        # TODO -- this must not block long (!)
        self.worksheet.quit()
        return HTMLResponse(stream='done')

class Worksheet_interrupt(WorksheetResource, resource.Resource):
    def render(self, ctx):
        # TODO -- this must not block long (!)
        s = self.worksheet.interrupt()
        return HTMLResponse(stream='ok' if s else 'failed')

class Worksheet_plain(WorksheetResource, resource.Resource):
    def render(self, ctx):
        s = notebook.plain_text_worksheet_html(self.name)
        return HTMLResponse(stream=s)

class Worksheet_hide_all(WorksheetResource, resource.Resource):
    def render(self, ctx):
        self.worksheet.hide_all()
        return HTMLResponse(stream='success')

class Worksheet_show_all(WorksheetResource, resource.Resource):
    def render(self, ctx):
        self.worksheet.show_all()
        return HTMLResponse(stream='success')


# Delete all the output of cells in a worksheet.
class Worksheet_delete_all_output(WorksheetResource, resource.Resource):
    def render(self, ctx):
        try:
            self.worksheet.delete_all_output(self.username)
        except ValueError:
            return HTMLResponse(stream='fail')
        return HTMLResponse(stream='success')

class Worksheet_print(WorksheetResource, resource.Resource):
    def render(self, ctx):
        s = notebook.worksheet_html(self.name, do_print=True)
        return HTMLResponse(stream=s)


class NotImplementedWorksheetOp(resource.Resource):
    def __init__(self, op, ws):
        self.op = op
        self.ws = ws

    def render(self, ctx):
        return HTMLResponse(stream = message(
            'The worksheet operation "%s" is not defined.'%self.op,
            '/home/'+self.ws.filename()))


class Worksheet(WorksheetResource, resource.Resource):
    addSlash = True

    def render(self, ctx):
        self.worksheet.sage()
        s = notebook.html(worksheet_filename = self.name,  username=self.username)
        return HTMLResponse(stream=s)

    def childFactory(self, request, op):
        notebook_updates()
        try:
            # Rather than a bunch of if-else statements, we wrap
            # any Worksheet_... class as a subresource of a worksheet
            # using the following  statement:
            R = globals()['Worksheet_%s'%op]
            return R(self.name, username = self.username)
        except KeyError:
            file = self.worksheet.data_directory() + '/' + op
            if os.path.exists(file):
                return static.File(file)
            dir = self.worksheet.cells_directory()
            for F in os.listdir(dir):
                h = '%s/%s/%s'%(dir,F,op)
                if os.path.exists(h):
                    return static.File(h)
            return NotImplementedWorksheetOp(op, self.worksheet)


def render_worksheet_list(args, pub, username):
    """
    Returns a rendered worksheet listing.

    INPUT:


    -  ``args`` - ctx.args where ctx is the dict passed
       into a resource's render method

    -  ``pub`` - boolean, True if this is a listing of
       public worksheets

    -  ``username`` - the user whose worksheets we are
       listing


    OUTPUT: a string
    """
    from sage.server.notebook.notebook import sort_worksheet_list
    typ = args['typ'][0] if 'typ' in args else 'active'
    search = args['search'][0] if 'search' in args else None
    sort = args['sort'][0] if 'sort' in args else 'last_edited'
    reverse = (args['reverse'][0] == 'True') if 'reverse' in args else False

    if not pub:
        worksheets = notebook.worksheet_list_for_user(username, typ=typ, sort=sort,
                                                      search=search, reverse=reverse)

    else:
        worksheets = notebook.worksheet_list_for_public(username, sort=sort,
                                                        search=search, reverse=reverse)

    worksheet_filenames = [x.filename() for x in worksheets]

    if pub and (not username or username == tuple([])):
        username = 'pub'

    accounts = notebook.get_accounts()

    return template('worksheet_listing.html', **locals())


class WorksheetsByUser(resource.Resource):
    addSlash = True

    def __init__(self, user, username):
        # user -- who we're requesting the worksheets of
        # username -- who is doing the requesting
        self.user = user
        self.username = username

    def render_list(self, ctx):
        s = render_worksheet_list(ctx.args, pub=False, username=self.user)
        return HTMLResponse(stream = s)

    def render(self, ctx):
        if self.user == self.username or user_type(self.username) == 'admin':
            return self.render_list(ctx)
        else:
            if not self.username == 'guest':
                s = message("User '%s' does not have permission to view the home page of '%s'."%(self.username, self.user))
            else:
                return http.RedirectResponse('/')
            return HTMLResponse(stream = s)

    def childFactory(self, request, name):
        if name == "trash":
            return TrashCan(self.user)

        filename = self.user + '/' + name
        try:
            return Worksheet(filename, self.username)
        except KeyError:
            s = "The user '%s' has no worksheet '%s'."%(self.user, name)
            return InvalidPage(msg = s, username = self.user)
        except RuntimeError:
            s = "You are not logged in or do not have access to the worksheet '%s'."%name
            return InvalidPage(msg = s, username = self.user)



############################
# Trash can, archive and active
############################
class EmptyTrash(resource.Resource):
    def __init__(self, username):
        """
        This twisted resource empties the trash of the current user when it
        is rendered.

        EXAMPLES: We create an instance of this resource.

        ::

            sage: import sage.server.notebook.twist
            sage: E = sage.server.notebook.twist.EmptyTrash('sage'); E
            <sage.server.notebook.twist.EmptyTrash object at ...>
        """
        self.username = username

    def render(self, ctx):
        """
        Rendering this resource (1) empties the trash, and (2) returns a
        message.

        EXAMPLES: We create a notebook with a worksheet, put it in the
        trash, then empty the trash by creating and rendering this
        worksheet.

        ::

            sage: n = sage.server.notebook.notebook.Notebook('notebook-test')
            sage: n.add_user('sage','sage','sage@sagemath.org',force=True)
            sage: W = n.new_worksheet_with_title_from_text('Sage', owner='sage')
            sage: W.move_to_trash('sage')
            sage: n.worksheet_names()
            ['sage/0']
            sage: sage.server.notebook.twist.notebook = n
            sage: E = sage.server.notebook.twist.EmptyTrash('sage'); E
            <sage.server.notebook.twist.EmptyTrash object at ...>
            sage: E.render(None)
            <twisted.web2.http.Response code=200, streamlen=...>

        Finally we verify that the trashed worksheet is gone::

            sage: n.worksheet_names()
            []
            sage: n.delete()
        """
        notebook.empty_trash(self.username)
        return HTMLResponse(stream = message("Trash emptied."))

class SendWorksheetToFolder(resource.PostableResource):
    def __init__(self, username):
        self.username = username

    def action(self, W):
        raise NotImplementedError

    def render(self, ctx):
        X = notebook.user(self.username)
        if user_type(self.username) == 'guest':
            return HTMLResponse(stream = message("You are not authorized to move '%s'"%W.name()))

        def send_worksheet_to_folder(filename):
            W = notebook.get_worksheet_with_filename(filename)
            self.action(W)

        if ctx.args.has_key('filename'):
            filenames = [ctx.args['filename'][0]]
        elif ctx.args.has_key('filenames'):
            sep = ctx.args['sep'][0]
            filenames = [x for x in ctx.args['filenames'][0].split(sep) if len(x.strip()) > 0]

        else:

            filenames = []

        for F in filenames:
            send_worksheet_to_folder(F)

        return HTMLResponse(stream = '')

class SendWorksheetToTrash(SendWorksheetToFolder):
    def action(self, W):
        W.move_to_trash(self.username)

class SendWorksheetToArchive(SendWorksheetToFolder):
    def action(self, W):
        W.move_to_archive(self.username)

class SendWorksheetToActive(SendWorksheetToFolder):
    def action(self, W):
        W.set_active(self.username)

# Using SendWorksheet does feel somewhat hackish.  It however is
# exactly the right thing to actually do, and minimizes code
# duplication.
class SendWorksheetToStop(SendWorksheetToFolder):
    """
    Quits each selected worksheet.
    """
    def action(self, W):
        W.quit()

############################
# Publicly Available Worksheets
############################
class PublicWorksheets(resource.Resource):
    addSlash = True

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        s = render_worksheet_list(ctx.args, pub=True, username=self.username)
        return HTMLResponse(stream = s)

    def childFactory(self, request, name):
        return Worksheet('pub/' + name, username=self.username)

class PublicWorksheetsHome(resource.Resource):
    addSlash = True

    def __init__(self, username):
        self.username = username

    def childFactor(self, request, name):
        if name == 'pub':
            return PublicWorksheets(self.username)

############################
# Resource that gives access to worksheets
############################

class Worksheets(resource.Resource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        return HTMLResponse(stream = message("Please request a specific worksheet"))

    def childFactory(self, request, name):
        return WorksheetsByUser(name, username=self.username)


class WorksheetsByUserAdmin(WorksheetsByUser):
    def render(self, ctx):
        return self.render_list(ctx)

class WorksheetsAdmin(Worksheets):
    def childFactory(self, request, name):
        return WorksheetsByUserAdmin(name, username=self.username)

############################
# Notebook configuration
############################

class NotebookConf(Worksheets):
    def render(self, ctx):
        s = '<html>' + notebook.conf().html_conf_form('submit') + '</html>'
        return HTMLResponse(stream = s)



############################
# Adding a new worksheet
############################

class AddWorksheet(resource.Resource):
    def render(self, ctx):
        name = ctx.args['name'][0]
        W = notebook.create_new_worksheet(name)
        v = notebook.worksheet_list_html(W.name())
        return HTMLResponse(stream = encode_list([v, W.name()]))


############################

class Help(resource.Resource):
    addSlash = True
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        from tutorial import notebook_help
        return HTMLResponse(stream=template('docs.html', username=self.username, notebook_help=notebook_help))


############################

############################

class History(resource.Resource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        t = template('history.html', username=self.username,
                     text = notebook.user_history_text(self.username),
                     actions=False)
        return HTMLResponse(stream=t)

class LiveHistory(resource.Resource):
    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        W = notebook.create_new_worksheet_from_history('Log', self.username, 100)
        return http.RedirectResponse('/home/'+W.filename())


############################

class Main_css(resource.Resource):
    def render(self, ctx):
        s = css.css()
        gzip_handler(ctx)
        response = http.Response(stream=s)
        response.headers.addRawHeader('Content-Type', 'text/css; charset=utf-8')
        return response

class Reset_css(resource.Resource):
    def render(self, ctx):
        s = css.reset
        gzip_handler(ctx)
        return http.Response(stream=s)

class CSS(resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File(css_path)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File(css_path + "/" + name)

setattr(CSS, 'child_main.css', Main_css())
setattr(CSS, 'child_reset.css', Reset_css())

############################


############################
# Javascript resources
############################

class Main_js(resource.Resource):
    def render(self, ctx):
        gzip_handler(ctx)
        s = js.javascript()
        return http.Response(stream=s)


class Keyboard_js_specific(resource.Resource):
    def __init__(self, browser_os):
        self.s = keyboards.get_keyboard(browser_os)

    def render(self, ctx):
        gzip_handler(ctx)
        return http.Response(stream = self.s)


class Keyboard_js(resource.Resource):
    def childFactory(self, request, browser_os):
        gzip_handler(request)
        return Keyboard_js_specific(browser_os)

class Javascript(resource.Resource):
    addSlash = True
    child_keyboard = Keyboard_js()

    def render(self, ctx):
        return static.File(javascript_path)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File(javascript_path + "/" + name)

setattr(Javascript, 'child_main.js', Main_js())


class JavascriptLocal(resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File(javascript_local_path)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File(javascript_local_path + "/" + name)



############################
# Java resources
############################

class Java(resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File(java_path)

    def childFactory(self, request, name):
        gzip_handler(request)
        return static.File(java_path + "/" + name)

############################
# Logout
############################
class Logout(resource.Resource):
    def render(self, ctx):
        # TODO -- actually log out.
        s = message("<br>Thank you for using Sage.<br><br><a href='/'>Please login and use Sage again soon.</a><br>")
        return HTMLResponse(stream=s)

############################
# Image resource
############################

class Images(resource.Resource):
    addSlash = True

    def render(self, ctx):
        return static.File(image_path)

    def childFactory(self, request, name):
        return static.File(image_path + "/" + name)

#####################################
# Confirmation of registration
####################################
class RegConfirmation(resource.Resource):
    def render(self, request):
        if not notebook.conf()['email']:
            return HTMLResponse(stream=message('The confirmation system is not active.'))
        key = request.args['key'][0]
        invalid_confirm_key = """\
<h1>Invalid confirmation key</h1>
<p>You are reporting a confirmation key that has not been assigned by this
server. Please <a href="/register">register</a> with the server.</p>
"""
        key = int(key)
        global waiting
        try:
            username = waiting[key]
            user = notebook.user(username)
            user.set_email_confirmation(True)
        except KeyError:
            return HTMLResponse(stream=message(invalid_confirm_key, '/register'))
        success = """<h1>Email address confirmed for user %s</h1>""" % username
        del waiting[key]
        return HTMLResponse(stream=message(success))

############################
# Registration page
############################
import re
re_valid_username = re.compile('[a-z|A-Z|0-9|_|.]*')
def is_valid_username(username):
    r"""
    Returns True if and only if ``username`` is valid,
    i.e., starts with a letter, is between 4 and 32 characters long,
    and contains only letters, numbers, underscores, and and one dot
    (.).

    EXAMPLES::

        sage: from sage.server.notebook.twist import is_valid_username

    ``username`` must start with a letter

    ::

        sage: is_valid_username('mark10')
        True
        sage: is_valid_username('10mark')
        False

    ``username`` must be between 4 and 32 characters long

    ::

        sage: is_valid_username('bob')
        False
        sage: is_valid_username('I_love_computer_science_and_maths') #33 characters long
        False

    ``username`` must not have more than one dot (.)

    ::

        sage: is_valid_username('david.andrews')
        True
        sage: is_valid_username('david.m.andrews')
        False
        sage: is_valid_username('math125.TA.5')
        False

    ``username`` must not have any spaces

    ::

        sage: is_valid_username('David Andrews')
        False
        sage: is_valid_username('David M. Andrews')
        False

    ::

        sage: is_valid_username('sarah_andrews')
        True

    ::

        sage: is_valid_username('TA-1')
        False
        sage: is_valid_username('math125-TA')
        False

    ::

        sage: is_valid_username('dandrews@sagemath.org')
        False
    """
    import string

    if not (len(username) > 3 and len(username) < 33):
        return False
    if not username[0] in string.letters:
        return False
    if '.' in username:
        if username.count('.') > 1:
            return False

    m = re_valid_username.match(username)
    return m.start() == 0 and m.end() == len(username)

def is_valid_password(password, username):
    r"""
    Return True if and only if ``password`` is valid, i.e.,
    is between 6 and 32 characters long, doesn't contain space(s), and
    doesn't contain ``username``.

    EXAMPLES::

        sage: from sage.server.notebook.twist import is_valid_password
        sage: is_valid_password('uip@un7!', None)
        True
        sage: is_valid_password('markusup89', None)
        True
        sage: is_valid_password('8u7', None)
        False
        sage: is_valid_password('fUmDagaz8LmtonAowjSe0Pvu9C5Gvr6eKcC6wsAT', None)
        False
        sage: is_valid_password('rrcF !u78!', None)
        False
        sage: is_valid_password('markusup89', 'markus')
        False
    """
    import string
    if len(password) < 6 or len(password) > 32 or ' ' in password:
        return False
    if username:
        if string.lower(username) in string.lower(password):
            return False
    return True

def do_passwords_match(pass1, pass2):
    """
    EXAMPLES::

        sage: from sage.server.notebook.twist import do_passwords_match
        sage: do_passwords_match('momcat', 'mothercat')
        False
        sage: do_passwords_match('mothercat', 'mothercat')
        True
    """
    return pass1 == pass2

def is_valid_email(email):
    """
    from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65215

    EXAMPLES::

        sage: from sage.server.notebook.twist import is_valid_email
        sage: is_valid_email('joe@washinton.gov')
        True
        sage: is_valid_email('joe.washington.gov')
        False
    """
    if len(email) > 7:
        if re.match("^[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\.[a-zA-Z]{2,6}$", email) != None:
            return True
    return False

class RegistrationPage(resource.PostableResource):
    def __init__(self, userdb):
        self.userdb = userdb

    def render(self, request):
        input_boxes = ['username', 'password', 'retype_password']
        is_valid_dict = {'username': is_valid_username, 'password': is_valid_password,
                         'retype_password': do_passwords_match, 'email': is_valid_email}

        missing = [False] * len(input_boxes)
        filled_in = {}
        template_dict = {}

        def errors_found():
            for key, value in filled_in.iteritems():
                template_dict[key] = value
            minus = 1 if 'email' in template_dict else 0
            size = len(template_dict) - minus
            count = 0
            boxes = []
            if size == 1:
                return ('',)
            for i in template_dict:
                if '_' in i:
                    count += 1
            plural = True if count > 1 else False
            template_dict['error'] = 'Es ' if plural else 'E '

        if notebook.conf()['email']:
            template_dict['email'] = True

        if set(input_boxes) <= set(request.args):
            for i, box in enumerate(input_boxes):
                filled_in[box] = request.args[box][0]
                if box == 'retype_password':
                    if not is_valid_dict[box](filled_in[box], filled_in['password']):
                        template_dict['passwords_dont_match'] = True
                elif box == 'password':
                    if 'username' in filled_in:
                        u = filled_in['username']
                    else:
                        u = None
                    if not is_valid_dict[box](filled_in[box], u):
                        template_dict['password_invalid'] = True
                else:
                    if not is_valid_dict[box](filled_in[box]):
                        template_dict[box + '_invalid'] = True
        else:
            for i, box in enumerate(input_boxes):
                if not box in request.args:
                    missing[i] = True

            if set(missing) == set([True]):
                return HTMLResponse(stream=template('registration.html', **template_dict))
            elif set(missing) == set([False]):
                for i, box in enumerate(input_boxes):
                    filled_in[box] = request.args[box][0]
                    if box == 'retype_password':
                        if not is_valid_dict[box](filled_in[box], filled_in['password']):
                            template_dict['passwords_dont_match'] = True
                    elif box == 'password':
                        if 'username' in filled_in:
                            u = filled_in['username']
                        else:
                            u = None
                        if not is_valid_dict[box](filled_in[box], u):
                            template_dict['password_invalid'] = True
                    else:
                        if not is_valid_dict[box](filled_in[box]):
                            template_dict[box + '_invalid'] = True
            else:
                for i, value in enumerate(missing):
                    if value:
                        template_dict[input_boxes[i] + '_missing'] = True
                    elif not value:
                        filled_in[input_boxes[i]] = request.args[input_boxes[i]][0]

        if template_dict and set(template_dict) != set(['email']):
            errors_found()
            return HTMLResponse(stream=template('registration.html', **template_dict))
        else:
            try:
                e = filled_in['email'] if notebook.conf()['email'] else ''
                self.userdb.add_user(filled_in['username'], request.args['password'][0],
                                     e, force=True)
            except ValueError:
                template_dict['username_taken'] = True
                errors_found()
                return HTMLResponse(stream=template('registration.html', **template_dict))

            if notebook.conf()['email']:
                destaddr = filled_in['email']
                from sage.server.notebook.smtpsend import send_mail
                from sage.server.notebook.register import make_key, build_msg
                # TODO: make this come from the server settings
                key = make_key()
                listenaddr = notebook.address
                port = notebook.port
                fromaddr = 'no-reply@%s' % listenaddr
                body = build_msg(key, filled_in['username'], listenaddr, port,
                                 notebook.secure)

                # Send a confirmation message to the user.
                try:
                    send_mail(fromaddr, destaddr, "Sage Notebook Registration",body)
                    waiting[key] = filled_in['username']
                except ValueError:
                    pass

            template_dict = {'accounts': notebook.get_accounts(),
                             'default_user': notebook.default_user(),
                             'welcome': filled_in['username'],
                             'recovery': notebook.conf()['email']}
            return HTMLResponse(stream=template('login.html', **template_dict))

class ForgotPassPage(resource.Resource):

    def render(self, request):
        if not notebook.conf()['email']:
            return HTMLResponse(stream=message('The account recovery system is not active.'))

        if request.args.has_key('username'):
            def error(msg):
                return HTMLResponse(stream=message(msg, '/forgotpass'))

            try:
                import string
                user = notebook.user(request.args[string.strip('username')][0])
            except KeyError:
                return error('Username is invalid.')

            if not user.is_email_confirmed():
                return error("The e-mail address hasn't been confirmed.")

            from random import choice
            import string
            chara = string.letters + string.digits
            old_pass = user.password()
            password = ''.join([choice(chara) for i in range(8)])
            user.set_password(password)

            from sage.server.notebook.smtpsend import send_mail
            from sage.server.notebook.register import build_password_msg
            # TODO: make this come from the server settings

            listenaddr = notebook.address
            port = notebook.port
            fromaddr = 'no-reply@%s' % listenaddr
            body = build_password_msg(password, request.args[string.strip('username')][0], listenaddr, port, notebook.secure)
            destaddr = user.get_email()
            try:
                send_mail(fromaddr, destaddr, "Sage Notebook Account Recovery",body)
            except ValueError:
                # the email address is invalid
                user.set_password(oldpass)
                return error("The new password couldn't be sent."%destaddr)

            return HTMLResponse(stream=message("A new password has been sent to your e-mail address.", '/'))
        else:
            s = template('account_recovery.html')
        return HTMLResponse(stream=s)

class ListOfUsers(resource.Resource):
    addSlash = True

    def __init__(self, username):
        self.username = username

    def render(self, ctx):
        template_dict = {}

        if 'reset' in ctx.args:
            user = ctx.args['reset'][0]
            from random import choice
            import string
            chara = string.letters + string.digits
            password = ''.join([choice(chara) for i in range(8)])
            try:
                U = notebook.user(user)
                U.set_password(password)
            except KeyError:
                pass
            template_dict['reset'] = [user, password]

        if 'suspension' in ctx.args:
            user = ctx.args['suspension'][0]
            try:
                U = notebook.user(user)
                U.set_suspension()
            except KeyError:
                pass

        template_dict['number_of_users'] = len(notebook.valid_login_names()) if len(notebook.valid_login_names()) > 1 else None
        users = sorted(notebook.valid_login_names())
        del users[users.index('admin')]
        template_dict['users'] = [notebook.user(i) for i in users]
        return HTMLResponse(stream = template('user_management.html', **template_dict))

class AdminAddUser(resource.PostableResource):
    def __init__(self, userdb):
        self.userdb = userdb

    def render(self, request):

        if 'username' in request.args:
            username = request.args['username'][0]
            if not is_valid_username(username):
                return HTMLResponse(stream=template('admin_add_user.html', error='username_invalid', username=username))

            from random import choice
            import string
            chara = string.letters + string.digits
            password = ''.join([choice(chara) for i in range(8)])
            if username in notebook.usernames():
                return HTMLResponse(stream=template('admin_add_user.html', error='username_taken', username=username))
            notebook.add_user(username, password, '', force=True)
            return HTMLResponse(stream=message('The temporary password for the new user <em>%s</em> is <em>%s</em>' % (username, password), '/adduser'))
        else:
            return HTMLResponse(stream=template('admin_add_user.html'))

class InvalidPage(resource.Resource):
    addSlash = True

    def __init__(self, msg, username):
        self.msg = msg
        self.username = username

    def render(self, ctx):
        if self.msg:
            s = self.msg
        else:
            s = "This is an invalid page."
            if self.username == 'guest':
                s += ' You might have to login to view this page.'
        return HTMLResponse(stream = message(s, '/'))

    def childFactory(self, request, name):
        return InvalidPage(msg = self.msg, username = self.username)


class RedirectLogin(resource.PostableResource):
    def render(self, ctx):
        return http.RedirectResponse('/')
    def childFactory(self, request, name):
        return RedirectLogin()

import sage.server.simple.twist

class Toplevel(resource.PostableResource):
    child_login = RedirectLogin()
    child_simple = sage.server.simple.twist.SimpleServer()

    def __init__(self, cookie, username):
        self.cookie = cookie
        self.username = username if username else 'guest'

    def render(self, ctx):
        template_dict = {'accounts': notebook.get_accounts(),
                         'default_user': notebook.default_user(),
                         'recovery': notebook.conf()['email']}
        return HTMLResponse(stream=template('login.html', **template_dict))

    def userchildFactory(self, request, name):
        return InvalidPage(msg = "unauthorized request", username = self.username)

    def childFactory(self, request, name):
        return self.userchildFactory(request, name)

setattr(Toplevel, 'child_favicon.ico', static.File(image_path + '/favicon.ico'))

class LoginResourceClass(resource.Resource):
    def render(self, ctx):
        template_dict = {'accounts': notebook.get_accounts(),
                         'default_user': notebook.default_user(),
                         'recovery': notebook.conf()['email']}
        return HTMLResponse(stream=template('login.html', **template_dict))

    def childFactory(self, request, name):
        return LoginResource

LoginResource = LoginResourceClass()

class AnonymousToplevel(Toplevel):
    from sage.server.notebook.avatars import PasswordChecker
    addSlash = True
    child_register = RegistrationPage(PasswordChecker())
    child_confirm = RegConfirmation()
    child_forgotpass = ForgotPassPage()

    child_images = Images()
    child_css = CSS()
    child_javascript = Javascript()
    child_javascript_local = JavascriptLocal()
    child_java = Java()
    child_logout = RedirectLogin()

    def userchildFactory(self, request, name):
        # This is called from Toplevel above
        try:
            return AnonymousToplevel.__dict__['userchild_%s'%name](username = self.username)
        except KeyError:
            pass

    userchild_home = Worksheets
    userchild_pub = PublicWorksheets
    userchild_src = SourceBrowser

    #child_login = LoginResource

    def render(self, ctx):
        template_dict = {'accounts': notebook.get_accounts(),
                         'default_user': notebook.default_user(),
                         'recovery': notebook.conf()['email']}
        response = HTMLResponse(stream=template('login.html', **template_dict))
        response.headers.setHeader("set-cookie", [http_headers.Cookie('cookie_test', 'cookie_test')])
        return response

class FailedToplevel(Toplevel):
    def __init__(self, info, problem, username=None):
        self.info = info
        self.problem= problem
        self.username = username

    def render(self, ctx):
        # Since public access is allowed, which lists usernames in the published
        # worksheets and ratings, this gives no new information away.
        # If published pages were disabled, then this should be disabled too.
        if self.problem == 'username':
            template_dict = {'accounts': notebook.get_accounts(),
                             'default_user': notebook.default_user(),
                             'username_error': True,
                             'recovery': notebook.conf()['email']}
            return HTMLResponse(stream=template('login.html', **template_dict))
        elif self.problem == 'password':
            template_dict = {'accounts': notebook.get_accounts(),
                             'default_user': self.username,
                             'password_error': True,
                             'recovery': notebook.conf()['email']}
            return HTMLResponse(stream=template('login.html', **template_dict))
        elif self.problem == 'suspended':
            return HTMLResponse(stream = message("Your account is currently suspended."))
        else:
            return HTMLResponse(stream = message("Please enable cookies and try again."))


class UserToplevel(Toplevel):
    addSlash = True

    child_pdf = DocPDF()
    child_images = Images()
    child_css = CSS()
    child_javascript = Javascript()
    child_javascript_local = JavascriptLocal()
    child_java = Java()

    child_logout = Logout()

    child_confirm = RegConfirmation()



    #child_login = RedirectLogin()

    # userchild_* is like Twisted's child_, etc. except:
    #  (1) it also sets the username in the __init__ method, and
    #  (2) it calls the constructor for the object, i.e., it is
    #      a class rather than an object.
    # NOTE: If you overload childFactory in any derived class, you
    # better call userchildFactory it in the base class (Toplevel)!
    def userchildFactory(self, request, name):
        try:
            return UserToplevel.__dict__['userchild_%s'%name](username = self.username)
        except KeyError:
            pass

    userchild_doc = Doc
    userchild_sagetex = SageTex
    userchild_help = Help
    userchild_history = History
    userchild_home = Worksheets
    userchild_live_history = LiveHistory
    userchild_new_worksheet = NewWorksheet
    userchild_notebook_settings = NotebookSettings
    userchild_settings = SettingsPage
    userchild_pub = PublicWorksheets
    userchild_upload = Upload
    userchild_download_worksheets = DownloadWorksheets

    userchild_send_to_trash = SendWorksheetToTrash
    userchild_send_to_archive = SendWorksheetToArchive
    userchild_send_to_active = SendWorksheetToActive
    userchild_send_to_stop = SendWorksheetToStop

    userchild_src = SourceBrowser
    userchild_upload_worksheet = UploadWorksheet
    userchild_emptytrash = EmptyTrash

    def render(self, request):
        # This resource always does a redirect to the user's home directory
        # so that after login (which is a POST operation), the postdata will not remain
        # in the browser on return.  This method is sometimes
        # referred to as the post-redirect-get method.
        response = http.RedirectResponse("/home/%s" % self.username)
        # This allows a Notebook user to select a "remember me" checkbox and not have to
        # sign back in when she restarts her web browser
        # This works by setting an expiration date because without one the browser forgets the cookie.
        if 'remember' in request.args:
            response.headers.setHeader("set-cookie", [http_headers.Cookie('nb_session', self.cookie, expires=(time.time() + 60 * 60 * 24 * 14)), http_headers.Cookie('cookie_test', self.cookie, expires=1)])
        else:
            response.headers.setHeader("set-cookie", [http_headers.Cookie('nb_session', self.cookie), http_headers.Cookie('cookie_test', self.cookie, expires=1)])
        return response


class AdminToplevel(UserToplevel):
    addSlash = True

    userchild_home = WorksheetsAdmin
    child_users = ListOfUsers
    child_adduser = AdminAddUser

def user_type(username):
    # one of admin, guest, user
    try:
        U = notebook.user(username)
    except KeyError:
        return 'guest'
    return U.account_type()

def extract_title(html_page):
    h = html_page.lower()
    i = h.find('<title>')
    if i == -1:
        return "Untitled"
    j = h.find('</title>')
    return html_page[i + len('<title>') : j]
