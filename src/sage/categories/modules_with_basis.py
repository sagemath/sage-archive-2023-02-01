r"""
Modules With Basis

AUTHORS:
- Nicolas M. Thiery (2008-2010): initial revision
- Jason Bandlow & Florent Hivert (2010): Triangular Morphisms
- Christian Stump (2010): #9648: module_morphism's to a wider class of codomains
"""
#*****************************************************************************
#  Copyright (C) 2008 Teresa Gomez-Diaz (CNRS) <Teresa.Gomez-Diaz@univ-mlv.fr>
#                2008-2009 Nicolas M. Thiery <nthiery at users.sf.net>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#******************************************************************************

from sage.misc.lazy_attribute import lazy_attribute
from sage.misc.cachefunc import cached_method
from sage.misc.misc import attrcall
from sage.misc.superseded import deprecated_function_alias
from sage.misc.sage_itertools import max_cmp, min_cmp
from sage.categories.all import Sets, CommutativeAdditiveSemigroups, Modules, HomCategory, Homset
from sage.categories.cartesian_product import CartesianProductsCategory
from sage.categories.tensor import tensor, TensorProductsCategory
from sage.categories.dual import DualObjectsCategory
from sage.categories.category_types import Category_over_base_ring
from sage.categories.morphism import SetMorphism, Morphism
from sage.categories.sets_with_partial_maps import SetsWithPartialMaps
from sage.categories.homset import Hom
from sage.structure.element import Element, parent

class ModulesWithBasis(Category_over_base_ring):
    """
    The category of modules with a distinguished basis

    The elements are represented by expanding them in the distinguished basis.
    The morphisms are not required to respect the distinguished basis.

    EXAMPLES::

        sage: ModulesWithBasis(ZZ)
        Category of modules with basis over Integer Ring
        sage: ModulesWithBasis(ZZ).super_categories()
        [Category of modules over Integer Ring]

    If the base ring is actually a field, this is a subcategory of
    the category of abstract vector fields::

        sage: ModulesWithBasis(RationalField()).super_categories()
        [Category of vector spaces over Rational Field]

    Let `X` and `Y` be two modules with basis. We can build `Hom(X,Y)`::

        sage: X = CombinatorialFreeModule(QQ, [1,2]); X.__custom_name = "X"
        sage: Y = CombinatorialFreeModule(QQ, [3,4]); Y.__custom_name = "Y"
        sage: H = Hom(X, Y); H
        Set of Morphisms from X to Y in Category of modules with basis over Rational Field

    The simplest morphism is the zero map::

        sage: H.zero()         # todo: move this test into module once we have an example
        Generic morphism:
          From: X
          To:   Y

    which we can apply to elements of X::

        sage: x = X.monomial(1) + 3 * X.monomial(2)
        sage: H.zero()(x)
        0

    TESTS::

        sage: f = H.zero().on_basis()
        sage: f(1)
        0
        sage: f(2)
        0

    EXAMPLES:

    We now construct a more interesting morphism by extending a
    function by linearity::

        sage: phi = H(on_basis = lambda i: Y.monomial(i+2)); phi
        Generic morphism:
          From: X
          To:   Y
        sage: phi(x)
        B[3] + 3*B[4]

    We can retrieve the function acting on indices of the basis::

        sage: f = phi.on_basis()
        sage: f(1), f(2)
        (B[3], B[4])

    `Hom(X,Y)` has a natural module structure (except for the zero,
    the operations are not yet implemented though). However since the
    dimension is not necessarily finite, it is not a module with
    basis; but see FiniteDimensionalModulesWithBasis and
    GradedModulesWithBasis::

        sage: H in ModulesWithBasis(QQ), H in Modules(QQ)
        (False, True)

    Some more playing around with categories and higher order homsets::

        sage: H.category()
        Category of hom sets in Category of modules with basis over Rational Field
        sage: Hom(H, H).category()
        Category of hom sets in Category of modules over Rational Field

    # TODO: End(X) is an algebra

    TESTS::

        sage: TestSuite(ModulesWithBasis(ZZ)).run()
    """

    @cached_method
    def super_categories(self):
        """
        EXAMPLES::

            sage: ModulesWithBasis(QQ).super_categories()
            [Category of vector spaces over Rational Field]
            sage: ModulesWithBasis(ZZ).super_categories()
            [Category of modules over Integer Ring]
        """
        return [Modules(self.base_ring())]

    def _call_(self, x):
        """
        Construct a module with basis from the data in ``x``.

        EXAMPLES::

            sage: C = ModulesWithBasis(QQ)

        ``x`` is returned unchanged if it is already in this category::

            sage: C(CombinatorialFreeModule(QQ, ('a','b','c')))
            Free module generated by {'a', 'b', 'c'} over Rational Field
            sage: C(QQ^3)
            Vector space of dimension 3 over Rational Field

        If needed (and possible) the base ring is changed appropriately::

            sage: C(ZZ^3)                       # indirect doctest
            Vector space of dimension 3 over Rational Field

        If ``x`` itself is not a module with basis, but there is a
        canonical one associated to it, the later is returned::

            sage: C(AbelianVariety(Gamma0(37))) # indirect doctest
            Vector space of dimension 4 over Rational Field
        """
        try:
            M = x.free_module()
            if M.base_ring() != self.base_ring():
                M = M.change_ring(self.base_ring())
        except (TypeError, AttributeError), msg:
            raise TypeError, "%s\nunable to coerce x (=%s) into %s"%(msg,x,self)
        return M

    def is_abelian(self):
        """
        Returns whether this category is abelian.

        This is the case if and only if the base ring is a field.

        EXAMPLES::

            sage: ModulesWithBasis(QQ).is_abelian()
            True
            sage: ModulesWithBasis(ZZ).is_abelian()
            False
        """
        return self.base_ring().is_field()

    class ParentMethods:
        @cached_method
        def basis(self):
            """
            Returns the basis of self.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
                sage: F.basis()
                Finite family {'a': B['a'], 'c': B['c'], 'b': B['b']}

            ::

                sage: QS3 = SymmetricGroupAlgebra(QQ,3)
                sage: list(QS3.basis())
                [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
            """
            from sage.combinat.family import Family
            return Family(self._basis_keys, self.monomial)

        def module_morphism(self, on_basis = None, diagonal = None, triangular = None, **keywords):
            r"""
            Constructs morphisms by linearity

            Constructs morphisms `f: X \mapsto Y` by linearity on a basis
            `(x_i)_{i \in I}` of `X`.

            INPUT:

             - ``self`` -- a parent `X` in ``ModulesWithBasis(R)``, with basis `x`
               indexed by `I`
             - ``codomain`` -- the codomain `Y` of `f`: defaults to ``f.codomain()``
               if the later is defined
             - ``zero`` -- the zero of the codomain; defaults to ``codomain.zero()``
               Can be used (with care) to define affine maps
             - ``position`` -- a non negative integer; defaults to 0
             - ``on_basis`` -- a function `f` which accepts elements of `I`
               as position-th argument and returns elements of `Y`
             - ``diagonal`` -- a function `d` from `I` to `R`
             - ``triangular`` -- "upper" or "lower" or None
                 - "upper": if the `leading_support()`  of the image of `F(i)` is `i`, or
                 - "lower": if the `trailing_support()` of the image of `F(i)` is `i`.
             - ``category`` -- a category. By default, this is
               ``ModulesWithBasis(R)`` if `Y` is in this category, and
               otherwise this lets `\hom(X,Y)` decide

            Exactly one of ``on_basis`` and ``diagonal`` options should be specified.

            With the ``on_basis`` option, this returns a function `g`
            obtained by extending `f` by linearity on the ``position``-th
            positional argument. For example, for ``position == 1`` and a
            ternary function `f`, one has:

            .. math:: g(a,\ \sum_i \lambda_i x_i,\ c) = \sum_i \lambda_i f(a, i, c)

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename("X")
                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename("Y")
                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)
                sage: phi
                Generic morphism:
                From: X
                To:   Y
                sage: phi.category_for()
                Category of modules with basis over Rational Field
                sage: x = X.basis(); y = Y.basis()
                sage: phi(x[1] + x[3])
                B[1] + 2*B[2] + B[3] + 2*B[4]

            With the ``zero`` argument, one can define affine morphisms::

                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y, zero = 10*y[1])
                sage: phi(x[1] + x[3])
                11*B[1] + 2*B[2] + B[3] + 2*B[4]
                sage: phi.category_for()
                Category of sets

            One can construct morphisms with the base ring as codomain::

                sage: X = CombinatorialFreeModule(ZZ,[1,-1])
                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )
                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )
                -1
                sage: phi.category_for()
                Category of commutative additive semigroups
                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))
                Category of modules over Integer Ring

            Or more generaly any ring admitting a coercion map from the base ring::

                sage: phi = X.module_morphism(on_basis= lambda i: i, codomain=RR )
                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )
                -1.00000000000000
                sage: phi.category_for()
                Category of commutative additive semigroups
                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))
                Category of modules over Integer Ring

                sage: phi = X.module_morphism(on_basis= lambda i: i, codomain=Zmod(4) )
                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )
                3

                sage: phi = Y.module_morphism(on_basis= lambda i: i, codomain=Zmod(4) )
                Traceback (most recent call last):
                ...
                AssertionError: codomain should be a module over base_ring

            On can also define module morphism betweem free modules
            over different base rings; here we implement the natural
            map from `X = \RR^2` to `Y = \CC`::

                sage: X = CombinatorialFreeModule(RR,['x','y'])
                sage: Y = CombinatorialFreeModule(CC,['z'])
                sage: x = X.monomial('x')
                sage: y = X.monomial('y')
                sage: z = Y.monomial('z')
                sage: def on_basis( a ):
                ...       if a == 'x':
                ...           return CC(1) * z
                ...       elif a == 'y':
                ...           return CC(I) * z
                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )
                sage: v = 3 * x + 2 * y; v
                3.00000000000000*B['x'] + 2.00000000000000*B['y']
                sage: phi(v)
                (3.00000000000000+2.00000000000000*I)*B['z']
                sage: phi.category_for()
                Category of commutative additive semigroups
                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)
                Category of vector spaces over Real Field with 53 bits of precision

                sage: Y = CombinatorialFreeModule(CC['q'],['z'])
                sage: z = Y.monomial('z')
                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )
                sage: phi(v)
                (3.00000000000000+2.00000000000000*I)*B['z']

            Of course, there should be a coercion between the
            respective base rings of the domain and the codomain for
            this to be meaningful::

                sage: Y = CombinatorialFreeModule(QQ,['z'])
                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )
                Traceback (most recent call last):
                ...
                AssertionError: codomain should be a module over base_ring

                sage: Y = CombinatorialFreeModule(RR['q'],['z'])
                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )
                Traceback (most recent call last):
                ...
                AssertionError: codomain should be a module over base_ring


            With the ``diagonal`` argument, this returns the module morphism `g` such that:

                `g(x_i) = d(i) y_i`

            This assumes that the respective bases `x` and `y` of `X`
            and `Y` have the same index set `I`.

            With ``triangular = upper``, the constructed module
            morphism is assumed to be upper triangular; that is its
            matrix in the distinguished basis of `X` and `Y` would be
            upper triangular with invertible elements on its
            diagonal. This is used to compute preimages and
            inverting the morphism::

                sage: I = range(1,200)
                sage: X = CombinatorialFreeModule(QQ, I); X.rename("X"); x = X.basis()
                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename("Y"); y = Y.basis()
                sage: f = Y.sum_of_monomials * divisors
                sage: phi = X.module_morphism(f, triangular="upper", codomain = Y)
                sage: phi(x[2])
                B[1] + B[2]
                sage: phi(x[6])
                B[1] + B[2] + B[3] + B[6]
                sage: phi(x[30])
                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]
                sage: phi.preimage(y[2])
                -B[1] + B[2]
                sage: phi.preimage(y[6])
                B[1] - B[2] - B[3] + B[6]
                sage: phi.preimage(y[30])
                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]
                sage: (phi^-1)(y[30])
                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]

            For details and further optional arguments, see
            :class:`sage.categories.modules_with_basis.TriangularModuleMorphism`.


            Caveat: the returned element is in ``Hom(codomain, domain,
            category``). This is only correct for unary functions.

            Todo: should codomain be ``self`` by default in the
            diagonal and triangular cases?

            """
            if diagonal is not None:
                return DiagonalModuleMorphism(diagonal = diagonal, domain = self, **keywords)
            elif on_basis is not None:
                if triangular is not None:
                    return TriangularModuleMorphism(on_basis, domain = self, triangular = triangular, **keywords)
                return ModuleMorphismByLinearity(on_basis = on_basis, domain = self, **keywords)
            else:
                raise ValueError("module morphism requires either on_basis or diagonal argument")

        _module_morphism = module_morphism

        def _repr_(self):
            """
            EXAMPLES::

                sage: QS3 = SymmetricGroupAlgebra(QQ,3)
                sage: QS3                 # indirect doctest
                Symmetric group algebra of order 3 over Rational Field
                sage: QS3.rename("QS3")
                sage: QS3                 # indirect doctest
                QS3

                sage: class Blah(Parent):
                ...       pass
                sage: Blah(category = ModulesWithBasis(QQ))
                <class '__main__.Blah_with_category'>

            FIXME: this implementation is not generic; it uses the
            ``_name`` attribute if available (as is the case for
            instances of :class:`CombinatorialFreeModule`), and
            otherwise returns the name of the class as per Python's
            default ``repr``. However, having it here rather than in
            :class:`CombinatorialFreeModule` allows subcategories for
            overriding it.
            """
            if hasattr(self, "_name"):
                return self._name + " over %s"%self.base_ring()
            else:
                return repr(type(self))


        def tensor(*parents):
            """
            Returns the tensor product of the parents

            EXAMPLES::

                sage: C = AlgebrasWithBasis(QQ)
                sage: A = C.example(); A.rename("A")
                sage: A.tensor(A,A)
                A # A # A
                sage: A.rename(None)
            """
            return parents[0].__class__.Tensor(parents, category = tensor.category_from_parents(parents))


    class ElementMethods:
        # TODO: Define the appropriate element methods here (instead of in
        # subclasses).  These methods should be consistent with those on
        # polynomials.

#         def _neg_(self):
#             """
#             Default implementation of negation by trying to multiply by -1.
#             TODO: doctest
#             """
#             return self._lmul_(-self.parent().base_ring().one(), self)


        def support_of_term(self):
            """
            INPUT:

             - ``self`` - a monomial, possibly with coefficient

            Returns the support of ``self``.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename("X")
                sage: X.monomial(2).support_of_term()
                2
                sage: X.term(3, 2).support_of_term()
                3

            An exception is raised if ``self`` has more than one term::

                sage: (X.monomial(2) + X.monomial(3)).support_of_term()
                Traceback (most recent call last):
                ...
                ValueError: B[2] + B[3] is not a single term

            """
            if len(self) == 1:
                return self.support()[0]
            else:
                raise ValueError, "%s is not a single term"%(self)

        def leading_support(self, cmp=None):
            r"""
            Returns the maximal element of the support of ``self``. Note
            that this may not be the term which actually appears first when
            ``self`` is printed.

            If the default ordering of the basis elements is not what is
            desired, a comparison function, ``cmp(x,y)``, can be provided.
            This should return a negative value if `x < y`, `0` if `x == y`
            and a positive value if `x > y`.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)
                sage: x.leading_support()
                3
                sage: def cmp(x,y): return y-x
                sage: x.leading_support(cmp=cmp)
                1

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.leading_support()
                [3]
            """
            return max_cmp(self.support(), cmp)


        def leading_item(self, cmp=None):
            r"""
            Returns the pair ``(k, c)`` where ``c`` * (the basis elt. indexed
            by ``k``) is the leading term of ``self``.

            'leading term' means that the corresponding basis element is
            maximal.  Note that this may not be the term which actually appears
            first when ``self`` is printed.  If the default term ordering is not
            what is desired, a comparison function, ``cmp(x,y)``, can be
            provided.  This should return a negative value if `x < y`, `0` if
            `x == y` and a positive value if `x > y`.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)
                sage: x.leading_item()
                (3, 4)
                sage: def cmp(x,y): return y-x
                sage: x.leading_item(cmp=cmp)
                (1, 3)

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.leading_item()
                ([3], -5)
            """
            k = self.leading_support(cmp=cmp)
            return k, self[k]

        def leading_monomial(self, cmp=None):
            r"""
            Returns the leading monomial of ``self``.

            This is the monomial whose corresponding basis element is
            maximal. Note that this may not be the term which actually appears
            first when ``self`` is printed. If the default term ordering is not
            what is desired, a comparison function, cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.leading_monomial()
                B[3]
                sage: def cmp(x,y): return y-x
                sage: x.leading_monomial(cmp=cmp)
                B[1]

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.leading_monomial()
                s[3]
            """
            return self.parent().monomial( self.leading_support(cmp=cmp) )

        def leading_coefficient(self, cmp=None):
            r"""
            Returns the leading coefficient of ``self``.

            This is the coefficient of the term whose corresponding basis element is
            maximal. Note that this may not be the term which actually appears
            first when ``self`` is printed.  If the default term ordering is not
            what is desired, a comparison function, cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X")
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.leading_coefficient()
                1
                sage: def cmp(x,y): return y-x
                sage: x.leading_coefficient(cmp=cmp)
                3

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.leading_coefficient()
                -5
            """
            return self.leading_item(cmp=cmp)[1]

        def leading_term(self, cmp=None):
            r"""
            Returns the leading term of ``self``.

            This is the term whose corresponding basis element is
            maximal. Note that this may not be the term which actually appears
            first when ``self`` is printed. If the default term ordering is not
            what is desired, a comparison function, cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.leading_term()
                B[3]
                sage: def cmp(x,y): return y-x
                sage: x.leading_term(cmp=cmp)
                3*B[1]

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.leading_term()
                -5*s[3]
            """
            return self.parent().term(*self.leading_item(cmp=cmp))

        def trailing_support(self, cmp=None):
            r"""
            Returns the minimal element of the support of ``self``. Note
            that this may not be the term which actually appears last when
            ``self`` is printed.

            If the default ordering of the basis elements is not what is
            desired, a comparison function, ``cmp(x,y)``, can be provided.
            This should return a negative value if `x < y`, `0` if `x == y`
            and a positive value if `x > y`.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)
                sage: x.trailing_support()
                1
                sage: def cmp(x,y): return y-x
                sage: x.trailing_support(cmp=cmp)
                3

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.trailing_support()
                [1]
            """
            return min_cmp(self.support(), cmp)

        def trailing_item(self, cmp=None):
            r"""
            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``
            is the trailing term of ``self``.

            This is the monomial whose corresponding basis element is
            minimal. Note that this may not be the term which actually appears
            last when ``self`` is printed.  If the default term ordering is not
            what is desired, a comparison function cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.trailing_item()
                (1, 3)
                sage: def cmp(x,y): return y-x
                sage: x.trailing_item(cmp=cmp)
                (3, 1)

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.trailing_item()
                ([1], 2)
            """
            k = self.trailing_support(cmp=cmp)
            return k, self[k]

        def trailing_monomial(self, cmp=None):
            r"""
            Returns the trailing monomial of ``self``.

            This is the monomial whose corresponding basis element is
            minimal. Note that this may not be the term which actually appears
            last when ``self`` is printed. If the default term ordering is not
            what is desired, a comparison function cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.trailing_monomial()
                B[1]
                sage: def cmp(x,y): return y-x
                sage: x.trailing_monomial(cmp=cmp)
                B[3]

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.trailing_monomial()
                s[1]
            """
            return self.parent().monomial( self.trailing_support(cmp=cmp) )

        def trailing_coefficient(self, cmp=None):
            r"""
            Returns the trailing coefficient of ``self``.

            This is the coefficient of the monomial whose corresponding basis element is
            minimal. Note that this may not be the term which actually appears
            last when ``self`` is printed. If the default term ordering is not
            what is desired, a comparison function cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.trailing_coefficient()
                3
                sage: def cmp(x,y): return y-x
                sage: x.trailing_coefficient(cmp=cmp)
                1

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.trailing_coefficient()
                2
            """

            return self.trailing_item(cmp=cmp)[1]

        def trailing_term(self, cmp=None):
            r"""
            Returns the trailing term of ``self``.

            This is the term whose corresponding basis element is
            minimal. Note that this may not be the term which actually appears
            last when ``self`` is printed. If the default term ordering is not
            what is desired, a comparison function cmp(x,y), can be provided.
            This should return a negative value if x < y, 0 if x == y
            and a positive value if x > y.

            EXAMPLES::

                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)
                sage: x.trailing_term()
                3*B[1]
                sage: def cmp(x,y): return y-x
                sage: x.trailing_term(cmp=cmp)
                B[3]

                sage: s = SymmetricFunctions(QQ).schur()
                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]
                sage: f.trailing_term()
                2*s[1]
            """
            return self.parent().term( *self.trailing_item(cmp=cmp) )

        def map_coefficients(self, f):
            """
            Mapping a function on coefficients

            INPUT:

             - ``f`` -- an endofunction on the coefficient ring of the free module

            Returns a new element of self.parent() obtained by applying the
            function `f` to all of the coefficients of self.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
                sage: B = F.basis()
                sage: f = B['a'] - 3*B['c']
                sage: f.map_coefficients(lambda x: x+5)
                6*B['a'] + 2*B['c']

            Killed coefficients are handled properly::

                sage: f.map_coefficients(lambda x: 0)
                0
                sage: list(f.map_coefficients(lambda x: 0))
                []

            ::

                sage: s = SFASchur(QQ)
                sage: a = s([2,1])+2*s([3,2])
                sage: a.map_coefficients(lambda x: x*2)
                2*s[2, 1] + 4*s[3, 2]
            """
            return self.parent().sum_of_terms( (m, f(c)) for m,c in self )

        def map_support(self, f):
            """
            Mapping a function on the support

            INPUT:

             - ``f`` -- an endofunction on the indices of the free module

            Returns a new element of self.parent() obtained by
            applying the function `f` to all of the objects indexing
            the basis elements.

            EXAMPLES::

                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])
                sage: x = B.an_element(); x
                2*B[-1] + 2*B[0] + 3*B[1]
                sage: x.map_support(lambda i: -i)
                3*B[-1] + 2*B[0] + 2*B[1]

            ``f`` needs not be injective::

                sage: x.map_support(lambda i: 1)
                7*B[1]

                sage: s = SFASchur(QQ)
                sage: a = s([2,1])+2*s([3,2])
                sage: a.map_support(lambda x: x.conjugate())
                s[2, 1] + 2*s[2, 2, 1]

            TESTS::

                sage: B.zero()      # This actually failed at some point!!! See #8890
                0
            """
            return self.parent().sum_of_terms( (f(m), c) for m,c in self )

        def map_item(self, f):
            """
            Mapping a function on items

            INPUT:

             - ``f`` -- a function mapping pairs (index, coeff) to
               other such pairs

            Returns a new element of self.parent() obtained by
            applying the function `f` to all items (index,coeff) of
            ``self``.

            EXAMPLES::

                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])
                sage: x = B.an_element(); x
                2*B[-1] + 2*B[0] + 3*B[1]
                sage: x.map_item(lambda i, c: (-i, 2*c))
                6*B[-1] + 4*B[0] + 4*B[1]

            ``f`` needs not be injective::

                sage: x.map_item(lambda i, c: (1, 2*c))
                14*B[1]

                sage: s = SFASchur(QQ)
                sage: f = lambda m,c: (m.conjugate(), 2*c)
                sage: a = s([2,1]) + s([1,1,1])
                sage: a.map_item(f)
                2*s[2, 1] + 2*s[3]

            The following methods are deprecated::

                sage: a.map_term(f)
                doctest:...: DeprecationWarning: map_term is deprecated. Please use map_item instead.
                See http://trac.sagemath.org/8890 for details.
                2*s[2, 1] + 2*s[3]
                sage: a.map_mc(f)
                doctest:...: DeprecationWarning: map_mc is deprecated. Please use map_item instead.
                See http://trac.sagemath.org/8890 for details.
                2*s[2, 1] + 2*s[3]
            """
            return self.parent().sum_of_terms( f(m,c) for m,c in self )

        map_term = deprecated_function_alias(8890, map_item)
        map_mc   = deprecated_function_alias(8890, map_item)

        def tensor(*elements):
            """
            Returns the tensor product of its arguments, as an element of
            the tensor product of the parents of those elements.

            EXAMPLES::

                sage: C = AlgebrasWithBasis(QQ)
                sage: A = C.example()
                sage: (a,b,c) = A.algebra_generators()
                sage: a.tensor(b, c)
                B[word: a] # B[word: b] # B[word: c]

            FIXME: is this a policy that we want to enforce on all parents?
            """
            assert(all(isinstance(element, Element) for element in elements))
            parents = [parent(element) for element in elements]
            return tensor(parents)._tensor_of_elements(elements) # good name???

    class HomCategory(HomCategory):
        """
        The category of homomorphisms sets Hom(X,Y) for X, Y modules with basis
        """

        class ParentMethods: #(sage.modules.free_module_homspace.FreeModuleHomspace): #    Only works for plain FreeModule's
            """
            Abstract class for hom sets
            """

            def __call__(self, on_basis = None, *args, **options):
                """
                Construct an element of this homset

                INPUT:

                 - on_basis (optional) -- a function from the indices
                   of the basis of the domain of ``self`` to the
                   codomain of ``self``

                EXAMPLES::

                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename("X")
                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename("Y")
                    sage: H = Hom(X, Y)
                    sage: x = X.basis()

                As for usual homsets, the argument can be a Python function::

                    sage: phi = H(lambda x: Y.zero())
                    sage: phi
                    Generic morphism:
                      From: X
                      To:   Y
                    sage: phi(x[1] + x[3])
                    0

                With the on_basis argument, the function can instead
                be constructed by extending by linearity a function on
                the basis::

                    sage: phi = H(on_basis = lambda i: Y.monomial(i) + 2*Y.monomial(i+1))
                    sage: phi
                    Generic morphism:
                    From: X
                    To:   Y
                    sage: phi(x[1] + x[3])
                    B[1] + 2*B[2] + B[3] + 2*B[4]

                This is achieved internaly by using
                :meth:`ModulesWithBasis.ParentMethods.module_morphism`, which see.
                """
                if on_basis is not None:
                    args = (self.domain().module_morphism(on_basis, codomain = self.codomain()),) + args
                h = Homset.__call__(self, *args, **options)
                if on_basis is not None:
                    h._on_basis = on_basis
                return h

            # Temporary hack
            __call_on_basis__ = __call__

            @lazy_attribute
            def element_class_set_morphism(self):
                """
                A base class for elements of this homset which are
                also SetMorphism's, i.e. implemented by mean of a
                Python function.

                This overrides the default implementation
                :meth:`Homset.element_class_set_morphism`, to also
                inherit from categories.

                Todo: refactor during the upcoming homset cleanup.

                EXAMPLES::

                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename("X")
                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename("Y")
                    sage: H = Hom(X, Y)
                    sage: H.element_class_set_morphism
                    <class 'sage.categories.morphism.SetMorphism_with_category'>
                    sage: H.element_class_set_morphism.mro()
                    [<class 'sage.categories.morphism.SetMorphism_with_category'>,
                     <type 'sage.categories.morphism.SetMorphism'>,
                     <type 'sage.categories.morphism.Morphism'>,
                     <type 'sage.categories.map.Map'>,
                     <type 'sage.structure.element.Element'>,
                     <type 'sage.structure.sage_object.SageObject'>,
                     <class 'sage.categories.modules_with_basis.ModulesWithBasis.HomCategory.element_class'>,
                     <class 'sage.categories.category.Modules.HomCategory.element_class'>,
                     <class 'sage.categories.vector_spaces.VectorSpaces.element_class'>,
                     ...]

                Compare with:

                    sage: H = Hom(ZZ, ZZ)
                    sage: H.element_class_set_morphism
                    <type 'sage.categories.morphism.SetMorphism'>
                """
                return self.__make_element_class__(SetMorphism, inherit = True)

        class ElementMethods:
            """
            Abstract class for morphisms of modules with basis
            """
            def on_basis(self):
                """
                Returns the action of this morphism on basis elements

                OUTPUT:

                - a function from the indices of the basis of the domain to the codomain.

                EXAMPLES::

                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename("X")
                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename("Y")
                    sage: H = Hom(X, Y)
                    sage: x = X.basis()

                    sage: f = H(lambda x: Y.zero()).on_basis()
                    sage: f(2)
                    0

                    sage: f = lambda i: Y.monomial(i) + 2*Y.monomial(i+1)
                    sage: g = H(on_basis = f).on_basis()
                    sage: g(2)
                    B[2] + 2*B[3]
                    sage: g == f
                    True
                """
                if not hasattr(self, "_on_basis"):
                    monomial = self.domain().monomial
                    self._on_basis = lambda t: self(monomial(t))
                return self._on_basis


    class CartesianProducts(CartesianProductsCategory):
        """
        The category of modules with basis constructed by cartesian products of modules with basis
        """
        @cached_method
        def extra_super_categories(self):
            """
            EXAMPLES::

                sage: ModulesWithBasis(QQ).CartesianProducts().extra_super_categories()
                [Category of modules with basis over Rational Field]
                sage: ModulesWithBasis(QQ).CartesianProducts().super_categories()
                [Category of modules with basis over Rational Field, Category of Cartesian products of sets]
            """
            return [self.base_category()]

        class ParentMethods:

            def _an_element_(self):
                """
                EXAMPLES::

                    sage: A = AlgebrasWithBasis(QQ).example(); A
                    An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field
                    sage: B = HopfAlgebrasWithBasis(QQ).example(); B
                    An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field
                    sage: A.an_element(), B.an_element()
                    (B[word: ] + 2*B[word: a] + 3*B[word: b], B[()] + 2*B[(2,3)] + 3*B[(1,2)] + B[(1,2,3)])
                    sage: cartesian_product((A, B, A)).an_element()           # indirect doctest
                    2*B[(0, word: )] + 2*B[(0, word: a)] + 3*B[(0, word: b)]
                """
                from cartesian_product import cartesian_product
                return cartesian_product([module.an_element() for module in self.modules])

    class TensorProducts(TensorProductsCategory):
        """
        The category of modules with basis constructed by tensor product of modules with basis
        """
        @cached_method
        def extra_super_categories(self):
            """
            EXAMPLES::

                sage: ModulesWithBasis(QQ).TensorProducts().extra_super_categories()
                [Category of modules with basis over Rational Field]
                sage: ModulesWithBasis(QQ).TensorProducts().super_categories()
                [Category of modules with basis over Rational Field]
            """
            return [self.base_category()]

        class ParentMethods:
            """
            implements operations on tensor products of modules with basis
            """
            pass

        class ElementMethods:
            """
            implements operations on elements of tensor products of modules
            with basis
            """
            pass

    class DualObjects(DualObjectsCategory):

        @cached_method
        def extra_super_categories(self):
            """
            EXAMPLES::

                sage: ModulesWithBasis(ZZ).DualObjects().extra_super_categories()
                [Category of modules over Integer Ring]
                sage: ModulesWithBasis(QQ).DualObjects().extra_super_categories()
                [Category of vector spaces over Rational Field]
            """
            return [Modules(self.base_category().base_ring())]


class ModuleMorphismByLinearity(Morphism):
    """
    A class for module morphisms obtained by extending a function by linearity
    """
    def __init__(self, domain, on_basis = None, position = 0, zero = None, codomain = None, category = None):
        """
        Constructs a module morphism by linearity

        INPUT:

         - ``domain`` -- a parent in ModulesWithBasis(...)
         - ``codomain`` -- a parent in Modules(...); defaults to f.codomain() if the later is defined
         - ``position`` -- a non negative integer; defaults to 0
         - ``on_basis`` -- a function which accepts indices of the basis of domain as position-th argument (optional)
         - ``zero`` -- the zero of the codomain; defaults to ``codomain.zero()``

        ``on_basis`` may alternatively be provided in derived classes by implementing or setting ``_on_basis``.

        EXAMPLES::


            sage: X = CombinatorialFreeModule(ZZ, [-2, -1, 1, 2])
            sage: Y = CombinatorialFreeModule(ZZ, [1, 2])
            sage: phi = sage.categories.modules_with_basis.ModuleMorphismByLinearity(X, on_basis = Y.monomial * abs)

        TESTS::

            sage: TestSuite(phi).run() # known issue
            Failure in _test_category:
            ...
            The following tests failed: _test_category

        Analysis: ``phi`` does not inherit from the element class of
        the category of its parent::

            sage: isinstance(phi, phi.parent().category().element_class)
            False

        To be fixed in the general morphism overhaul (#....), possibly
        by making sure to create ``phi`` through its parent.

        """
        # Might want to assert that domain is a module with basis
        base_ring = domain.base_ring()

        if codomain is None and hasattr(on_basis, 'codomain'):
            codomain = on_basis.codomain()
        assert codomain is not None
        assert hasattr( codomain, 'base_ring' )
        # codomain should be a module over base_ring
        # The natural test would be ``codomains in Modules(base_ring)``
        # But this is not properly implemented yet:
        #     sage: CC in Modules(QQ)
        #     False
        #     sage: QQ in Modules(QQ)
        #     False
        #     sage: CC[x] in Modules(QQ)
        #     False
        # The test below is a bit more restrictive
        assert codomain.base_ring().has_coerce_map_from(base_ring) or \
            codomain.has_coerce_map_from(base_ring),                  \
            "codomain should be a module over base_ring"

        if zero is None:
            zero = codomain.zero()
        self._zero = zero

        self._is_module_with_basis_over_same_base_ring = \
            codomain in ModulesWithBasis( base_ring ) and zero == codomain.zero()

        if category is None:
            if self._is_module_with_basis_over_same_base_ring:
                category = ModulesWithBasis(base_ring)
            elif zero == codomain.zero():
                if codomain in Modules(base_ring):
                    category = Modules(base_ring)
                else:
                    # QQ is not in Modules(QQ)!
                    category = CommutativeAdditiveSemigroups()
            else:
                category = Sets()

        Morphism.__init__(self, Hom(domain, codomain, category = category))


        self._position = position
        if on_basis is not None:
            self._on_basis = on_basis

    def __eq__(self, other):
        """
        EXAMPLES::

            sage: X = CombinatorialFreeModule(ZZ, [-2, -1, 1, 2])
            sage: Y = CombinatorialFreeModule(ZZ, [1, 2])
            sage: f  = X.module_morphism(on_basis = Y.monomial * abs)
            sage: g  = X.module_morphism(on_basis = Y.monomial * abs)
            sage: h1 = X.module_morphism(on_basis = X.monomial * abs)
            sage: h2 = X.module_morphism(on_basis = X.monomial * factorial)
            sage: h3 = X.module_morphism(on_basis = Y.monomial * abs, category = Modules(ZZ))
            sage: f == g, f == h1, f == h2, f == h3, f == 1, 1 == f
            (True, False, False, False, False, False)
        """
        return self.__class__ is other.__class__ and parent(self) == parent(other) and self.__dict__ == other.__dict__


    def on_basis(self):
        """
        Returns the action of this morphism on basis elements, as per
        :meth:`ModulesWithBasis.HomCategory.ElementMethods.on_basis`.

        OUTPUT:

        - a function from the indices of the basis of the domain to the codomain.

        EXAMPLES::

            sage: X = CombinatorialFreeModule(ZZ, [-2, -1, 1, 2])
            sage: Y = CombinatorialFreeModule(ZZ, [1, 2])
            sage: phi_on_basis = Y.monomial * abs
            sage: phi = sage.categories.modules_with_basis.ModuleMorphismByLinearity(X, on_basis = phi_on_basis, codomain = Y)
            sage: x = X.basis()
            sage: phi.on_basis()(-2)
            B[2]
            sage: phi.on_basis() == phi_on_basis
            True

        Note: could probably be inherited from the categories
        """
        return self._on_basis

    def __call__(self, *args):
        """
        Apply this morphism

        EXAMPLES::

            sage: X = CombinatorialFreeModule(ZZ, [-2, -1, 1, 2])
            sage: Y = CombinatorialFreeModule(ZZ, [1, 2])
            sage: def phi_on_basis(i): return Y.monomial(abs(i))
            sage: phi = sage.categories.modules_with_basis.ModuleMorphismByLinearity(X, on_basis = Y.monomial * abs, codomain = Y)
            sage: x = X.basis()
            sage: phi(x[1]), phi(x[-2]), phi(x[1] + 3 * x[-2])
            (B[1], B[2], B[1] + 3*B[2])

        Todo: add more tests for multi-parameter module morphisms.
        """
        before = args[0:self._position]
        after = args[self._position+1:len(args)]
        x = args[self._position]
        assert(x.parent() is self.domain())

        if self._is_module_with_basis_over_same_base_ring:
            return self.codomain().linear_combination( (self._on_basis(*(before+(index,)+after)), coeff ) for (index, coeff) in args[self._position] )
        else:
            return sum(( coeff * self._on_basis(*(before+(index,)+after)) for (index, coeff) in args[self._position]), self._zero)

    # As per the specs of Map, we should in fact implement _call_.
    # However we currently need to abuse Map.__call__ (which strict
    # type checking) for multi-parameter module morphisms
    # To be cleaned up
    _call_ = __call__

class TriangularModuleMorphism(ModuleMorphismByLinearity):
    """
    A class for triangular module morphisms; that is module morphisms
    from `X` to `Y` whose matrix in the distinguished basis of `X` and
    `Y` would be upper triangular with invertible elements on its
    diagonal.

    See :meth:`ModulesWithBasis.ParentMethods.module_morphism`

    INPUT:

     - ``domain`` - a module with basis `F`
     - ``codomain`` - a module with basis `G` (defaults to `F`)
     - ``on_basis`` - a function from the index set of the basis of `F` to the
       elements of `G` which describes the morphism
     - ``unitriangular`` - boolean (default: False)
     - ``triangular`` - "upper" or "lower" (default: "upper")
         - "upper": if the `leading_support()`  of the image of `F(i)` is `i`, or
         - "lower": if the `trailing_support()` of the image of `F(i)` is `i`.
     - ``cmp`` - an optional comparison function on the index set `J` of
       the basis of the codomain.
     - ``invertible`` - should be set to ``True`` if ``self`` is
       invertible. Automatically set to ``True`` if the domain and
       codomain share the same indexing set
     - ``inverse_on_support`` - compute the inverse on the support if the
       codomain and domain have different index sets. see assumptions below

    Assumptions:

     - `F` and `G` have the same base ring `R`

     - let `I` and `J` be the respective index sets of the basis of `F` and
       `G`. Either `I = J` or ``inverse_on_support`` is a function `r :
       J\mapsto I` with the following property: for any `j\in J`, `r(j)`
       should return an `i\in I` such that the leading term of ``on_basis(i)``
       is `j` if there exists such a `i` or ``None`` if not.

    OUTPUT:

        The triangular module morphism from `F` to `G` which maps `f_\lambda`
        to `on_basis(\lambda)` and is extended by linearity.

    EXAMPLES::

        sage: I = range(1,200)
        sage: X = CombinatorialFreeModule(QQ, I); X.rename("X"); x = X.basis()
        sage: Y = CombinatorialFreeModule(QQ, I); Y.rename("Y"); y = Y.basis()
        sage: f = Y.sum_of_monomials * divisors
        sage: phi = X.module_morphism(f, triangular="upper", unitriangular = True, codomain = Y)
        sage: phi(x[2])
        B[1] + B[2]
        sage: phi(x[6])
        B[1] + B[2] + B[3] + B[6]
        sage: phi(x[30])
        B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]
        sage: phi.preimage(y[2])
        -B[1] + B[2]
        sage: phi.preimage(y[6])
        B[1] - B[2] - B[3] + B[6]
        sage: phi.preimage(y[30])
        -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]
        sage: (phi^-1)(y[30])
        -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]

        sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
        sage: def ut(i): return sum(j*x[j] for j in range(i,4))
        sage: phi = X.module_morphism(ut, triangular="lower", codomain = X)
        sage: phi(x[2])
        2*B[2] + 3*B[3]
        sage: phi.preimage(x[2])
        1/2*B[2] - 1/2*B[3]
        sage: phi(phi.preimage(x[2]))
        B[2]


        sage: X = CombinatorialFreeModule(QQ, [1,2,3]); x = X.basis()
        sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4,5]); y = Y.basis()
        sage: uut = lambda i: sum(  y[j] for j in range(i+1,6)  )
        sage: phi = X.module_morphism(uut, codomain = Y,
        ...        triangular=True, unitriangular=True,
        ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
        sage: phi(x[2])
        B[3] + B[4] + B[5]
        sage: phi.preimage(y[3])
        B[2] - B[3]
    """

    def __init__(self, on_basis, domain, triangular = "upper", unitriangular=False,
                 codomain = None, category = None, cmp = None,
                 inverse = None, inverse_on_support = None, invertible = None):
        """
        TESTS::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
            sage: def ut(i): return sum(j*x[j] for j in range(i,4))
            sage: import __main__; __main__.ut = ut
            sage: phi = X.module_morphism(ut, triangular="lower", codomain = X)
            sage: phi.__class__
            <class 'sage.categories.modules_with_basis.TriangularModuleMorphism'>
            sage: TestSuite(phi).run() # known issue; see ModuleMorphism above
            Failure in _test_category:
            ...
            The following tests failed: _test_category
        """
        ModuleMorphismByLinearity.__init__(self, domain = domain, codomain = codomain, category = category)
        if triangular == "upper":
            self._dominant_item = attrcall("leading_item",  cmp)
        else:
            self._dominant_item = attrcall("trailing_item", cmp)
        # We store those two just be able to pass them down to the inverse function
        self._triangular = triangular
        self._cmp = cmp

        self._unitriangular = unitriangular
        self._inverse = inverse
        self.on_basis = on_basis # should this be called on_basis (or _on_basis)?
        self._inverse_on_support = inverse_on_support
        if invertible is not None:
            self._invertible = invertible
        else:
            self._invertible = (domain.basis().keys() == codomain.basis().keys())

    def _test_triangular(self, **options):
        """
        Tests that ``self`` is actually triangular

        See also: :class:`sage.misc.sage_unittest.TestSuite`.

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); y = Y.basis()
            sage: f = lambda i: sum(  y[j] for j in range(i,4)  )
            sage: phi = X.module_morphism(f, triangular="lower", codomain = Y)
            sage: phi._test_triangular()

            sage: fw = lambda i: sum(  y[j] for j in range(i+1,4)  )
            sage: phi = X.module_morphism(fw, triangular="lower", codomain = Y)
            sage: phi._test_triangular()
            Traceback (most recent call last):
            ...
            AssertionError: morphism is not triangular on 1

            sage: X = CombinatorialFreeModule(QQ, [1,2,3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4,5]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i+1,6)  )
            sage: phi = X.module_morphism(uut, codomain = Y,
            ...        triangular=True, unitriangular=True,
            ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
            sage: phi._test_triangular()

            sage: uutw = lambda i: sum(  2*y[j] for j in range(i+1,6)  ) # uni-upper
            sage: phi = X.module_morphism(uutw, codomain = Y,
            ...        triangular=True, unitriangular=True,
            ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
            sage: phi._test_triangular()
            Traceback (most recent call last):
            ...
            AssertionError: morphism is not untriangular on 1
        """
        from sage.misc.lazy_format import LazyFormat
        tester = self._tester(**options)
        for x in self.domain().basis().keys():
            # or should it be self.domain().basis().some_elements() # ?
            bs, co = self._dominant_item(self._on_basis(x))
            if self._unitriangular:
                tester.assertEqual(co, self.domain().base_ring().one(),
                    LazyFormat("morphism is not untriangular on %s")%(x))
            if self._inverse_on_support is not None:
                xback = self._inverse_on_support(bs)
            else:
                xback = bs
            tester.assertEqual(x, xback,
                LazyFormat("morphism is not triangular on %s")%(x))


    def _on_basis(self, i):
        """
        Returns the image, by self, of the basis element indexed by `i`.

        TESTS::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); y = Y.basis()
            sage: f = lambda i: sum(  y[j] for j in range(i,4)  )
            sage: phi = X.module_morphism(f, triangular="lower", codomain = Y)
            sage: phi._on_basis(2)
            B[2] + B[3]
        """
        return self.on_basis(i)

    def __invert__(self):
        """
        Returns the triangular morphism which is the inverse of `self`.

        Raises an error if ``self`` is not invertible.

        TESTS::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(1,i+1)) # uni-upper
            sage: ult = lambda i: sum(  y[j] for j in range(i,4)  ) # uni-lower
            sage: ut =  lambda i: sum(j*y[j] for j in range(1,i+1)) # upper
            sage: lt =  lambda i: sum(j*y[j] for j in range(i,4  )) # lower
            sage: f_uut = X.module_morphism(uut, triangular="upper", unitriangular=True,  codomain = Y)
            sage: f_ult = X.module_morphism(ult, triangular="lower", unitriangular=True,  codomain = Y)
            sage: f_ut =  X.module_morphism(ut,  triangular="upper",                      codomain = Y)
            sage: f_lt =  X.module_morphism(lt,  triangular="lower",                      codomain = Y)
            sage: (~f_uut)(y[2])
            -B[1] + B[2]
            sage: (~f_ult)(y[2])
            B[2] - B[3]
            sage: (~f_ut)(y[2])
            -1/2*B[1] + 1/2*B[2]
            sage: (~f_lt)(y[2])
            1/2*B[2] - 1/2*B[3]
        """
        if not self._invertible:
            raise ValueError, "Non invertible morphism"
        else:
            return self.section()

    def section(self):
        """
        Returns the section (partial inverse) of ``self``.

        Returns a partial triangular morphism which is a section of
        ``self``. The section morphism raise a ``ValueError`` if asked to
        apply on an element which is not in the image of ``self``.

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1,2,3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4,5]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i+1,6)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y,
            ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
            sage: ~phi
            Traceback (most recent call last):
            ...
            ValueError: Non invertible morphism
            sage: phiinv = phi.section()
            sage: map(phiinv*phi, X.basis().list()) == X.basis().list()
            True
            sage: phiinv(Y.basis()[1])
            Traceback (most recent call last):
            ...
            ValueError: B[1] is not in the image of Generic morphism:
              From: X
              To:   Free module generated by {1, 2, 3, 4, 5} over Rational Field
        """
        if self._inverse is not None:
            return self._inverse
        if self._inverse_on_support is None:
            retract_dom = None
        else:
            def retract_dom(i):
                self._dominant_item(self._on_basis(i))[0]

        if self._invertible:
            return self.__class__( self._invert_on_basis,
                domain = self.codomain(),               codomain = self.domain(),
                unitriangular = self._unitriangular,  triangular = self._triangular,
                cmp = self._cmp,
                inverse = self,                       category = self.category_for(),
                inverse_on_support=retract_dom, invertible = self._invertible)
        else:
            return SetMorphism(Hom(self.codomain(), self.domain(),
                                   SetsWithPartialMaps()),
                               self.preimage)

    # This should be removed and optimized (the inverse should not be computed
    # on the basis
    def _invert_on_basis(self, i):
        r"""
        Returns the image, by the inverse of ``self``, of the basis element
        indexed by ``i``.

        TESTS::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i,4)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y)
            sage: phi._invert_on_basis(2)
            B[2] - B[3]
        """
        return self.preimage( self.codomain().monomial(i) )

    def preimage(self, f):
        """
        Returns the image of f by the inverse of ``self``.

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i,4)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y)
            sage: phi.preimage(y[1] + y[2])
            B[1] - B[3]

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3, 4]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i,5)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y)
            sage: phi.preimage(y[1] + y[2])
            B[1] - B[3]

            sage: X = CombinatorialFreeModule(QQ, [1,2,3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4,5]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i+1,6)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y,
            ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
            sage: phi.preimage(y[2] + y[3])
            B[1] - B[3]
            sage: phi(phi.preimage(y[2] + y[3])) == y[2] + y[3]
            True
            sage: el = x[1] + 3*x[2] + 2*x[3]
            sage: phi.preimage(phi(el)) == el
            True

            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y,
            ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
            sage: phi.preimage(y[1])
            Traceback (most recent call last):
            ...
            ValueError: B[1] is not in the image of Generic morphism:
              From: X
              To:   Free module generated by {1, 2, 3, 4, 5} over Rational Field
        """
        F = self.domain()
        G = self.codomain()
        map = self._on_basis
        assert f in G

        remainder = f

        out = F.zero()
        while not remainder.is_zero():
            (j,c) = self._dominant_item(remainder)

            if self._inverse_on_support is None:
                j_preimage = j
            else:
                j_preimage = self._inverse_on_support(j)
                if j_preimage is None:
                    raise ValueError, "%s is not in the image of %s"%(f, self)
            s = map(j_preimage)
            assert j == self._dominant_item(s)[0]

            if not self._unitriangular:
                    c /= s[j]

            remainder -= s._lmul_(c)
            out += F.term(j_preimage, c)

        return out

    def co_reduced(self, y):
        """
        Reduces element w.r.t image of ``self``

        Suppose that ``self`` is a morphism from `X` to `Y`. Then for any
        `y\in Y`, the calls ``self.co_reduced(y)`` returns a normal form for
        `y` in the quotient `Y/I` where `I` is the image of ``self``.

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i,4)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y)
            sage: phi.co_reduced(y[1] + y[2])
            0
        """
        F = self.domain()
        G = self.codomain()
        map = self._on_basis
        assert y in G

        result    = G.zero()
        remainder = y

        out = F.zero()
        while not remainder.is_zero():
            (j,c) = self._dominant_item(remainder)
            if self._inverse_on_support is None:
                j_preimage = j
            else:
                j_preimage = self._inverse_on_support(j)
            if j_preimage is None:
                dom_term = G.term(j,c)
                remainder -= dom_term
                result += dom_term
            else:
                s = map(j_preimage)
                assert j == self._dominant_item(s)[0]
                if not self._unitriangular:
                    c /= s[j]
                    remainder -= s._lmul_(c)
        return result

    def co_kernel_projection(self, category = None):
        """
        Returns a projection on the co-kernel of ``self``

        INPUT::

           - `category` -- the category of the result.

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1,2,3]); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4,5]); y = Y.basis()
            sage: uut = lambda i: sum(  y[j] for j in range(i+1,6)  ) # uni-upper
            sage: phi = X.module_morphism(uut, triangular=True, codomain = Y,
            ...        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)
            sage: phipro = phi.co_kernel_projection()
            sage: phipro(y[1] + y[2])
            B[1]
            sage: all(phipro(phi(x)).is_zero() for x in X.basis())
            True
            sage: phipro(y[1])
            B[1]
            sage: phipro(y[4])
            -B[5]
            sage: phipro(y[5])
            B[5]
        """
        category = ModulesWithBasis(self.codomain().base_ring()).or_subcategory(category)
        return SetMorphism(Hom(self.codomain(), self.codomain(), category),
                           self.co_reduced)

class DiagonalModuleMorphism(ModuleMorphismByLinearity):
    """
    A class for diagonal module morphisms.

    See :meth:`ModulesWithBasis.ParentMethods.module_morphism`

    Todo:

     - implement an optimized _call_ function
     - generalize to a mapcoeffs
     - generalize to a mapterms
    """

    def __init__(self, diagonal, domain, codomain = None, category = None):
        """
        INPUT:
         - domain, codomain: two modules with basis `F` and `G`
         - diagonal: a function `d`

        Assumptions:
         - `F` and `G` have the same base ring `R`
         - Their respective bases `f` and `g` have the same index set `I`
         - `d` is a function `I\mapsto R`

        Returns the diagonal module morphism from F to G which maps
        `f_\lambda` to `d(\lambda) g_\lambda`.

        By default, codomain is currently assumed to be domain
        (Todo: make a consistent choice with ModuleMorphism)

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X")
            sage: phi = X.module_morphism(diagonal = factorial, codomain = X)
            sage: x = X.basis()
            sage: phi(x[1]), phi(x[2]), phi(x[3])
            (B[1], 2*B[2], 6*B[3])

        TESTS::

            sage: phi.__class__
            <class 'sage.categories.modules_with_basis.DiagonalModuleMorphism'>
            sage: TestSuite(phi).run() # known issue; see ModuleMorphismByLinearity.__init__
            Failure in _test_category:
            ...
            The following tests failed: _test_category
        """
        assert codomain is not None
        assert domain.basis().keys() == codomain.basis().keys()
        assert domain.base_ring()    == codomain.base_ring()
        if category is None:
            category = ModulesWithBasis(domain.base_ring())
        ModuleMorphismByLinearity.__init__(self, domain = domain, codomain = codomain, category = category)
        self._diagonal = diagonal

    def _on_basis(self, i):
        """
        Returns the image by self of the basis element indexed by i

        TESTS::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); Y.rename("Y"); y = Y.basis()
            sage: phi = X.module_morphism(diagonal = factorial, codomain = X)
            sage: phi._on_basis(3)
            6*B[3]
        """
        return self.codomain().term(i, self._diagonal(i))

    def __invert__(self):
        """
        Returns the inverse diagonal morphism

        EXAMPLES::

            sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename("X"); x = X.basis()
            sage: Y = CombinatorialFreeModule(QQ, [1, 2, 3]); Y.rename("Y"); y = Y.basis()
            sage: phi = X.module_morphism(diagonal = factorial, codomain = X)
            sage: phi_inv = ~phi
            sage: phi_inv
            Generic endomorphism of Y
            sage: phi_inv(y[3])
            1/6*B[3]

        Caveat: this inverse morphism is only well defined if
        `d(\lambda)` is always invertible in the base ring. This is
        condition is *not* tested for, so using an ill defined inverse
        morphism will trigger arithmetic errors.
        """
        return self.__class__(
            pointwise_inverse_function(self._diagonal),
            domain = self.codomain(), codomain = self.domain(), category = self.category_for())


def pointwise_inverse_function(f):
    """
    INPUT:
     - f: a function

    Returns the function (...) -> 1 / f(...)

    EXAMPLES::

        sage: from sage.categories.modules_with_basis import pointwise_inverse_function
        sage: def f(x): return x
        ...
        sage: g = pointwise_inverse_function(f)
        sage: g(1), g(2), g(3)
        (1, 1/2, 1/3)

    pointwise_inverse_function is an involution::

        sage: f is pointwise_inverse_function(g)
        True

    Todo: this has nothing to do here!!! Should there be a library for
    pointwise operations on functions somewhere in Sage?

    """
    if hasattr(f, "pointwise_inverse"):
        return f.pointwise_inverse()
    else:
        return PointwiseInverseFunction(f)

from sage.structure.sage_object import SageObject
class PointwiseInverseFunction(SageObject):
    """
    A class for point wise inverse functions

    EXAMPLES::

        sage: from sage.categories.modules_with_basis import PointwiseInverseFunction
        sage: f = PointwiseInverseFunction(factorial)
        sage: f(0), f(1), f(2), f(3)
        (1, 1, 1/2, 1/6)
    """

    def __eq__(self, other):
        """
        TESTS::

            sage: from sage.categories.modules_with_basis import PointwiseInverseFunction
            sage: f = PointwiseInverseFunction(factorial)
            sage: g = PointwiseInverseFunction(factorial)
            sage: f is g
            False
            sage: f == g
            True
        """
        return self.__class__ is other.__class__ and self.__dict__ == other.__dict__

    def __init__(self, f):
        """
        TESTS::

            sage: from sage.categories.modules_with_basis import PointwiseInverseFunction
            sage: f = PointwiseInverseFunction(factorial)
            sage: f(0), f(1), f(2), f(3)
            (1, 1, 1/2, 1/6)
            sage: TestSuite(f).run()
        """
        self._pointwise_inverse = f

    def __call__(self, *args):
        """
        TESTS::

            sage: from sage.categories.modules_with_basis import PointwiseInverseFunction
            sage: g = PointwiseInverseFunction(operator.mul)
            sage: g(5,7)
            1/35
        """
        return ~(self._pointwise_inverse(*args))

    def pointwise_inverse(self):
        """
        TESTS::

            sage: from sage.categories.modules_with_basis import PointwiseInverseFunction
            sage: g = PointwiseInverseFunction(operator.mul)
            sage: g.pointwise_inverse() is operator.mul
            True
        """
        return self._pointwise_inverse
