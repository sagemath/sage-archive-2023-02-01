# -*- coding: utf-8 -*-
"""
Homology and cohomology with a basis

This module provides homology and cohomology vector spaces suitable
for computing cup products and cohomology operations.

REFERENCES:

.. [G-DR03] R. González-Díaz and P. Réal, "Computation of cohomology
            operations on finite simplicial complexes" in Homology,
            Homotopy and Applications 5 (2003), 83-93.

.. [G-DR99] R. González-Díaz and P. Réal, "A combinatorial method for
            computing Steenrod squares" in J. Pure Appl. Algebra 139
            (1999), 89-108.

AUTHORS:

- John H. Palmieri (2015-09)
"""


########################################################################
#       Copyright (C) 2015 John H. Palmieri <palmieri@math.washington.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#
#                  http://www.gnu.org/licenses/
########################################################################

from sage.combinat.free_module import CombinatorialFreeModule, CombinatorialFreeModuleElement

class HomologyVectorSpaceWithBasis(CombinatorialFreeModule):
    """Homology (or cohomology) vector space.

    This is intended to provide enough structure to allow the
    computation of cup products and cohomology operations. The former
    has been implemented, but not the latter (yet).

    It also requires field coefficients (hence the "VectorSpace" in
    the name of the class).

    .. note::

        This is not intended to be used directly by the user, but instead
        via the methods
        :meth:`cell_complex.CellComplex.homology_with_basis` and
        :meth:`cell_complex.CellComplex.cohomology_with_basis`.

    EXAMPLES:

    Homology classes are denoted by ``h_{d,i}`` where ``d`` is the
    degree of the homology class and ``i`` is their index in the list
    of basis elements. Cohomology classes are denoted ``h^{1,0}``::

        sage: RP2 = cubical_complexes.RealProjectivePlane()
        sage: RP2.homology_with_basis(1, GF(2))
        Free module generated by (h_{1,0},) over Finite Field of size 2
        sage: RP2.cohomology_with_basis(1, GF(2))
        Free module generated by (h^{1,0},) over Finite Field of size 2
        sage: simplicial_complexes.Torus().homology_with_basis(1, QQ)
        Free module generated by (h_{1,0}, h_{1,1}) over Rational Field

    To access a basis element, use its index (0 or 1 in the 1st
    cohomology group of a torus)::

        sage: H1 = simplicial_complexes.Torus().cohomology_with_basis(1, QQ)
        sage: H1.indices()
        {0, 1}
        sage: H1.basis()[0]
        h^{1,0}
        sage: H1.basis()[1]
        h^{1,1}

    You can then form linear combinations of these easily enough::

        sage: x = H1.basis()[0]
        sage: y = H1.basis()[1]
        sage: 2*x-3*y
        2*h^{1,0} - 3*h^{1,1}

    Or you can use the :meth:`from_vector` method to do this in one step::

        sage: H1.from_vector(vector((2, -3)))
        2*h^{1,0} - 3*h^{1,1}

    You can compute cup products of cohomology classes::

        sage: x.cup_product(y)
        h^{2,0}
        sage: y.cup_product(x)
        -h^{2,0}
        sage: x.cup_product(x)
        0

    This works with both simplicial complexes and cubical complexes::

        sage: Klein_c = cubical_complexes.KleinBottle()
        sage: H1 = Klein_c.cohomology_with_basis(1, GF(2))
        sage: x,y = H1.basis()
        sage: x.cup_product(x)
        h^{2,0}
        sage: x.cup_product(y)
        0
        sage: y.cup_product(y)
        h^{2,0}

        sage: Klein_s = simplicial_complexes.KleinBottle()
        sage: H1 = Klein_s.cohomology_with_basis(1, GF(2))
        sage: a,b = H1.basis()

    The basis elements have been chosen differently; apply the change
    of basis `x \mapsto a+b`, `y \mapsto b` to see the same product
    structure. ::

        sage: a.cup_product(a)
        0
        sage: a.cup_product(b)
        h^{2,0}
        sage: (a+b).cup_product(a+b)
        h^{2,0}
        sage: b.cup_product(b)
        h^{2,0}

    """
    def __init__(self, deg, contraction, cell_complex):
        """
        INPUTS:

        - ``deg`` -- the degree of this homology group
        - ``contraction`` -- the chain contraction associated to this
          homology computation
        - ``cell_complex`` -- the cell complex whose homology we are
          computing

        EXAMPLES::

            sage: RP2 = simplicial_complexes.ProjectivePlane()
            sage: RP2.homology_with_basis(1, QQ) # indirect doctest
            Free module generated by () over Rational Field
            sage: RP2.homology_with_basis(1, GF(2))
            Free module generated by (h_{1,0},) over Finite Field of size 2
            sage: RP2.cohomology_with_basis(1, GF(2))
            Free module generated by (h^{1,0},) over Finite Field of size 2
            sage: RP2.cohomology_with_basis(1, GF(5))
            Free module generated by () over Finite Field of size 5
        """
        self._contraction = contraction
        # M is the homology chain complex.
        M = self._contraction.pi()._codomain
        self._degree = deg
        self._complex = cell_complex
        rank = M.free_module_rank(deg)
        # Homology vs. cohomology is detected by the degree of the
        # differential in the relevant chain complexes:
        self._cohomology = (M.degree_of_differential() == 1)
        CombinatorialFreeModule.__init__(self, M.base_ring(), range(rank))

    def degree(self):
        """
        The degree of this homology group: if this is `H_n(K)` for some
        complex `K`, return `n`.

        EXAMPLES::

            sage: H2 = simplicial_complexes.Torus().homology_with_basis(2, GF(7))
            sage: H2.degree()
            2
        """
        return self._degree

    def contraction(self):
        r"""
        The chain contraction associated to this homology computation.

        That is, to work with chain representatives of homology
        classes, we need the chain complex `C` associated to the cell
        complex, the chain complex `H` of its homology (with trivial
        differential), chain maps `\pi: C \to H` and `\iota: H \to C`,
        and a chain contraction `\phi` giving a chain homotopy between
        `1_C` and `\iota \circ \pi`.

        OUTPUT: `\phi`

        See :class:`chain_homotopy.ChainContraction` for information
        about chain contractions, and see
        :func:`algebraic_topological_model.algebraic_topological_model`
        for the construction of this particular chain contraction
        `\phi`.

        EXAMPLES::

            sage: H1 = simplicial_complexes.Simplex(2).homology_with_basis(1, QQ)
            sage: H1.contraction()
            Chain homotopy between Chain complex morphism from Chain complex with at most 3 nonzero terms over Rational Field to Chain complex with at most 3 nonzero terms over Rational Field and Chain complex morphism from Chain complex with at most 3 nonzero terms over Rational Field to Chain complex with at most 3 nonzero terms over Rational Field

        From the chain contraction, one can also recover the maps `\pi` and `\iota`::

            sage: phi = H1.contraction()
            sage: phi.pi()
            Chain complex morphism from Chain complex with at most 3 nonzero terms over Rational Field to Chain complex with at most 1 nonzero terms over Rational Field
            sage: phi.iota()
            Chain complex morphism from Chain complex with at most 1 nonzero terms over Rational Field to Chain complex with at most 3 nonzero terms over Rational Field
        """
        return self._contraction

    def complex(self):
        """
        The cell complex whose homology is being computed.

        EXAMPLES::

            sage: H1 = simplicial_complexes.Simplex(2).homology_with_basis(1, QQ)
            sage: H1.complex()
            Simplicial complex with vertex set (0, 1, 2) and facets {(0, 1, 2)}
        """
        return self._complex

    def _repr_(self):
        """
        EXAMPLES::

            sage: simplicial_complexes.Torus().homology_with_basis(1, QQ)
            Free module generated by (h_{1,0}, h_{1,1}) over Rational Field
        """
        return "Free module generated by {} over {}".format(tuple(self.basis()), self.base_ring())

    def _repr_term(self, i):
        """
        Return 'h_{d,i}' for the ith generator in degree d for homology,
        'h^{d,i}' for cohomology.

        EXAMPLES::

            sage: H1 = simplicial_complexes.Torus().homology_with_basis(1, QQ)
            sage: H1.basis()[0] # indirect doctest
            h_{1,0}
            sage: latex(H1.basis()[1]) # indirect doctest
            h_{1,1}
            sage: co = simplicial_complexes.KleinBottle().homology_with_basis(1, GF(2), cohomology=True)
            sage: co.basis()[0] # indirect doctest
            h^{1,0}
        """
        sym = '^' if self._cohomology else '_'
        return 'h{}{{{},{}}}'.format(sym, self.degree(), i)

    _latex_term = _repr_term

    # We need an element class so we can apply iota to the elements,
    # compute cup products, Steenrod operations, etc.

    class Element(CombinatorialFreeModuleElement):

        def to_cycle(self):
            r"""
            (Co)cycle representative of this (co)homology class.

            EXAMPLES::

                sage: S2 = simplicial_complexes.Sphere(2)
                sage: H2 = S2.homology_with_basis(2, QQ)
                sage: H2.basis()[0]
                h_{2,0}
                sage: H2.basis()[0].to_cycle()
                -(0, 1, 2) + (0, 1, 3) - (0, 2, 3) + (1, 2, 3)

            Chains are written as linear combinations of simplices
            `\sigma`. Cochains are written as linear combinations of
            characteristic functions `\chi_{\sigma}` for those
            simplices::

                sage: S2.cohomology_with_basis(2, QQ).basis()[0].to_cycle()
                \chi_(0, 1, 3)
                sage: S2.cohomology_with_basis(0, QQ).basis()[0].to_cycle()
                \chi_(0,) + \chi_(1,) + \chi_(2,) + \chi_(3,)
            """
            deg = self.parent().degree()
            vec = self.parent().contraction().iota().in_degree(deg) * self.to_vector()
            chains = self.parent().complex().n_chains(deg, self.base_ring(),
                                                   cochains=self.parent()._cohomology)
            return chains.from_vector(vec)

        def cup_product(self, other):
            r"""
            The cup product of this element with ``other``.

            INPUTS:

            - ``other`` -- a cohomology class from the same cell complex.

            Algorithm: see González-Díaz and Réal [G-DR03]_, p. 88.
            Given two cohomology classes, lift them to cocycle
            representatives using :meth:`to_cycle`. In the sum of
            their dimensions, look at all of the homology classes
            `\gamma`: lift each of those to a cycle representative,
            apply the Alexander-Whitney diagonal map to each cell in
            the cycle, evaluate the two cocycles on these factors, and
            multiply. The result is the value of the cup product
            cocycle on this homology class. After this has been done
            for all homology classes, since homology and cohomology
            are dual, one can tell which cohomology class corresponds
            to the cup product.

            EXAMPLES::

                sage: RP3 = simplicial_complexes.RealProjectiveSpace(3)
                sage: H1 = RP3.cohomology_with_basis(1, GF(2))
                sage: c = H1.basis()[0]
                sage: c.cup_product(c).cup_product(c)
                h^{3,0}

                sage: T = simplicial_complexes.Torus()
                sage: x,y = list(T.cohomology_with_basis(1, QQ).basis())
                sage: x.cup_product(y)
                h^{2,0}
                sage: x.cup_product(x)
                0

                sage: one = T.cohomology_with_basis(0, QQ).basis()[0]
                sage: x.cup_product(one)
                h^{1,0}
                sage: one.cup_product(y) == y
                True
                sage: one.cup_product(one)
                h^{0,0}
                sage: x.cup_product(y) + y.cup_product(x)
                0

            This also works with cubical complexes::

                sage: T = cubical_complexes.Torus()
                sage: x,y = list(T.cohomology_with_basis(1, QQ).basis())
                sage: x.cup_product(y)
                -h^{2,0}
                sage: x.cup_product(x)
                0
            """
            complex = self.parent().complex()
            base_ring = self.base_ring()
            assert (complex == other.parent().complex()
                    and self.parent()._cohomology
                    and other.parent()._cohomology), 'these are not cohomology classes from the same complex'
            deg_left = self.parent().degree()
            deg_right = other.parent().degree()
            deg_tot = deg_left + deg_right
            result = []
            for gamma in complex.homology_with_basis(deg_tot, base_ring).basis():
                gamma_coeff = base_ring.zero()
                for cell, coeff in gamma.to_cycle():
                    for (c, left_cell, right_cell) in cell.alexander_whitney(deg_left):
                        left = complex.n_chains(deg_left, base_ring)(left_cell)
                        right = complex.n_chains(deg_right, base_ring)(right_cell)
                        gamma_coeff += c * coeff * self.to_cycle().eval(left) * other.to_cycle().eval(right)
                result.append((gamma.leading_support(), gamma_coeff))
            return complex.cohomology_with_basis(deg_tot, base_ring).sum_of_terms(result)

        def Sq(self, i):
            r"""
            Return the result of applying Sq^i to this element.

            INPUT:

            - ``i`` -- nonnegative integer

            .. warning::

               This is only implemented for simplicial complexes, not
               cubical complexes.

            This cohomology operation is only defined in
            characteristic 2.

            Algorithm: see González-Díaz and Réal [G-DR99]_, Corollary
            3.2.

            EXAMPLES::

                sage: RP2 = simplicial_complexes.RealProjectiveSpace(2)
                sage: x = RP2.cohomology_with_basis(1, GF(2)).basis()[0]
                sage: x.Sq(1)
                h^{2,0}

                sage: K = RP2.suspension()
                sage: K.set_immutable()
                sage: y = K.cohomology_with_basis(2, GF(2)).basis()[0]
                sage: y.Sq(1)
                h^{3,0}

                sage: RP4 = simplicial_complexes.RealProjectiveSpace(4)
                sage: x = RP4.cohomology_with_basis(1, GF(2)).basis()[0] # long time
                sage: y = RP4.cohomology_with_basis(2, GF(2)).basis()[0] # long time
                sage: z = RP4.cohomology_with_basis(3, GF(2)).basis()[0] # long time
                sage: x.Sq(1)  # long time
                h^{2,0}
                sage: y.Sq(1)  # long time
                0
                sage: y.Sq(2)  # long time
                h^{4,0}
                sage: z.Sq(1)  # long time
                h^{4,0}

            TESTS::

                sage: T = cubical_complexes.Torus()
                sage: x = T.cohomology_with_basis(1, GF(2)).basis()[0]
                sage: x.Sq(1)
                Traceback (most recent call last):
                ...
                NotImplementedError: Steenrod squares are only implemented for simplicial complexes
                sage: S2 = simplicial_complexes.Sphere(2)
                sage: x = S2.cohomology_with_basis(2, GF(7)).basis()[0]
                sage: x.Sq(1)
                Traceback (most recent call last):
                ...
                ValueError: Steenrod squares are only defined in characteristic 2                
            """
            from simplicial_complex import SimplicialComplex
            complex = self.parent().complex()
            if not isinstance(complex, SimplicialComplex):
                raise NotImplementedError('Steenrod squares are only implemented for simplicial complexes')
            base_ring = self.base_ring()
            if base_ring.characteristic() != 2:
                raise ValueError('Steenrod squares are only defined in characteristic 2')
            # We keep the same notation as in [G-DR99].
            j = self.parent().degree()
            m = j+i
            # The trivial cases:
            if i == 0:
                # Sq^0 is the identity.
                return self
            target = complex.cohomology_with_basis(m, base_ring)
            if target.dimension() == 0:
                return target.zero()
            if i > j:
                return target.zero()
            if i == j:
                return self.cup_product(self)
            n = j-i
            # Now assemble the indices over which the sums take place.
            # S(n) is defined to be floor((m+1)/2) + floor(n/2).
            S_n = (m+1)//2 + n//2
            if n == 0:
                sums = [[S_n]]
            else:
                sums = []
                for i_n in range(S_n, m+1):
                    sums.extend([[i_n] + _ for _ in sum_indices(n-1, i_n, S_n)])
            # At this point, 'sums' is a list of lists of the form
            # [i_n, i_{n-1}, ..., i_0]. (It is reversed from the
            # obvious order because this is closer to the order in
            # which the face maps will be applied.)  Now we sum over
            # these, according to the formula in [G-DR99], Corollary
            # 3.2.
            result = []
            cycle = self.to_cycle()
            for gamma in complex.homology_with_basis(m, base_ring).basis():
                gamma_coeff = base_ring.zero()
                for cell, coeff in gamma.to_cycle():
                    for indices in sums:
                        indices = list(indices)
                        left = cell
                        right = cell
                        # Since we are working with a simplicial complex, 'cell' is a simplex.
                        if not m % 2:
                            left_endpoint = m
                            while indices:
                                right_endpoint = indices[0]-1
                                for k in range(left_endpoint, indices.pop(0), -1):
                                    left = left.face(k)
                                try:
                                    left_endpoint = indices[0]-1
                                    for k in range(right_endpoint, indices.pop(0), -1):
                                        right = right.face(k)
                                except IndexError:
                                    pass
                            for k in range(right_endpoint, -1, -1):
                                right = right.face(k)
                        else:
                            right_endpoint = m
                            while indices:
                                left_endpoint = indices[0]-1
                                try:
                                    for k in range(right_endpoint, indices.pop(0), -1):
                                        right = right.face(k)
                                    right_endpoint = indices[0]-1
                                except IndexError:
                                    pass
                                for k in range(left_endpoint, indices.pop(0), -1):
                                    left = left.face(k)
                            for k in range(right_endpoint, -1, -1):
                                right = right.face(k)

                        left = complex.n_chains(j, base_ring)(left)
                        right = complex.n_chains(j, base_ring)(right)
                        gamma_coeff += coeff * cycle.eval(left) * cycle.eval(right)
                result.append((gamma.leading_support(), gamma_coeff))
            return complex.cohomology_with_basis(m, base_ring).sum_of_terms(result)


def sum_indices(k, i_k_plus_one, S_k_plus_one):
    """This is a recursive function for computing the indices for the
    nested sums in González-Díaz and Réal [G-DR99]_, Corollary 3.2.

    In the paper, given indices `i_n`, `i_{n-1}`, ..., `i_{k+1}`,
    given `k`, and given `S(k+1)`, the number `S(k)` is defined to be

    .. math::

        S(k) = -S(k+1) + floor(k/2) + floor((k+1)/2) + i_{k+1},

    and `i_k` ranges from `S(k)` to `i_{k+1}-1`. There are two special
    cases: if `k=0`, then `i_0 = S(0)`. Also, the initial case of
    `S(k)` is `S(n)`, which is set in the method :meth:`Sq` before
    calling this function. For this function, given `k`, `i_{k+1}`,
    and `S(k+1)`, return a list consisting of the allowable possible
    indices `[i_k, i_{k-1}, ..., i_1, i_0]` given by the above
    formula.

    INPUTS:

    - ``k`` -- non-negative integer
    - ``i_k_plus_one`` -- the positive integer `i_{k+1}`
    - ``S_k_plus_one`` -- the integer `S(k+1)`

    EXAMPLES::

        sage: from sage.homology.homology_vector_space_with_basis import sum_indices
        sage: sum_indices(1, 3, 3)
        [[1, 0], [2, 1]]
        sage: sum_indices(0, 4, 2)
        [[2]]

    """
    S_k = -S_k_plus_one + k//2 + (k+1)//2 + i_k_plus_one
    if k == 0:
        return [[S_k]]
    ans = []
    for i_k in range(S_k, i_k_plus_one):
        ans.extend([[i_k] + _ for _ in sum_indices(k-1, i_k, S_k)])
    return ans

